import{_ as e,c as i,a,o as r}from"./app-7eKjwDat.js";const n={};function t(o,l){return r(),i("div",null,l[0]||(l[0]=[a('<h1 id="chapter-3-5-经典垃圾收集器" tabindex="-1"><a class="header-anchor" href="#chapter-3-5-经典垃圾收集器"><span>Chapter 3.5 - 经典垃圾收集器</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 01 / 26 16:26 🧨🧧</p><p>Ningbo, Zhejiang, China</p><hr><h2 id="_3-5-经典垃圾收集器" tabindex="-1"><a class="header-anchor" href="#_3-5-经典垃圾收集器"><span>3.5 经典垃圾收集器</span></a></h2><p>到目前为止还没有最好的垃圾收集器出现，也不存在万能的收集器。</p><h3 id="_3-5-1-serial-收集器" tabindex="-1"><a class="header-anchor" href="#_3-5-1-serial-收集器"><span>3.5.1 Serial 收集器</span></a></h3><p>Serial 收集器是最基础、历史最悠久的收集器。该收集器是一个单线程工作的收集器，在进行垃圾收集时，必须暂停其它所有工作线程，直至收集结束，即 <em>Stop The World</em>。</p><blockquote><p>相当于妈妈给你打扫房间，你只能要么在椅子上，要么在房间外面等着。</p></blockquote><p>简单、高效。新生代 Serial 使用标记/复制算法，对于单核 CPU 或 CPU 核心数较少的环境来说，可以获得最高的单线程收集效率。</p><h3 id="_3-5-2-parnew-收集器" tabindex="-1"><a class="header-anchor" href="#_3-5-2-parnew-收集器"><span>3.5.2 ParNew 收集器</span></a></h3><p>是 Serial 收集器的多线程并行版本。在 GC 时，同时使用多个线程，在单核心处理器下，不可能会比 Serial 有更好的效果。是一个新生代收集器，已经退出历史舞台。</p><h3 id="_3-5-3-parallel-scavenge-收集器" tabindex="-1"><a class="header-anchor" href="#_3-5-3-parallel-scavenge-收集器"><span>3.5.3 Parallel Scavenge 收集器</span></a></h3><ul><li>新生代收集器</li><li>基于标记/复制算法</li><li>并行收集的多线程收集器</li></ul><p>收集器的目标不是缩短用于线程的停顿时间，而是达到一个可控制的吞吐量：CPU 用于运行用户线程的时间与 CPU 总耗时的比值。</p><blockquote><p>用户停顿时间和吞吐量的区别</p><p>比如，把新生代内存区调小一些，每次 GC 可以更快，用户停顿时间较小；然而，这样会导致 GC 的频率变高。相同的一段时间内，GC 频率高了，虽然每次 GC 的时间短了，但总体上用于执行 GC 的时间多了，用于执行用户线程的 CPU 时间自然就减少了。</p></blockquote><p>因此，在后台计算、不需要太多交互性的分析型任务应当更追求吞吐率。</p><h3 id="_3-5-4-serial-old-收集器" tabindex="-1"><a class="header-anchor" href="#_3-5-4-serial-old-收集器"><span>3.5.4 Serial Old 收集器</span></a></h3><p>是 Serial 收集器的老年代版本，是一个单线程收集器。使用标记/整理算法。</p><h3 id="_3-5-5-parallel-old-收集器" tabindex="-1"><a class="header-anchor" href="#_3-5-5-parallel-old-收集器"><span>3.5.5 Parallel Old 收集器</span></a></h3><p>是 Parallel Scavenge 收集器的老年代版本，支持多线程并发收集，基于标记/整理算法。</p><h3 id="_3-5-6-cms-concurrent-mark-sweep-收集器" tabindex="-1"><a class="header-anchor" href="#_3-5-6-cms-concurrent-mark-sweep-收集器"><span>3.5.6 CMS (Concurrent Mark Sweep) 收集器</span></a></h3><p>以获取 <strong>最短回收停顿时间</strong> 为目标的 <strong>老年代</strong> 收集器。一些基于 Web 的 Java 应用会较为关注服务的响应速度，希望停顿时间尽可能短，给用户带来良好的交互体验。CMS 收集器基于标记/清除算法实现，分为四个阶段：</p><ol><li>初始标记 (CMS initial mark) <ul><li><strong>Stop The World</strong></li><li>标记 GC Roots 能直接关联到的对象，速度很快</li></ul></li><li>并发标记 (CMS concurrent mark) <ul><li>遍历对象图</li><li>耗时较长，但可以与用户线程并发</li></ul></li><li>重新标记 (CMS remark) <ul><li><strong>Stop The World</strong></li><li>修正并发标记期间导致标记变动的对象</li></ul></li><li>并发清除 (CMS concurrent sweep) <ul><li>清理标记后已经死亡的对象</li><li>不需要移动存活对象，因此可以与用户线程并发</li></ul></li></ol><p>特性：并发收集、低停顿。</p><p>缺点：</p><ol><li>CMS 对 CPU 资源非常敏感 <ul><li>由于在并发时占用了一定线程，将导致应用程序变慢，总吞吐量降低</li></ul></li><li>无法处理 <em>浮动垃圾 (Floating Garbage)</em><ul><li>在并发标记或并发清理阶段，用户线程还是会产生垃圾</li><li>这些垃圾只能在下一次 GC 时才被清理 - 浮动垃圾</li><li>如果此时用户线程需要的内存已经不够用了，就会触发 Stop The World 并进行一次 Full GC <ul><li>并发失败 (Concurrent Mode Failure)</li><li>冻结用户线程，启动 Serial Old 进行老年代垃圾收集</li></ul></li><li>因此，CMS 收集器在老年代使用到一定空间后就要被激活工作</li></ul></li><li>基于标记/清除算法，导致大量内存碎片的产生 <ul><li>进而也会导致 Full GC</li></ul></li></ol><h3 id="_3-5-7-garbage-first-g1-收集器" tabindex="-1"><a class="header-anchor" href="#_3-5-7-garbage-first-g1-收集器"><span>3.5.7 Garbage First (G1) 收集器</span></a></h3><p>被 <em>Oracle</em> 官方称为全功能垃圾收集器 (Fully-Featured Garbage Collector)，是一款主要面向 <strong>服务端应用</strong> 的垃圾收集器，希望能在未来替代 CMS 收集器。G1 可以面向堆内存的任何部分组成回收集 (Collection Set) 进行回收，不管是新生代还是老年代。衡量标准不再是分代，而是哪块内存的垃圾多，回收收益最大。</p><p>G1 不再坚持固定大小或固定数量的分代区域划分，而是将连续的 Java 堆划分为多个大小相等的独立区域 (Region)，每个 Region 可以根据需要扮演新生代或老年代的角色。Region 中还有专门用于存储大对象的 Humongous 区域。Region 是单次回收的最小单元。G1 追踪每个 Region 中垃圾堆积的价值大小，以允许的收集停顿时间为参数，优先处理回收价值最大的 Region (Garbage First 的由来)。</p><p>为保证 G1 收集器在有限的时间内获得尽可能高的收集效率：</p><ul><li>Region 间的引用问题如何解决？ <ul><li>每个 Region 都维护自己的记忆集</li><li>存储了双向卡表 (我指向谁，谁指向我)</li><li>G1 有着更高的内存负担</li></ul></li><li>如何保证收集线程与用户线程互不干扰地运行？ <ul><li>G1 使用 SATB 算法实现</li><li>划分出 Region 的一部分空间用于并发回收过程中的新对象分配</li><li>如果内存回收速度赶不上内存分配速度，G1 也要被迫冻结用户线程</li></ul></li><li>如何建立可靠的停顿预测模型？ <ul><li>G1 会记录每个 Region 的回收耗时等统计信息</li><li>预测哪些 Region 组成的回收集可以在不超过停顿时间的约束下获得最高的收益</li></ul></li></ul><p>G1 的运作过程可划分为以下四个步骤：</p><ul><li>初始标记 (Initial Marking) <ul><li>标记 GC Roots 能直接关联到的对象</li><li>需要 <strong>停顿线程</strong>，但耗时很短</li></ul></li><li>并发标记 (Concurrent Marking) <ul><li>从 GC Roots 开始对对堆中的对象进行可达性分析</li></ul></li><li>最终标记 (Final Marking) <ul><li>对用户线程做 <strong>短暂的暂停</strong></li><li>处理并发结束后少量的 SATB 记录</li></ul></li><li>筛选回收 (Live Data Counting and Evacuation) <ul><li>更新 Region 的统计数据，对各 Region 的回收价值和成本进行排序</li><li>选择任意多个 Region 作为回收集，将决定回收的 Region 中的存活对象复制到空的 Region 中，再清理旧 Region 的全部空间</li><li>需要 <strong>暂停用户线程</strong>，由多个收集器线程并行完成</li></ul></li></ul><p>G1 的目标是在延迟可控的前提下，获得尽可能高的吞吐量，可以 <strong>由用户指定期望停顿时间</strong> 是 G1 的一个很强大的功能。但是也别自己作死把期望停顿时间调得很小，这样 G1 计算得出每次只能 GC 很少的 Region 才能满足停顿时间的要求，回收速度跟不上分配速度，导致垃圾堆积，最终导致 Full GC 反而降低性能。</p><p>从 G1 开始，垃圾收集器的设计导向变为，追求 GC 速度能够应付内存分配速率。</p><p>G1 的特性：</p><ul><li>G1 运作期间不会产生内存碎片 <ul><li>从整体来看是基于标记/整理算法实现的</li><li>从局部上看是基于标记/复制算法实现的</li><li>有利于程序长时间运行</li></ul></li><li>G1 为了 GC 而产生的内存占用和运行时额外开销都比 CMS 高</li><li>G1 的记忆集消耗可能会占堆的 20% 乃至更多空间</li><li>CMS 和 G1 都用到了写屏障 <ul><li>由于 G1 写屏障中的操作更为复杂</li><li>CMS 的写屏障是直接的同步操作</li><li>G1 的写屏障是消息队列 + 异步处理</li></ul></li></ul>',39)]))}const p=e(n,[["render",t],["__file","Chapter 3.5 - 经典垃圾收集器.html.vue"]]),g=JSON.parse('{"path":"/understanding-the-jvm-notes/Part%202%20-%20%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Chapter%203.5%20-%20%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.html","title":"Chapter 3.5 - 经典垃圾收集器","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"3.5 经典垃圾收集器","slug":"_3-5-经典垃圾收集器","link":"#_3-5-经典垃圾收集器","children":[{"level":3,"title":"3.5.1 Serial 收集器","slug":"_3-5-1-serial-收集器","link":"#_3-5-1-serial-收集器","children":[]},{"level":3,"title":"3.5.2 ParNew 收集器","slug":"_3-5-2-parnew-收集器","link":"#_3-5-2-parnew-收集器","children":[]},{"level":3,"title":"3.5.3 Parallel Scavenge 收集器","slug":"_3-5-3-parallel-scavenge-收集器","link":"#_3-5-3-parallel-scavenge-收集器","children":[]},{"level":3,"title":"3.5.4 Serial Old 收集器","slug":"_3-5-4-serial-old-收集器","link":"#_3-5-4-serial-old-收集器","children":[]},{"level":3,"title":"3.5.5 Parallel Old 收集器","slug":"_3-5-5-parallel-old-收集器","link":"#_3-5-5-parallel-old-收集器","children":[]},{"level":3,"title":"3.5.6 CMS (Concurrent Mark Sweep) 收集器","slug":"_3-5-6-cms-concurrent-mark-sweep-收集器","link":"#_3-5-6-cms-concurrent-mark-sweep-收集器","children":[]},{"level":3,"title":"3.5.7 Garbage First (G1) 收集器","slug":"_3-5-7-garbage-first-g1-收集器","link":"#_3-5-7-garbage-first-g1-收集器","children":[]}]}],"git":{},"filePathRelative":"understanding-the-jvm-notes/Part 2 - 自动内存管理/Chapter 3.5 - 经典垃圾收集器.md"}');export{p as comp,g as data};
