import{_ as i,c as a,a as e,o as n}from"./app-BeHGwf2X.js";const s={};function t(r,l){return n(),a("div",null,l[0]||(l[0]=[e('<h1 id="chapter-11-3-11-4-提前编译器-编译器优化技术" tabindex="-1"><a class="header-anchor" href="#chapter-11-3-11-4-提前编译器-编译器优化技术"><span>Chapter 11.3-11.4 - 提前编译器 &amp;&amp; 编译器优化技术</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 02 / 02 22:29 🧨🧧</p><p>Ningbo, Zhejiang, China</p><hr><h2 id="_11-3-提前编译器" tabindex="-1"><a class="header-anchor" href="#_11-3-提前编译器"><span>11.3 提前编译器</span></a></h2><h3 id="_11-3-1-提前编译的优劣得失" tabindex="-1"><a class="header-anchor" href="#_11-3-1-提前编译的优劣得失"><span>11.3.1 提前编译的优劣得失</span></a></h3><p>提前编译 (Ahead Of Time, AOT) 在 Java 中的价值直指即时编译的最大弱点：即时编译需要占用运行时资源。比如，编译时最耗时的优化措施是进行 <em>过程间分析</em>，必须在全程序范围内做大量耗时计算工作。目前常见的 JVM 都是通过大规模的函数内联 + 过程内分析来模拟过程间分析。提前编译的本质是给即时编译器做缓存加速，改善 Java 启动后需要一段时间的预热才能到达最高性能的问题。</p><p>提前编译不仅要和目标机器相关，还需要与 JVM 运行时的参数绑定。即时编译器相对于提前编译器的天然优势：</p><ol><li>性能分析制导优化 (Profile-Guided Optimization, PGO) <ul><li>解释器和客户端编译器会不断收集性能监控信息</li><li>这些信息在静态分析时是无法得到的</li><li>动态运行时可以看出其偏好性</li></ul></li><li>激进预测性优化 (Aggressive Speculative Optimization) <ul><li>性能监控信息能够支持一些正确可能性很大的预测，就可以按高概率的假设进行优化</li><li>万一真的出现了错误预测，大不了退回到低级编译器甚至解释器上执行</li><li>只要出错的概率足够低，这样的优化就能大幅降低目标复杂度</li></ul></li><li>链接时优化 (Link-Time Optimization, LTO) <ul><li>Java 语言天生就是动态链接的</li><li>C/C++ 的主程序与动态链接库在编译时完全独立，不能联合优化</li></ul></li></ol><h2 id="_11-4-编译器优化技术" tabindex="-1"><a class="header-anchor" href="#_11-4-编译器优化技术"><span>11.4 编译器优化技术</span></a></h2><h3 id="_11-4-2-方法内联" tabindex="-1"><a class="header-anchor" href="#_11-4-2-方法内联"><span>11.4.2 方法内联</span></a></h3><p>把目标代码原封不动地复制到发起调用的代码中，避免发生真实的函数调用。JVM 引入了 <strong>类型继承关系分析</strong> (Class Hierarchy Analysis, CHA) 技术，确定类型之间的关系</p><ul><li>对于非虚函数，可以直接内联</li><li>对于虚函数 <ul><li>如果 CHA 只查询到只有一个目标版本，则进行 <strong>守护内联</strong> (Guarded Inlining)</li><li>由于 Java 的动态链接性，如果有新的类型加载，改变了 CHA 的结论，则发生 <strong>激进预测性优化</strong>，需要放弃已经编译的代码，回退到解释器或重新编译</li><li>如果 CHA 确认有多个版本的目标函数可供选择，使用内联缓存来缩减函数调用开销 <ul><li>缓存建立在目标函数的入口之前</li><li>缓存记录函数接收者的类型，并在每次函数调用时都比较接收者的版本</li><li>如果每次接收者都是一样的，则是单态内联缓存</li><li>如果出现了接收者不一致，则退化为超多态内联缓存，相当于查虚函数表进行函数分派</li></ul></li></ul></li></ul><h3 id="_11-4-3-逃逸分析-escape-analysis" tabindex="-1"><a class="header-anchor" href="#_11-4-3-逃逸分析-escape-analysis"><span>11.4.3 逃逸分析 (Escape Analysis)</span></a></h3><p>分析对象的动态作用域，划分逃逸程度：</p><ul><li>从不逃逸</li><li>函数逃逸 - 对象在函数中被定义后，可能作为参数被外部函数引用</li><li>线程逃逸 - 对象会被外部线程访问到</li></ul><p>如果一个对象逃逸程度较低，就可能进行不同程度的优化：</p><ul><li>栈上分配 (Stack Allocation) <ul><li>确定一个对象不会逃逸出线程，那么可以在栈上为其分配内存，而不是在 Java Heap 上</li><li>对象占用的内存随栈帧出栈而被销毁</li><li>从不逃逸和函数逃逸的对象占比很高，大量对象会随着函数结束而自动销毁，GC 子系统压力下降</li><li>不支持线程逃逸</li></ul></li><li>标量替换 (Scalar Replacement) <ul><li>标量指不可再分为更小数据的数据，比如原始数据类型</li><li>将对象用到的成员变量恢复为原始类型来访问</li><li>程序执行时可以不创建对象，只创建使用到的成员即可</li><li>栈上分配 + 后续优化</li><li>不支持函数逃逸</li></ul></li><li>同步消除 (Synchronization Elimination) <ul><li>如果确定变量不会线程逃逸，对变量的所有同步措施可以安全地消除掉</li></ul></li></ul><p>逃逸计算的成本非常高，且不能保证逃逸分析带来的性能收益会高于消耗。所以 JVM 中只能采用不那么准确，但时间压力较小的算法。逃逸分析可能出现效果不稳定的情况，或分析过程耗时却无法辨别出非逃逸对象，导致性能下降。</p><h3 id="_11-4-4-公共子表达式消除" tabindex="-1"><a class="header-anchor" href="#_11-4-4-公共子表达式消除"><span>11.4.4 公共子表达式消除</span></a></h3><p>不重复计算已经计算过的表达式。</p><h3 id="_11-4-5-数组边界检查消除" tabindex="-1"><a class="header-anchor" href="#_11-4-5-数组边界检查消除"><span>11.4.5 数组边界检查消除</span></a></h3><p>在 Java 中会对数组访问自动进行上下界的范围检查，因此每次数组元素的读写都带有一次隐含的条件判定操作。对于拥有大量数组访问的程序，是一种性能负担。对于可以确定合法范围的数组访问，尽可能将运行期检查提前到编译期内完成，可以省掉数组的上下界检查。</p>',24)]))}const p=i(s,[["render",t],["__file","Chapter 11.3-11.4 - 提前编译器 __ 编译器优化技术.html.vue"]]),_=JSON.parse('{"path":"/understanding-the-jvm-notes/Part%204%20-%20%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/Chapter%2011.3-11.4%20-%20%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91%E5%99%A8%20__%20%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF.html","title":"Chapter 11.3-11.4 - 提前编译器 && 编译器优化技术","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"11.3 提前编译器","slug":"_11-3-提前编译器","link":"#_11-3-提前编译器","children":[{"level":3,"title":"11.3.1 提前编译的优劣得失","slug":"_11-3-1-提前编译的优劣得失","link":"#_11-3-1-提前编译的优劣得失","children":[]}]},{"level":2,"title":"11.4 编译器优化技术","slug":"_11-4-编译器优化技术","link":"#_11-4-编译器优化技术","children":[{"level":3,"title":"11.4.2 方法内联","slug":"_11-4-2-方法内联","link":"#_11-4-2-方法内联","children":[]},{"level":3,"title":"11.4.3 逃逸分析 (Escape Analysis)","slug":"_11-4-3-逃逸分析-escape-analysis","link":"#_11-4-3-逃逸分析-escape-analysis","children":[]},{"level":3,"title":"11.4.4 公共子表达式消除","slug":"_11-4-4-公共子表达式消除","link":"#_11-4-4-公共子表达式消除","children":[]},{"level":3,"title":"11.4.5 数组边界检查消除","slug":"_11-4-5-数组边界检查消除","link":"#_11-4-5-数组边界检查消除","children":[]}]}],"git":{},"filePathRelative":"understanding-the-jvm-notes/Part 4 - 程序编译与代码优化/Chapter 11.3-11.4 - 提前编译器 && 编译器优化技术.md"}');export{p as comp,_ as data};
