import{_ as e,c as n,a as i,o as p}from"./app-BeHGwf2X.js";const r="/blog/assets/spring-cloud-server-CCApSznr.png",l={};function d(c,o){return p(),n("div",null,o[0]||(o[0]=[i('<h1 id="chapter-3-使用-spring-cloud-配置服务器控制配置" tabindex="-1"><a class="header-anchor" href="#chapter-3-使用-spring-cloud-配置服务器控制配置"><span>Chapter 3 - 使用 Spring Cloud 配置服务器控制配置</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 08 / 13 16:50</p><p>@Nanjing, Jiangsu, China</p><hr><h2 id="_3-1-管理配置的复杂性" tabindex="-1"><a class="header-anchor" href="#_3-1-管理配置的复杂性"><span>3.1 管理配置的复杂性</span></a></h2><p>通常，会将 <strong>配置信息</strong> 与 <strong>代码</strong> 分开。因此每次对配置进行更改时，应用程序必须重新编译、重新部署。对于配置的管理，需要遵循以下四个原则：</p><ul><li>分离 - 服务配置与服务部署完全分开</li><li>抽象 - 将访问配置数据的功能抽象到一个服务接口中，而不是直接为应用编写访问服务存储库的代码</li><li>集中 - 云上可能会有大量的服务实例，因此最小化保存配置信息的存储库数量很重要</li><li>稳定 - 由于配置信息与部署服务完全隔离，保证配置信息的高可用、冗余很重要</li></ul><p>回忆微服务的生命周期：装配、引导、发现和监控，微服务的配置管理和加载发生在引导阶段。在微服务实例启动引导时，它将调用一个 <strong>服务端点</strong> 来读取其所在环境的配置信息。而配置管理的连接信息 (即服务端点的信息) 将会在微服务启动时被传递给微服务。</p><h2 id="_3-2-构建-spring-cloud-配置服务器" tabindex="-1"><a class="header-anchor" href="#_3-2-构建-spring-cloud-配置服务器"><span>3.2 构建 Spring Cloud 配置服务器</span></a></h2><p>Spring Cloud 配置服务器也可以被视为是一个微服务实例。这个配置服务的客户端是其它的微服务实例，而配置服务的后端则是配置的具体存储介质，可以是文件系统、版本控制库或数据库。</p><p>根据配置服务扮演的角色，很显然，在启动一个配置服务时，需要将一些信息作为参数启动服务。这些配置信息位于 <code>xxx/src/main/resources</code> 目录下的 <code>application.yml</code> 中。其中包含的信息包括：</p><ol><li>Spring Cloud 配置服务器将要监听的端口号</li><li>配置存储的后端的类型 (文件系统 / 数据库 / Git 版本控制库)</li><li>配置存储的路径 (文件路径 / 数据库连接信息 / Git 版本控制库的连接信息)</li></ol><p>在每个应用的配置存储路径下，还可以提供适用 <strong>不同环境</strong> 的配置文件：默认环境、开发环境等。应用程序配置文件的命名约定为：<code>应用程序名称-环境名称.yml</code>。</p><img src="'+r+`" alt="spring-cloud-server" style="zoom:50%;"><p>配置服务需要作为一个服务实例被启动。因此，每一个 Spring Cloud 服务也需要一个启动引导类。在引导类上，需要加入 <code>@SpringBootApplication</code> (表明这也是一个 Spring Boot 应用程序) 以及 <code>@EnableConfigServer</code> (成为 Spring Cloud Config 服务) 注解。然后就可以启动配置服务器了。</p><p>在配置服务启动后，如果其它服务实例想要检索 <code>a</code> 应用的开发环境配置，那么直接向配置服务运行的端口发送对 <code>/a/dev</code> 的 GET 请求即可。在访问开发环境的配置时，配置服务器将会返回默认配置属性和开发环境的配置属性。这是因为 Spring 框架实现了一种层次解析机制 - 始终首先查找默认属性，然后用特定环境 (如开发环境) 的配置值覆盖默认配置值。</p><h2 id="_3-3-将-spring-cloud-config-与-spring-boot-客户端集成" tabindex="-1"><a class="header-anchor" href="#_3-3-将-spring-cloud-config-与-spring-boot-客户端集成"><span>3.3 将 Spring Cloud Config 与 Spring Boot 客户端集成</span></a></h2><p>当其它服务实例启动时，需要通过命令向服务实例传递三个信息：</p><ol><li>服务的应用程序名称</li><li>应用程序的运行环境 profile</li><li>连接到 Spring Cloud Config 服务器的连接信息</li></ol><p>比如，对一个名为 <code>a</code> 的应用来说，想要以开发环境启动，上述信息已经足够实例在启动时访问配置服务器 <code>&lt;cloud_config_url&gt;/a/dev</code> 获取 <code>a</code> 的开发环境配置。这些信息被配置在服务实例源码目录 <code>src/main/resources/</code> 的 <code>bootstrap.yml</code> 或 <code>application.yml</code> 中。</p><p>在启动服务实例时，如果不加任何参数，那么实例将直接使用 <code>bootstrap.yml</code> 或 <code>application.yml</code> 中定义的配置启动。也可以将服务编译为一个 JAR，然后在 JAR 启动时加入 <code>-D</code> 系统属性 <strong>覆盖</strong> 之前定义的配置。</p><p>Spring Boot Actuator 可以增强服务的自我检查能力。如果访问服务的 <code>/env</code> end point，可以获得服务实例的配置信息完整列表，包括服务启动的环境和 end point。</p><p>通过使用 <code>@Value</code> 注解，服务可以直接从 Spring Cloud 配置服务器中提取配置属性并注入应用程序的类中。</p><p>当 Spring Cloud 后端管理的配置发生变化时，如何动态刷新正在运行的所有服务实例？由于 Spring Boot 服务实例只会在启动时读取配置，因此 Spring Cloud 管理的配置发生更改时并不会被 Spring Boot 实例自动获取。Spring Boot Actuator 提供了一个 <code>@RefreshScope</code> 注解，暴露了 Spring Boot 实例的 <code>/refresh</code> end point。访问实例的 <code>/refresh</code> end point 将会强制 Spring Boot 实例重新读取应用程序的配置。</p><blockquote><p>刷新微服务的手段</p><p>Spring Cloud 服务提供了一种 <em>Spring Cloud Bus</em> 的推送机制，使 Spring Cloud 配置服务器能够向所有使用配置服务的实例发布有更改发生的消息。但是并不是所有的 Spring Cloud 后端都支持这个功能。</p><p>或许，可以写一个简单的脚本查询服务发现引擎，查找所有的服务实例，然后直接调用所有实例的 <code>/refresh</code> end point 即可。</p><p>还有一种方法是直接重启服务器或容器，来接收新属性。重启 docker 容器的时间非常短。</p></blockquote><h2 id="_3-4-保护敏感的访问信息" tabindex="-1"><a class="header-anchor" href="#_3-4-保护敏感的访问信息"><span>3.4 保护敏感的访问信息</span></a></h2><p>默认情况下，Spring Cloud 配置服务的后端存储以 <strong>明文</strong> 形式存放所有的配置属性，包括数据库凭据等敏感信息。出于安全考虑，将敏感信息以密文的形式存储在配置文件中更安全。这就需要使用加密与解密。对称加密与非对称加密都是支持的，只需要提前将密钥设置在 Spring Cloud 配置服务或其它所有服务实例所运行的服务器上的环境变量中即可。</p><p>在 Spring Cloud 配置服务实例启动后，将会检测环境变量 <code>ENCRYPT_KEY</code> 并暴露 <code>/encrypt</code> 和 <code>/decrypt</code> end point。用户可以通过向这两个 end point 发送 POST 请求，附带明文或密文，实现加密或解密。</p><p>Spring Cloud 规定，在后端的配置文件中，被加密的属性值前需要加上 <code>{cipher}</code>：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line">spring<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>password<span class="token operator">:</span><span class="token string">&quot;{cipher}84583464835248fe&quot;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>由此，Spring Cloud 配置服务器在读取到配置后，会识别出这是一个被加密的配置属性。默认情况下，配置服务器将自行解密已被加密的配置。那么当其它服务实例访问配置服务器时，被解密的敏感信息又会被以明文的形式传递。因此，这里的要点是，不要让配置服务器自行解密配置属性，而是直接将密文配置发送给客户端，由客户端的服务实例自行解密。这样，敏感数据将不会以明文形式传递。满足这个功能需要以下三个条件：</p><ol><li>配置 Spring Cloud 配置服务器不要解密属性</li><li>在客户端服务实例所在服务器上设置解密密钥</li><li>客户端服务实例需要有密码库的支持</li></ol><p>为满足第一个条件，需要在配置服务器的 <code>application.yml</code> 中设置 <code>spring.cloud.config.server.encrypt.enabled</code> 为 <code>false</code>。客户端服务实例需要在 Maven 中引入 <code>spring-security-rsa</code> 依赖，以支持在客户端解密配置属性。</p>`,34)]))}const t=e(l,[["render",d],["__file","Chapter 3 - 使用 Spring Cloud 配置服务器控制配置.html.vue"]]),a=JSON.parse('{"path":"/spring-microservices-notes/Chapter%203%20-%20%E4%BD%BF%E7%94%A8%20Spring%20Cloud%20%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A7%E5%88%B6%E9%85%8D%E7%BD%AE.html","title":"Chapter 3 - 使用 Spring Cloud 配置服务器控制配置","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"3.1 管理配置的复杂性","slug":"_3-1-管理配置的复杂性","link":"#_3-1-管理配置的复杂性","children":[]},{"level":2,"title":"3.2 构建 Spring Cloud 配置服务器","slug":"_3-2-构建-spring-cloud-配置服务器","link":"#_3-2-构建-spring-cloud-配置服务器","children":[]},{"level":2,"title":"3.3 将 Spring Cloud Config 与 Spring Boot 客户端集成","slug":"_3-3-将-spring-cloud-config-与-spring-boot-客户端集成","link":"#_3-3-将-spring-cloud-config-与-spring-boot-客户端集成","children":[]},{"level":2,"title":"3.4 保护敏感的访问信息","slug":"_3-4-保护敏感的访问信息","link":"#_3-4-保护敏感的访问信息","children":[]}],"git":{},"filePathRelative":"spring-microservices-notes/Chapter 3 - 使用 Spring Cloud 配置服务器控制配置.md"}');export{t as comp,a as data};
