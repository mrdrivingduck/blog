import{_ as a,c as n,a as e,o as t}from"./app-7eKjwDat.js";const p={};function l(o,s){return t(),n("div",null,s[0]||(s[0]=[e(`<h1 id="c-stl-algorithm" tabindex="-1"><a class="header-anchor" href="#c-stl-algorithm"><span>C++ STL algorithm</span></a></h1><p>Created by : Mr Dk.</p><p>2021 / 01 / 20 16:58</p><p>Ningbo, Zhejiang, China</p><hr><p>STL 的 <code>&lt;algorithm&gt;</code> 中定义了专门用于对一个范围内的元素进行操作的各种算法。实现上肯定十分高效，熟悉这些算法肯定能够极大提升刷题效率。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="non-modifying-sequence-operations" tabindex="-1"><a class="header-anchor" href="#non-modifying-sequence-operations"><span>Non-Modifying Sequence Operations</span></a></h2><h2 id="modifying-sequence-operations" tabindex="-1"><a class="header-anchor" href="#modifying-sequence-operations"><span>Modifying Sequence Operations</span></a></h2><h3 id="std-unique" tabindex="-1"><a class="header-anchor" href="#std-unique"><span>std::unique</span></a></h3><p>在一个范围内去除重复元素，只保留相同元素中第一个出现的元素。<code>==</code> 运算符用于进行比较，但是可以自行实现比较函数。</p><p>在具体的实现中，算法是将与当前迭代器不同的元素复制到前面来，实现去重。所以数组必须先进行排序后，再调用 <code>unique()</code>，才能真正实现去重的效果。</p><p>返回去重区间的结尾位置。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  ForwardIterator <span class="token function">unique</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">BinaryPredicate</span><span class="token operator">&gt;</span></span>
<span class="line">  ForwardIterator <span class="token function">unique</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span></span>
<span class="line">                          BinaryPredicate pred<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-unique-copy" tabindex="-1"><a class="header-anchor" href="#std-unique-copy"><span>std::unique_copy</span></a></h3><p>与上述功能相同，只需另外提供一个保存输出结果的迭代器即可。去重操作将不会影响原有数组。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">OutputIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  OutputIterator <span class="token function">unique_copy</span> <span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">,</span></span>
<span class="line">                              OutputIterator result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">OutputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">BinaryPredicate</span><span class="token operator">&gt;</span></span>
<span class="line">  OutputIterator <span class="token function">unique_copy</span> <span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">,</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-reverse" tabindex="-1"><a class="header-anchor" href="#std-reverse"><span>std::reverse</span></a></h3><p>逆置。具体实现方式是从头部和尾部开始交换元素。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BidirectionalIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">reverse</span> <span class="token punctuation">(</span>BidirectionalIterator first<span class="token punctuation">,</span> BidirectionalIterator last<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-reverse-copy" tabindex="-1"><a class="header-anchor" href="#std-reverse-copy"><span>std::reverse_copy</span></a></h3><p>逆置，将结果复制到一个迭代器指向的空间中。从结尾开始复制元素到结果空间的开头。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BidirectionalIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">OutputIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  OutputIterator <span class="token function">reverse_copy</span> <span class="token punctuation">(</span>BidirectionalIterator first<span class="token punctuation">,</span></span>
<span class="line">                               BidirectionalIterator last<span class="token punctuation">,</span> OutputIterator result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-copy-std-copy-backward" tabindex="-1"><a class="header-anchor" href="#std-copy-std-copy-backward"><span>std::copy / std::copy_backward</span></a></h3><p>复制一段范围的元素到另一个空间中 (从头开始拷贝或从尾开始拷贝)。</p><ul><li>一对输入迭代器指示范围</li><li>一个输出迭代器指向目标空间开始的位置</li></ul><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">OutputIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  OutputIterator <span class="token function">copy</span> <span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">,</span> OutputIterator result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BidirectionalIterator1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">BidirectionalIterator2</span><span class="token operator">&gt;</span></span>
<span class="line">  BidirectionalIterator2 <span class="token function">copy_backward</span> <span class="token punctuation">(</span>BidirectionalIterator1 first<span class="token punctuation">,</span></span>
<span class="line">                                        BidirectionalIterator1 last<span class="token punctuation">,</span></span>
<span class="line">                                        BidirectionalIterator2 result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-copy-n" tabindex="-1"><a class="header-anchor" href="#std-copy-n"><span>std::copy_n</span></a></h3><p>复制某个位置开始的 n 个元素到目标空间中。</p><ul><li>一个输入迭代器指示起始位置</li><li>整数 <code>n</code> 指示元素个数</li><li>一个输出迭代器指示目标位置</li></ul><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Size</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">OutputIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  OutputIterator <span class="token function">copy_n</span> <span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> Size n<span class="token punctuation">,</span> OutputIterator result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-copy-if" tabindex="-1"><a class="header-anchor" href="#std-copy-if"><span>std::copy_if</span></a></h3><p>复制一段范围中满足条件的元素到另一个空间中。</p><ul><li>一对输入迭代器指示范围</li><li>一个输出迭代器指示目标空间起始位置</li><li>一元表达式判断每个元素是否符合条件</li></ul><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">OutputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">UnaryPredicate</span><span class="token operator">&gt;</span></span>
<span class="line">  OutputIterator <span class="token function">copy_if</span> <span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">,</span></span>
<span class="line">                          OutputIterator result<span class="token punctuation">,</span> UnaryPredicate pred<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-move-std-move-backward" tabindex="-1"><a class="header-anchor" href="#std-move-std-move-backward"><span>std::move / std::move_backward</span></a></h3><p>将指定范围内的元素移动到目标空间中 (从头移动或从尾移动)。移动后，原范围内的元素将处于 <strong>未确定但合法</strong> 的状态。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">OutputIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  OutputIterator <span class="token function">move</span> <span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">,</span> OutputIterator result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BidirectionalIterator1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">BidirectionalIterator2</span><span class="token operator">&gt;</span></span>
<span class="line">  BidirectionalIterator2 <span class="token function">move_backward</span> <span class="token punctuation">(</span>BidirectionalIterator1 first<span class="token punctuation">,</span></span>
<span class="line">                                        BidirectionalIterator1 last<span class="token punctuation">,</span></span>
<span class="line">                                        BidirectionalIterator2 result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-swap-std-swap-ranges-std-iter-swap" tabindex="-1"><a class="header-anchor" href="#std-swap-std-swap-ranges-std-iter-swap"><span>std::swap / std::swap_ranges / std::iter_swap</span></a></h3><p>交换两个对象的值。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token function">swap</span> <span class="token punctuation">(</span>T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>交换两个对象中指定长度范围内的元素。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">ForwardIterator2</span><span class="token operator">&gt;</span></span>
<span class="line">  ForwardIterator2 <span class="token function">swap_ranges</span> <span class="token punctuation">(</span>ForwardIterator1 first1<span class="token punctuation">,</span> ForwardIterator1 last1<span class="token punctuation">,</span></span>
<span class="line">                                ForwardIterator2 first2<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>交换两个迭代器指向的值。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">ForwardIterator2</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">iter_swap</span> <span class="token punctuation">(</span>ForwardIterator1 a<span class="token punctuation">,</span> ForwardIterator2 b<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-transform" tabindex="-1"><a class="header-anchor" href="#std-transform"><span>std::transform</span></a></h3><p>对一段范围内的元素应用指定的一元或二元操作后，将结果保存到一个指定的空间中。</p><p>一元操作：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">OutputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">UnaryOperation</span><span class="token operator">&gt;</span></span>
<span class="line">  OutputIterator <span class="token function">transform</span> <span class="token punctuation">(</span>InputIterator first1<span class="token punctuation">,</span> InputIterator last1<span class="token punctuation">,</span></span>
<span class="line">                            OutputIterator result<span class="token punctuation">,</span> UnaryOperation op<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>二元操作：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">InputIterator2</span><span class="token punctuation">,</span></span>
<span class="line">          <span class="token keyword">class</span> <span class="token class-name">OutputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">BinaryOperation</span><span class="token operator">&gt;</span></span>
<span class="line">  OutputIterator <span class="token function">transform</span> <span class="token punctuation">(</span>InputIterator1 first1<span class="token punctuation">,</span> InputIterator1 last1<span class="token punctuation">,</span></span>
<span class="line">                            InputIterator2 first2<span class="token punctuation">,</span> OutputIterator result<span class="token punctuation">,</span></span>
<span class="line">                            BinaryOperation binary_op<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-replace-std-replace-copy-std-replace-if-std-replace-copy-if" tabindex="-1"><a class="header-anchor" href="#std-replace-std-replace-copy-std-replace-if-std-replace-copy-if"><span>std::replace / std::replace_copy / std::replace_if / std::replace_copy_if</span></a></h3><p>对一段范围内的元素将与指定值相等的值替换为新值，使用 <code>==</code> 操作符进行比较。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">replace</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span></span>
<span class="line">                <span class="token keyword">const</span> T<span class="token operator">&amp;</span> old_value<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> new_value<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将一段范围内的元素替换后的结果复制到一个独立的空间中：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">OutputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line">  OutputIterator <span class="token function">replace_copy</span> <span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">,</span></span>
<span class="line">                               OutputIterator result<span class="token punctuation">,</span></span>
<span class="line">                               <span class="token keyword">const</span> T<span class="token operator">&amp;</span> old_value<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> new_value<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对一段范围内满足指定条件的元素替换为新值，使用自定义的一元函数进行判断。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">UnaryPredicate</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">replace_if</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span></span>
<span class="line">                   UnaryPredicate pred<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> new_value <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将一段范围内的元素替换后的结果复制到一个独立的空间中：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">OutputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">UnaryPredicate</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line">  OutputIterator <span class="token function">replace_copy_if</span> <span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">,</span></span>
<span class="line">                                  OutputIterator result<span class="token punctuation">,</span> UnaryPredicate pred<span class="token punctuation">,</span></span>
<span class="line">                                  <span class="token keyword">const</span> T<span class="token operator">&amp;</span> new_value<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="sorting" tabindex="-1"><a class="header-anchor" href="#sorting"><span>Sorting</span></a></h2><h3 id="std-sort" tabindex="-1"><a class="header-anchor" href="#std-sort"><span>std::sort</span></a></h3><p>不稳定排序。必须指定的是排序的起始范围 (迭代器)，作用范围为 <code>[first, last)</code>。可选的参数是排序要使用到的比较函数，如不指定比较函数，那么使用 <code>&lt;</code> 运算符进行比较。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">sort</span> <span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator last<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">sort</span> <span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator last<span class="token punctuation">,</span> Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度为 O(nlog(n))。实现逻辑如下：</p><ul><li>默认使用快速排序 (相比于堆排序，数据是连续访问的，对 cache 友好)，将数据分段归并</li><li>如果分段内数据小于阈值 (16)，则改用插入排序，避免快速排序的递归开销</li><li>如果递归层次过深，则使用堆排序 (复杂度相同，但无需更多递归)</li></ul><h3 id="std-stable-sort" tabindex="-1"><a class="header-anchor" href="#std-stable-sort"><span>std::stable_sort</span></a></h3><p>稳定排序。必须指定的是排序的起始范围 (迭代器)，作用范围为 <code>[first, last)</code>。可选的参数是排序要使用到的比较函数，如不指定比较函数，那么使用 <code>&lt;</code> 运算符进行比较。</p><p>稳定排序会维持序列中相等元素的相对顺序。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">stable_sort</span> <span class="token punctuation">(</span> RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator last <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">stable_sort</span> <span class="token punctuation">(</span> RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator last<span class="token punctuation">,</span></span>
<span class="line">                     Compare comp <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-partial-sort" tabindex="-1"><a class="header-anchor" href="#std-partial-sort"><span>std::partial_sort</span></a></h3><p>输入三个参数，作用范围在 <code>[first, last)</code> 之间。执行算法后，<code>[first, middle)</code> 区间将包含整个区间中升序排列的前 <code>middle - first</code> 个元素，<code>[middle, last)</code> 区间将不包含顺序。</p><p>默认使用 <code>&lt;</code> 运算符进行比较，可选自实现的比较函数覆盖默认行为。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">partial_sort</span> <span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator middle<span class="token punctuation">,</span></span>
<span class="line">                     RandomAccessIterator last<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">partial_sort</span> <span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator middle<span class="token punctuation">,</span></span>
<span class="line">                     RandomAccessIterator last<span class="token punctuation">,</span> Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-partial-sort-copy" tabindex="-1"><a class="header-anchor" href="#std-partial-sort-copy"><span>std::partial_sort_copy</span></a></h3><p>原理同上，只是将结果复制到另一块空间 <code>[result_first, result_last)</code> 中，原空间保持不变。<code>middle</code> 参数变为返回结果集中的首尾范围，显然内部是通过结果集的首尾范围隐式指定了 <code>middle</code> 的位置。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  RandomAccessIterator</span>
<span class="line">    <span class="token function">partial_sort_copy</span> <span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span>InputIterator last<span class="token punctuation">,</span></span>
<span class="line">                       RandomAccessIterator result_first<span class="token punctuation">,</span></span>
<span class="line">                       RandomAccessIterator result_last<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  RandomAccessIterator</span>
<span class="line">    <span class="token function">partial_sort_copy</span> <span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span>InputIterator last<span class="token punctuation">,</span></span>
<span class="line">                       RandomAccessIterator result_first<span class="token punctuation">,</span></span>
<span class="line">                       RandomAccessIterator result_last<span class="token punctuation">,</span> Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-is-sorted" tabindex="-1"><a class="header-anchor" href="#std-is-sorted"><span>std::is_sorted</span></a></h3><p>返回指定范围内的元素是否是排序的：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">bool</span> <span class="token function">is_sorted</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">bool</span> <span class="token function">is_sorted</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span> Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-is-sorted-until" tabindex="-1"><a class="header-anchor" href="#std-is-sorted-until"><span>std::is_sorted_until</span></a></h3><p>返回序列中第一个不符合排序要求的元素的迭代器：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  ForwardIterator <span class="token function">is_sorted_until</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  ForwardIterator <span class="token function">is_sorted_until</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span></span>
<span class="line">                                   Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-nth-element" tabindex="-1"><a class="header-anchor" href="#std-nth-element"><span>std::nth_element</span></a></h3><p>对指定范围内的数据进行重排序，并指定一个位置，这个位置之前的元素全都小于这个位置之后的元素 (等价于序列中最小的 n 个元素)。默认使用 <code>&lt;</code> 运算符，可选使用自定义的比较函数。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">nth_element</span> <span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator nth<span class="token punctuation">,</span></span>
<span class="line">                    RandomAccessIterator last<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">nth_element</span> <span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator nth<span class="token punctuation">,</span></span>
<span class="line">                    RandomAccessIterator last<span class="token punctuation">,</span> Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="partitions" tabindex="-1"><a class="header-anchor" href="#partitions"><span>Partitions</span></a></h2><h3 id="std-partition" tabindex="-1"><a class="header-anchor" href="#std-partition"><span>std::partition</span></a></h3><p>对指定范围内的元素进行重排序，满足特定条件为 <code>true</code> 的所有元素全部排列在特定条件为 <code>false</code> 的元素之前，返回指向后一组 (指定条件为 <code>false</code>) 元素第一个元素的迭代器。</p><p>不稳定分治：序列中元素的相对顺序不一定维持不变。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BidirectionalIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">UnaryPredicate</span><span class="token operator">&gt;</span></span>
<span class="line">  BidirectionalIterator <span class="token function">partition</span> <span class="token punctuation">(</span>BidirectionalIterator first<span class="token punctuation">,</span></span>
<span class="line">                                   BidirectionalIterator last<span class="token punctuation">,</span></span>
<span class="line">                                   UnaryPredicate pred<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 <code>UnaryPredicate</code> 是一个一元参数返回值为 <code>bool</code> 类型的函数。内部等价实现：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BidirectionalIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">UnaryPredicate</span><span class="token operator">&gt;</span></span>
<span class="line">  BidirectionalIterator <span class="token function">partition</span> <span class="token punctuation">(</span>BidirectionalIterator first<span class="token punctuation">,</span></span>
<span class="line">                                   BidirectionalIterator last<span class="token punctuation">,</span> UnaryPredicate pred<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">while</span> <span class="token punctuation">(</span>first<span class="token operator">!=</span>last<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">pred</span><span class="token punctuation">(</span><span class="token operator">*</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token operator">++</span>first<span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token operator">==</span>last<span class="token punctuation">)</span> <span class="token keyword">return</span> first<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">do</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token operator">--</span>last<span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token operator">==</span>last<span class="token punctuation">)</span> <span class="token keyword">return</span> first<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pred</span><span class="token punctuation">(</span><span class="token operator">*</span>last<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token function">swap</span> <span class="token punctuation">(</span><span class="token operator">*</span>first<span class="token punctuation">,</span><span class="token operator">*</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token operator">++</span>first<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">return</span> first<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>这里也可以看出为什么是不稳定的：原本排在前面的元素被 swap 到后面去了。</p></blockquote><h3 id="std-stable-partition" tabindex="-1"><a class="header-anchor" href="#std-stable-partition"><span>std::stable_partition</span></a></h3><p>同上，但是分治是稳定的：<code>pred</code> 返回结果相同的元素之间的相对顺序不变。内部实现上使用了一个 <strong>临时缓冲区</strong> (来从头存放 <code>false</code> group 中的元素)。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BidirectionalIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">UnaryPredicate</span><span class="token operator">&gt;</span></span>
<span class="line">  BidirectionalIterator <span class="token function">stable_partition</span> <span class="token punctuation">(</span>BidirectionalIterator first<span class="token punctuation">,</span></span>
<span class="line">                                          BidirectionalIterator last<span class="token punctuation">,</span></span>
<span class="line">                                          UnaryPredicate pred<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-partition-copy" tabindex="-1"><a class="header-anchor" href="#std-partition-copy"><span>std::partition_copy</span></a></h3><p>不修改原有序列，将满足条件为 <code>true</code> 的元素放入 <code>result_true</code> 迭代器开始的空间中，将满足条件 <code>false</code> 的元素放入 <code>result_false</code> 迭代器开始的空间中。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">OutputIterator1</span><span class="token punctuation">,</span></span>
<span class="line">          <span class="token keyword">class</span> <span class="token class-name">OutputIterator2</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">UnaryPredicate</span> pred<span class="token operator">&gt;</span></span>
<span class="line">  pair<span class="token operator">&lt;</span>OutputIterator1<span class="token punctuation">,</span>OutputIterator2<span class="token operator">&gt;</span></span>
<span class="line">    <span class="token function">partition_copy</span> <span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">,</span></span>
<span class="line">                    OutputIterator1 result_true<span class="token punctuation">,</span> OutputIterator2 result_false<span class="token punctuation">,</span></span>
<span class="line">                    UnaryPredicate pred<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-partition-point" tabindex="-1"><a class="header-anchor" href="#std-partition-point"><span>std::partition_point</span></a></h3><p>在一个 <strong>已经被划分好的序列中</strong>，寻找划分点，也就是第一个使 <code>pred()</code> 返回 <code>false</code> 的迭代器位置。基于已经被划分好的假设，可以通过二分查找的方式进行优化。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">UnaryPredicate</span><span class="token operator">&gt;</span></span>
<span class="line">  ForwardIterator <span class="token function">partition_point</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span></span>
<span class="line">                                   UnaryPredicate pred<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="binary-search" tabindex="-1"><a class="header-anchor" href="#binary-search"><span>Binary Search</span></a></h2><h3 id="std-lower-bound" tabindex="-1"><a class="header-anchor" href="#std-lower-bound"><span>std::lower_bound</span></a></h3><p>返回序列中第一个 <strong>大于等于</strong> 指定值的元素，前提是序列已经有序。默认使用 <code>&lt;</code> 运算符，可选使用自定义的比较函数。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line">  ForwardIterator <span class="token function">lower_bound</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span></span>
<span class="line">                               <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  ForwardIterator <span class="token function">lower_bound</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span></span>
<span class="line">                               <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val<span class="token punctuation">,</span> Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-upper-bound" tabindex="-1"><a class="header-anchor" href="#std-upper-bound"><span>std::upper_bound</span></a></h3><p>返回序列中第一个 <strong>大于</strong> 指定值的元素，前提是序列已经有序。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line">  ForwardIterator <span class="token function">upper_bound</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span></span>
<span class="line">                               <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  ForwardIterator <span class="token function">upper_bound</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span></span>
<span class="line">                               <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val<span class="token punctuation">,</span> Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-equal-range" tabindex="-1"><a class="header-anchor" href="#std-equal-range"><span>std::equal_range</span></a></h3><p>寻找序列中等于某个值的数据范围，前提是序列已经有序。如果序列中不存在该值，则返回两个范围为 0 的迭代器，迭代器指向距离指定值最接近的值。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line">  pair<span class="token operator">&lt;</span>ForwardIterator<span class="token punctuation">,</span>ForwardIterator<span class="token operator">&gt;</span></span>
<span class="line">    <span class="token function">equal_range</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  pair<span class="token operator">&lt;</span>ForwardIterator<span class="token punctuation">,</span>ForwardIterator<span class="token operator">&gt;</span></span>
<span class="line">    <span class="token function">equal_range</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val<span class="token punctuation">,</span></span>
<span class="line">                  Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-binary-search" tabindex="-1"><a class="header-anchor" href="#std-binary-search"><span>std::binary_search</span></a></h3><p>寻找序列中是否存在指定的值，前提是序列已经有序。二分查找。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">bool</span> <span class="token function">binary_search</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span></span>
<span class="line">                      <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">bool</span> <span class="token function">binary_search</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span></span>
<span class="line">                      <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val<span class="token punctuation">,</span> Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="heap" tabindex="-1"><a class="header-anchor" href="#heap"><span>Heap</span></a></h2><h3 id="std-make-heap" tabindex="-1"><a class="header-anchor" href="#std-make-heap"><span>std::make_heap</span></a></h3><p>参数给定一个范围，对该范围内的数据建立堆序。默认使用 <code>&lt;</code> 运算符构造大顶堆，可选自定义的比较函数。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">make_heap</span> <span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator last<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">make_heap</span> <span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator last<span class="token punctuation">,</span></span>
<span class="line">                  Compare comp <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-push-heap" tabindex="-1"><a class="header-anchor" href="#std-push-heap"><span>std::push_heap</span></a></h3><p>给定一个已经满足堆序的范围 <code>[first, last - 1)</code>，将最后一个元素 <code>last - 1</code> 加入到这个堆中，使 <code>[first, last)</code> 满足堆序。可选自定义的比较函数维护堆序。</p><blockquote><p>通常在容器的 <code>push_back()</code> 函数之后使用。</p></blockquote><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">push_heap</span> <span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator last<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">push_heap</span> <span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator last<span class="token punctuation">,</span></span>
<span class="line">                   Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-pop-heap" tabindex="-1"><a class="header-anchor" href="#std-pop-heap"><span>std::pop_heap</span></a></h3><p>给定一个满足堆序的范围 <code>[first, last)</code>，将堆顶元素弹出到 <code>last - 1</code> 位置上，并重新维护剩余元素的堆序。导致的效果是 <code>[first, last - 1)</code> 是一个堆，最后一个元素是原堆顶元素。</p><blockquote><p>通常在容器的 <code>pop_back()</code> 函数之前使用。</p></blockquote><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">pop_heap</span> <span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator last<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">pop_heap</span> <span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator last<span class="token punctuation">,</span></span>
<span class="line">                 Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-sort-heap" tabindex="-1"><a class="header-anchor" href="#std-sort-heap"><span>std::sort_heap</span></a></h3><p>对一个堆序范围进行堆排序。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">sort_heap</span> <span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator last<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">sort_heap</span> <span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator last<span class="token punctuation">,</span></span>
<span class="line">                  Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-is-heap" tabindex="-1"><a class="header-anchor" href="#std-is-heap"><span>std::is_heap</span></a></h3><p>返回给定的序列范围是否满足堆序。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">bool</span> <span class="token function">is_heap</span> <span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator last<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">bool</span> <span class="token function">is_heap</span> <span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator last<span class="token punctuation">,</span></span>
<span class="line">                Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-is-heap-until" tabindex="-1"><a class="header-anchor" href="#std-is-heap-until"><span>std::is_heap_until</span></a></h3><p>返回给定序列中第一个不满足堆序的位置。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  RandomAccessIterator <span class="token function">is_heap_until</span> <span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span></span>
<span class="line">                                      RandomAccessIterator last<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  RandomAccessIterator <span class="token function">is_heap_until</span> <span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span></span>
<span class="line">                                      RandomAccessIterator last</span>
<span class="line">                                      Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="merge" tabindex="-1"><a class="header-anchor" href="#merge"><span>Merge</span></a></h2><h2 id="min-max" tabindex="-1"><a class="header-anchor" href="#min-max"><span>Min / Max</span></a></h2><h3 id="std-min" tabindex="-1"><a class="header-anchor" href="#std-min"><span>std::min</span></a></h3><p>返回两个元素中较小的那个。如果两者相同，则返回前一个。默认使用 <code>&lt;</code> 运算符。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">min</span> <span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">min</span> <span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">,</span> Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-max" tabindex="-1"><a class="header-anchor" href="#std-max"><span>std::max</span></a></h3><p>返回两个元素中较大的那个，如果两者相同，则返回前一个。默认使用 <code>&lt;</code> 运算符。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">max</span> <span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">max</span> <span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">,</span> Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-minmax" tabindex="-1"><a class="header-anchor" href="#std-minmax"><span>std::minmax</span></a></h3><p>以 <code>&lt;min, max&gt;</code> 的形式返回最大值和最小值。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line">  pair <span class="token operator">&lt;</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token operator">&gt;</span> <span class="token function">minmax</span> <span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  pair <span class="token operator">&lt;</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token operator">&gt;</span> <span class="token function">minmax</span> <span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">,</span> Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">initializer <span class="token function">list</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line">  pair<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>T<span class="token operator">&gt;</span> <span class="token function">minmax</span> <span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> il<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  pair<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>T<span class="token operator">&gt;</span> <span class="token function">minmax</span> <span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> il<span class="token punctuation">,</span> Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-min-element" tabindex="-1"><a class="header-anchor" href="#std-min-element"><span>std::min_element</span></a></h3><p>返回指定范围内的最小值。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  ForwardIterator <span class="token function">min_element</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  ForwardIterator <span class="token function">min_element</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span></span>
<span class="line">                               Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-max-element" tabindex="-1"><a class="header-anchor" href="#std-max-element"><span>std::max_element</span></a></h3><p>返回指定范围内的最大值。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  ForwardIterator <span class="token function">max_element</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  ForwardIterator <span class="token function">max_element</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span></span>
<span class="line">                               Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="std-minmax-element" tabindex="-1"><a class="header-anchor" href="#std-minmax-element"><span>std::minmax_element</span></a></h3><p>返回指定范围内的最小值和最大值。如果包含多个相同值：</p><ul><li>返回第一个最小值</li><li>返回最后一个最大值</li></ul><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token operator">&gt;</span></span>
<span class="line">  pair<span class="token operator">&lt;</span>ForwardIterator<span class="token punctuation">,</span>ForwardIterator<span class="token operator">&gt;</span></span>
<span class="line">    <span class="token function">minmax_element</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token operator">&gt;</span></span>
<span class="line">  pair<span class="token operator">&lt;</span>ForwardIterator<span class="token punctuation">,</span>ForwardIterator<span class="token operator">&gt;</span></span>
<span class="line">    <span class="token function">minmax_element</span> <span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span> Compare comp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="other" tabindex="-1"><a class="header-anchor" href="#other"><span>Other</span></a></h2><hr><h2 id="references" tabindex="-1"><a class="header-anchor" href="#references"><span>References</span></a></h2><p><a href="http://www.cplusplus.com/reference/algorithm/" target="_blank" rel="noopener noreferrer">CPlusPlus.com</a></p>`,164)]))}const r=a(p,[["render",l],["__file","C__ STL algorithm.html.vue"]]),i=JSON.parse('{"path":"/notes/C__/C__%20STL%20algorithm.html","title":"C++ STL algorithm","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Non-Modifying Sequence Operations","slug":"non-modifying-sequence-operations","link":"#non-modifying-sequence-operations","children":[]},{"level":2,"title":"Modifying Sequence Operations","slug":"modifying-sequence-operations","link":"#modifying-sequence-operations","children":[{"level":3,"title":"std::unique","slug":"std-unique","link":"#std-unique","children":[]},{"level":3,"title":"std::unique_copy","slug":"std-unique-copy","link":"#std-unique-copy","children":[]},{"level":3,"title":"std::reverse","slug":"std-reverse","link":"#std-reverse","children":[]},{"level":3,"title":"std::reverse_copy","slug":"std-reverse-copy","link":"#std-reverse-copy","children":[]},{"level":3,"title":"std::copy / std::copy_backward","slug":"std-copy-std-copy-backward","link":"#std-copy-std-copy-backward","children":[]},{"level":3,"title":"std::copy_n","slug":"std-copy-n","link":"#std-copy-n","children":[]},{"level":3,"title":"std::copy_if","slug":"std-copy-if","link":"#std-copy-if","children":[]},{"level":3,"title":"std::move / std::move_backward","slug":"std-move-std-move-backward","link":"#std-move-std-move-backward","children":[]},{"level":3,"title":"std::swap / std::swap_ranges / std::iter_swap","slug":"std-swap-std-swap-ranges-std-iter-swap","link":"#std-swap-std-swap-ranges-std-iter-swap","children":[]},{"level":3,"title":"std::transform","slug":"std-transform","link":"#std-transform","children":[]},{"level":3,"title":"std::replace / std::replace_copy / std::replace_if / std::replace_copy_if","slug":"std-replace-std-replace-copy-std-replace-if-std-replace-copy-if","link":"#std-replace-std-replace-copy-std-replace-if-std-replace-copy-if","children":[]}]},{"level":2,"title":"Sorting","slug":"sorting","link":"#sorting","children":[{"level":3,"title":"std::sort","slug":"std-sort","link":"#std-sort","children":[]},{"level":3,"title":"std::stable_sort","slug":"std-stable-sort","link":"#std-stable-sort","children":[]},{"level":3,"title":"std::partial_sort","slug":"std-partial-sort","link":"#std-partial-sort","children":[]},{"level":3,"title":"std::partial_sort_copy","slug":"std-partial-sort-copy","link":"#std-partial-sort-copy","children":[]},{"level":3,"title":"std::is_sorted","slug":"std-is-sorted","link":"#std-is-sorted","children":[]},{"level":3,"title":"std::is_sorted_until","slug":"std-is-sorted-until","link":"#std-is-sorted-until","children":[]},{"level":3,"title":"std::nth_element","slug":"std-nth-element","link":"#std-nth-element","children":[]}]},{"level":2,"title":"Partitions","slug":"partitions","link":"#partitions","children":[{"level":3,"title":"std::partition","slug":"std-partition","link":"#std-partition","children":[]},{"level":3,"title":"std::stable_partition","slug":"std-stable-partition","link":"#std-stable-partition","children":[]},{"level":3,"title":"std::partition_copy","slug":"std-partition-copy","link":"#std-partition-copy","children":[]},{"level":3,"title":"std::partition_point","slug":"std-partition-point","link":"#std-partition-point","children":[]}]},{"level":2,"title":"Binary Search","slug":"binary-search","link":"#binary-search","children":[{"level":3,"title":"std::lower_bound","slug":"std-lower-bound","link":"#std-lower-bound","children":[]},{"level":3,"title":"std::upper_bound","slug":"std-upper-bound","link":"#std-upper-bound","children":[]},{"level":3,"title":"std::equal_range","slug":"std-equal-range","link":"#std-equal-range","children":[]},{"level":3,"title":"std::binary_search","slug":"std-binary-search","link":"#std-binary-search","children":[]}]},{"level":2,"title":"Heap","slug":"heap","link":"#heap","children":[{"level":3,"title":"std::make_heap","slug":"std-make-heap","link":"#std-make-heap","children":[]},{"level":3,"title":"std::push_heap","slug":"std-push-heap","link":"#std-push-heap","children":[]},{"level":3,"title":"std::pop_heap","slug":"std-pop-heap","link":"#std-pop-heap","children":[]},{"level":3,"title":"std::sort_heap","slug":"std-sort-heap","link":"#std-sort-heap","children":[]},{"level":3,"title":"std::is_heap","slug":"std-is-heap","link":"#std-is-heap","children":[]},{"level":3,"title":"std::is_heap_until","slug":"std-is-heap-until","link":"#std-is-heap-until","children":[]}]},{"level":2,"title":"Merge","slug":"merge","link":"#merge","children":[]},{"level":2,"title":"Min / Max","slug":"min-max","link":"#min-max","children":[{"level":3,"title":"std::min","slug":"std-min","link":"#std-min","children":[]},{"level":3,"title":"std::max","slug":"std-max","link":"#std-max","children":[]},{"level":3,"title":"std::minmax","slug":"std-minmax","link":"#std-minmax","children":[]},{"level":3,"title":"std::min_element","slug":"std-min-element","link":"#std-min-element","children":[]},{"level":3,"title":"std::max_element","slug":"std-max-element","link":"#std-max-element","children":[]},{"level":3,"title":"std::minmax_element","slug":"std-minmax-element","link":"#std-minmax-element","children":[]}]},{"level":2,"title":"Other","slug":"other","link":"#other","children":[]},{"level":2,"title":"References","slug":"references","link":"#references","children":[]}],"git":{},"filePathRelative":"notes/C++/C++ STL algorithm.md"}');export{r as comp,i as data};
