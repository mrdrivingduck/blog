import{_ as e,c as i,a,o as n}from"./app-BeHGwf2X.js";const t={};function r(s,l){return n(),i("div",null,l[0]||(l[0]=[a('<h1 id="chapter-9-内核同步介绍" tabindex="-1"><a class="header-anchor" href="#chapter-9-内核同步介绍"><span>Chapter 9 - 内核同步介绍</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 10 / 23 14:18</p><p>Nanjing, Jiangsu, China</p><hr><p>需要特别留意保护共享资源，防止共享资源并发访问。</p><h2 id="_9-1-临界区和竞争条件" tabindex="-1"><a class="header-anchor" href="#_9-1-临界区和竞争条件"><span>9.1 临界区和竞争条件</span></a></h2><p>临界区：访问和操作共享数据的代码段。多个线程并发访问同一个资源通常不安全，必须保证进入临界区中的代码 <strong>原子地</strong> 执行：操作在执行结束前不可被打断，要么执行完，要么完全不执行，如同整个临界区是一条不可分割的指令。</p><p>如果两个线程同时进入临界区，那么就发生了 <strong>竞争条件 (race condition)</strong>。避免并发和防止竞争条件称为 <strong>同步 (synchronization)</strong>。</p><h3 id="_9-1-1-为什么我们需要保护" tabindex="-1"><a class="header-anchor" href="#_9-1-1-为什么我们需要保护"><span>9.1.1 为什么我们需要保护</span></a></h3><p>银行 ATM 机的例子</p><ul><li>必须保证在操作期间对账户加锁</li><li>确保每个事物相对于其它事物的操作时原子性的</li><li>事物必须完整地发生，要么干脆不发生，但是绝不能打断</li></ul><h3 id="_9-1-2-单个变量" tabindex="-1"><a class="header-anchor" href="#_9-1-2-单个变量"><span>9.1.2 单个变量</span></a></h3><p><code>i++;</code> 的例子。多数 CPU 都提供了指令来原子地读变量、增加变量、并写回变量，使用这样的指令能够解决一定的问题，因为两个原子操作交错执行根本不可能发生。CPU 从物理上确保了这种不可能。</p><h2 id="_9-2-加锁" tabindex="-1"><a class="header-anchor" href="#_9-2-加锁"><span>9.2 加锁</span></a></h2><p>对数据结构的操作显然不能通过原子指令来实现。当共享资源是一个复杂的数据结构时，竞争条件往往会使该数据结构遭到破坏。硬件不可能对不定长度的临界区提供原子指令，需要 <strong>锁</strong> 机制来确保一次有且只有一个线程对数据结构进行操作：线程持有锁，锁保护了数据。</p><p>锁的使用是 <strong>自愿、非强制</strong> 的，不强制使用，但为了防止发生竞争条件，必须使用。锁有多种形式，且加锁的粒度和范围也各不相同。锁由 <strong>原子操作</strong> 实现：</p><ul><li>原子操作不存在竞争</li><li>单一指令可以验证锁的关键部分是否被抓住</li><li>几乎所有 CPU 都提供了 <strong>测试</strong> 和 <strong>设置</strong> 指令，对锁进行原子地验证</li></ul><h3 id="_9-2-1-造成并发执行的原因" tabindex="-1"><a class="header-anchor" href="#_9-2-1-造成并发执行的原因"><span>9.2.1 造成并发执行的原因</span></a></h3><p>用户空间需要同步：</p><ul><li>因为用户程序会被调度程序抢占和重新调度</li><li>程序在临界区中时，可能会被非自愿抢占</li></ul><p>这类并发实际上并不是同时发生的。如果有多核 CPU，则存在着真正意义上的并发（并行？）。内核可能造成并发执行的原因：</p><ul><li>中断 - 任何时刻异步发生</li><li>软中断、tasklet</li><li>内核抢占</li><li>睡眠、与用户空间同步</li><li>对称多处理</li></ul><p>应当在最开始设计代码时就考虑加锁，而不是事后。如果代码已经写好，在其中找到需要加锁的地方并加锁，是很困难的，而且结果也不好。</p><h3 id="_9-2-2-了解要保护些什么" tabindex="-1"><a class="header-anchor" href="#_9-2-2-了解要保护些什么"><span>9.2.2 了解要保护些什么</span></a></h3><p>执行线程的局部数据仅仅被它本身访问，显然不需要保护。要给数据而不是给代码加锁。编写内核代码时，要问问自己这些问题：</p><ul><li>数据是否是全局的？</li><li>数据会不会在进程上下文和中断上下文中共享</li><li>访问数据时可不可能被抢占</li><li>当前进程是不是会睡眠在某些资源上</li><li>函数如果在另一个 CPU 上被调度将会发生什么</li></ul><h2 id="_9-3-死锁" tabindex="-1"><a class="header-anchor" href="#_9-3-死锁"><span>9.3 死锁</span></a></h2><p>每个线程都在等待一个资源，所有的资源都已经被占用，所有线程都在互相等待，但永远不会释放已经占用的资源。</p><ul><li>自死锁：一个执行线程试图获得一个自己已经持有的锁</li><li>ABBA 死锁：线程 A 和 B 分别获得了 A 和 B 锁，都想要另一个锁</li></ul><p>没有线程会释放一开始就持有的锁。一些避免死锁的策略：</p><ul><li>按顺序加锁：保证以相同的顺序获取锁，如果两个或多个锁在同一时间里被请求，其它函数也应当按照前次的加锁顺序进行</li><li>防止发生饥饿</li><li>不要重复请求同一个锁</li><li>设计力求简单</li></ul><p>只要嵌套使用多个锁，就要按照相同的顺序去获取它们。</p><h2 id="_9-4-争用和扩展性" tabindex="-1"><a class="header-anchor" href="#_9-4-争用和扩展性"><span>9.4 争用和扩展性</span></a></h2><p>锁的争用，指锁被占用时，有其它线程试图获得该锁——多个线程等待获得该锁：高度争用状态。锁使程序以串行的方式对资源进行访问，使用锁会降低系统的性能，被高度争用的锁会成为系统的性能瓶颈，严重降低系统性能。</p><p>扩展性是对系统可扩展程度的一个量度，任何可以被计量的计算机组件都可以涉及可扩展性。在 Linux 2.6 内核中，内核加的锁是非常细的粒度。加锁粒度用于描述加锁保护的数据规模：</p><ul><li>一个过粗的锁保护大块数据</li><li>一个精细的锁保护很小的一块数据</li></ul><p>细粒度锁在大型系统上的性能可能会很好，但在小型系统上会增加复杂度，并加大开销</p><ul><li><strong>锁争用太严重时，加锁太粗会降低可扩展性</strong></li><li><strong>锁争用不明显时，加锁太细会加大系统开销，带来浪费</strong></li></ul><p>两种情况都会造成系统性能下降。</p>',40)]))}const h=e(t,[["render",r],["__file","Chapter 9 - 内核同步介绍.html.vue"]]),o=JSON.parse('{"path":"/linux-kernel-development-notes/Chapter%209%20-%20%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E4%BB%8B%E7%BB%8D.html","title":"Chapter 9 - 内核同步介绍","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"9.1 临界区和竞争条件","slug":"_9-1-临界区和竞争条件","link":"#_9-1-临界区和竞争条件","children":[{"level":3,"title":"9.1.1 为什么我们需要保护","slug":"_9-1-1-为什么我们需要保护","link":"#_9-1-1-为什么我们需要保护","children":[]},{"level":3,"title":"9.1.2 单个变量","slug":"_9-1-2-单个变量","link":"#_9-1-2-单个变量","children":[]}]},{"level":2,"title":"9.2 加锁","slug":"_9-2-加锁","link":"#_9-2-加锁","children":[{"level":3,"title":"9.2.1 造成并发执行的原因","slug":"_9-2-1-造成并发执行的原因","link":"#_9-2-1-造成并发执行的原因","children":[]},{"level":3,"title":"9.2.2 了解要保护些什么","slug":"_9-2-2-了解要保护些什么","link":"#_9-2-2-了解要保护些什么","children":[]}]},{"level":2,"title":"9.3 死锁","slug":"_9-3-死锁","link":"#_9-3-死锁","children":[]},{"level":2,"title":"9.4 争用和扩展性","slug":"_9-4-争用和扩展性","link":"#_9-4-争用和扩展性","children":[]}],"git":{},"filePathRelative":"linux-kernel-development-notes/Chapter 9 - 内核同步介绍.md"}');export{h as comp,o as data};
