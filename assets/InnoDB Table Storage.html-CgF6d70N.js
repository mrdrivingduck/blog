import{_ as a,c as n,a as l,o as r}from"./app-BeHGwf2X.js";const t={};function i(o,e){return r(),n("div",null,e[0]||(e[0]=[l('<h1 id="innodb-table-storage" tabindex="-1"><a class="header-anchor" href="#innodb-table-storage"><span>InnoDB - Table Storage</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 10 / 14 10:55</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="table-organization" tabindex="-1"><a class="header-anchor" href="#table-organization"><span>Table Organization</span></a></h2><p>InnoDB 中表以 <strong>主键顺序</strong> 组织存放，这种存储方式的表成为 <em>索引组织表 (Index Organized Table)</em>。如果在创建表时没有定义主键：</p><ul><li>如果表中有非空的唯一索引 (Unique NOT NULL) 的列，如果有，则使用第一个定义这种索引的列</li><li>如果没有，那么 InnoDB 存储引擎自动创建一个 6B 大小的指针</li></ul><h2 id="logical-structure" tabindex="-1"><a class="header-anchor" href="#logical-structure"><span>Logical Structure</span></a></h2><h3 id="table-space" tabindex="-1"><a class="header-anchor" href="#table-space"><span>Table Space</span></a></h3><p>InnoDB 存储引擎中，所有数据都被存放在称为 <em>表空间 (Table Space)</em> 的逻辑存储结构中。默认情况下，所有表的数据都存放在一个名为 <code>ibdata1</code> 的共享表空间中。在开启 <code>innodb_file_per_table</code> 后，每张表的数据、索引、插入缓冲 bitmap 会被存放到独立的表空间中；undo 信息、插入缓冲索引、事务信息、二次写缓冲还会被存放在共享表空间中。</p><h3 id="segment" tabindex="-1"><a class="header-anchor" href="#segment"><span>Segment</span></a></h3><p>表空间由各个段组成，段的类型各有不同 - 数据段、索引段、回滚段等。InnoDB 存储引擎的表是由 B+ 树索引组织的，因此数据段就是 B+ 树的叶子结点，索引段就是 B+ 树的非叶子结点。对段的管理由引擎自身完成。</p><h3 id="extent" tabindex="-1"><a class="header-anchor" href="#extent"><span>Extent</span></a></h3><p><strong>区</strong> 由连续的页组成，一般来说一个区由 64 个连续的页组成。</p><h3 id="page" tabindex="-1"><a class="header-anchor" href="#page"><span>Page</span></a></h3><p>页 (块) 时 InnoDB 存储引擎对磁盘进行管理的最小单位，根据用途，分为很多不同类型的页。</p><h3 id="row" tabindex="-1"><a class="header-anchor" href="#row"><span>Row</span></a></h3><p>InnoDB 存储引擎是 <em>面向列 (Row-Oriented)</em> 的，数据按 <strong>行</strong> 为单位进行存放，每页最多允许存放 16KB / 2-200 行记录。面向列的数据库有利于分析类 SQL 的执行以及数据压缩。在 InnoDB 1.0.x 版本之前，提供 Compact 和 Redundant 两种格式存放行记录。</p><h2 id="row-record-format" tabindex="-1"><a class="header-anchor" href="#row-record-format"><span>Row Record Format</span></a></h2><h3 id="compact-行记录格式" tabindex="-1"><a class="header-anchor" href="#compact-行记录格式"><span>Compact 行记录格式</span></a></h3><p>Compact 格式在 MySQL 5.0 中引入，包含：</p><ul><li>变长字段长度列表 - <strong>逆序</strong> 存放所有 <em>变长列</em> 的长度 (列 n 长度，列 n-1 长度，...) <ul><li>若列长度 &lt; 255B，则用 1B 表示长度</li><li>若列长度 &gt; 255B，则用 2B 表示长度 (可见列长度最大限制为 65535)</li></ul></li><li>NULL 标志位 - 指示该行数据中是否有 NULL 值</li><li>记录头 (Record Header) - 包含记录的信息，以及下一个记录的偏移量；页内部通过链表串联行记录</li><li>行中每列的数据 (NULL 不占任何空间)</li></ul><p>每行除了用户定义的列，还会有两个隐藏列：</p><ul><li>事务 ID 列</li><li>回滚指针列</li></ul><p>如果 InnoDB 表没有定义主键，每行还会增加一个 6B 的 rowid 列。</p><h3 id="redundant-行记录格式" tabindex="-1"><a class="header-anchor" href="#redundant-行记录格式"><span>Redundant 行记录格式</span></a></h3><p>MySQL 5.0 前 InnoDB 存储引擎的存储方式：</p><ul><li>字段长度偏移列表 (当前偏移减去前一个偏移才能得到长度)，同样以逆序存放</li><li>记录头 (Record Header) - 包含一行中列的数量</li><li>行中每列数据</li></ul><p>对于 VARCHAR 类型的 NULL 值不占空间，而 CHAR 类型的 NULL 值需要占用空间。</p><h3 id="行溢出数据" tabindex="-1"><a class="header-anchor" href="#行溢出数据"><span>行溢出数据</span></a></h3><p>InnoDB 存储引擎可以将一些数据存储在真正的数据页面之外。一般情况下，InnoDB 存储引擎的数据都是存放在类型为 <em>B-tree node</em> 的页中；但发生行溢出时，数据会被存放到类型为 <em>Uncompress BLOB</em> 的页中。由于 InnoDB 存储引擎的表由 B+ 树索引组织，那么每个页中应当至少有两条行记录 - 如果每页中只能放得下一条行记录，那么 InnoDB 存储索引会自动将 (768B 后的) 行数据存放到溢出页中，保证一个数据页内至少有两条行记录。如果一个页中能够存放至少两行数据，那么行数据就不会存放到 BLOB 页中。</p><h3 id="compressed-和-dynamic-行记录格式" tabindex="-1"><a class="header-anchor" href="#compressed-和-dynamic-行记录格式"><span>Compressed 和 Dynamic 行记录格式</span></a></h3><p>这两种新的格式对于存放 BLOB 数据采用 <strong>完全行溢出</strong> 的方式 - 数据页中只存放 20B 的指针，实际的数据存放在 <em>Off Page</em> 中。另外，存储的行数据会以 zlib 的算法进行压缩存储。</p><h2 id="data-page-format" tabindex="-1"><a class="header-anchor" href="#data-page-format"><span>Data Page Format</span></a></h2><p>页是 InnoDB 存储引擎管理数据库的最小磁盘单位。其中，页类型为 B-tree node 的页存放的就是实际的行数据，即数据页。数据页包含以下七个部分：</p><ul><li>File Header - 记录页的所属表空间，所在表空间中的位置，校验和等</li><li>Page Header - 记录当前页的状态信息</li><li>Infimum + Supremum Records - 虚拟行记录，限定记录的边界 (最小值 + 最大值)，不会被删除</li><li>User Records - 实际存储的行记录</li><li>Free Space - 空闲空间 (链表)</li><li>Page Directory - 存放当前页中记录的相对位置，是一个稀疏的 (哈希表?)，按主键值顺序存放</li><li>File Trailer - 用于检测页是否被完整地写入磁盘</li></ul><p>B+ 树索引只能找到一条记录所在的页，数据库将该页载入内存后，再通过 Page Directory 进行二分查找 (因为是顺序存放) 得到一个粗略的结果 (一个 hash slot 中对应多条记录)，还要通过每条记录 Record Header 中的 <code>next_record</code> 继续查找，直到得到具体的某条记录。由于二分查找的复杂度低，并且在内存中完成，因此这部分开销通常被忽略。</p><p>在默认配置下，InnoDB 存储引擎每次从磁盘中读取一个页就会检测页的完整性，会带来一定开销，通过 <code>innodb_checksums</code> 可以开启或关闭完整性检查。</p><hr>',40)]))}const d=a(t,[["render",i],["__file","InnoDB Table Storage.html.vue"]]),c=JSON.parse('{"path":"/notes/MySQL/InnoDB%20Table%20Storage.html","title":"InnoDB - Table Storage","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Table Organization","slug":"table-organization","link":"#table-organization","children":[]},{"level":2,"title":"Logical Structure","slug":"logical-structure","link":"#logical-structure","children":[{"level":3,"title":"Table Space","slug":"table-space","link":"#table-space","children":[]},{"level":3,"title":"Segment","slug":"segment","link":"#segment","children":[]},{"level":3,"title":"Extent","slug":"extent","link":"#extent","children":[]},{"level":3,"title":"Page","slug":"page","link":"#page","children":[]},{"level":3,"title":"Row","slug":"row","link":"#row","children":[]}]},{"level":2,"title":"Row Record Format","slug":"row-record-format","link":"#row-record-format","children":[{"level":3,"title":"Compact 行记录格式","slug":"compact-行记录格式","link":"#compact-行记录格式","children":[]},{"level":3,"title":"Redundant 行记录格式","slug":"redundant-行记录格式","link":"#redundant-行记录格式","children":[]},{"level":3,"title":"行溢出数据","slug":"行溢出数据","link":"#行溢出数据","children":[]},{"level":3,"title":"Compressed 和 Dynamic 行记录格式","slug":"compressed-和-dynamic-行记录格式","link":"#compressed-和-dynamic-行记录格式","children":[]}]},{"level":2,"title":"Data Page Format","slug":"data-page-format","link":"#data-page-format","children":[]}],"git":{},"filePathRelative":"notes/MySQL/InnoDB Table Storage.md"}');export{d as comp,c as data};
