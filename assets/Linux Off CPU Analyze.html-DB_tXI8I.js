import{_ as e,c as a,a as s,o as l}from"./app-BeHGwf2X.js";const i={};function r(p,n){return l(),a("div",null,n[0]||(n[0]=[s(`<h1 id="linux-performance-off-cpu-analyze" tabindex="-1"><a class="header-anchor" href="#linux-performance-off-cpu-analyze"><span>Linux Performance - Off CPU Analyze</span></a></h1><p>Created by: Mr Dk.</p><p>2023 / 09 / 24 00:08</p><p>Hangzhou, Zhejiang, China</p><hr><h2 id="background" tabindex="-1"><a class="header-anchor" href="#background"><span>Background</span></a></h2><p>性能问题可以被分为两类：</p><ul><li>On CPU：进程运行在 CPU 上所耗费的时间</li><li>Off CPU：进程被阻塞而离开 CPU 的时间，比如 I/O、锁、定时器等</li></ul><p>常规的 CPU 采样只能够收集 On CPU 的统计信息，但无法统计 Off CPU 的统计信息。</p><h2 id="differences" tabindex="-1"><a class="header-anchor" href="#differences"><span>Differences</span></a></h2><h3 id="cpu-sampling" tabindex="-1"><a class="header-anchor" href="#cpu-sampling"><span>CPU Sampling</span></a></h3><p>On CPU 的采样如下图所示。Perf 相关工具的采样原理是，以固定的频率采集当时 CPU 上的进程堆栈信息。当进程因各种因素离开 CPU 时，就不再会被采样了：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">    CPU Sampling -----------------------------------------------&gt;</span>
<span class="line">     |  |  |  |  |  |  |                      |  |  |  |  |</span>
<span class="line">     A  A  A  A  B  B  B                      B  A  A  A  A</span>
<span class="line">    A(---------.                                .----------)</span>
<span class="line">               |                                |</span>
<span class="line">               B(--------.                   .--)</span>
<span class="line">                         |                   |         user-land</span>
<span class="line">   - - - - - - - - - - syscall - - - - - - - - - - - - - - - - -</span>
<span class="line">                         |                   |         kernel</span>
<span class="line">                         X     Off-CPU       |</span>
<span class="line">                       block . . . . . interrupt</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="application-tracing" tabindex="-1"><a class="header-anchor" href="#application-tracing"><span>Application Tracing</span></a></h3><p>应用程序内部可以自己实现 Off CPU 统计，但问题在于，追踪所有函数的开销极大，而追踪部分函数又可能丢失真正想追踪的目标：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">    App Tracing ------------------------------------------------&gt;</span>
<span class="line">    |          |                                |          |</span>
<span class="line">    A(         B(                               B)         A)</span>
<span class="line"></span>
<span class="line">    A(---------.                                .----------)</span>
<span class="line">               |                                |</span>
<span class="line">               B(--------.                   .--)</span>
<span class="line">                         |                   |         user-land</span>
<span class="line">   - - - - - - - - - - syscall - - - - - - - - - - - - - - - - -</span>
<span class="line">                         |                   |         kernel</span>
<span class="line">                         X     Off-CPU       |</span>
<span class="line">                       block . . . . . interrupt</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="off-cpu-tracing" tabindex="-1"><a class="header-anchor" href="#off-cpu-tracing"><span>Off-CPU Tracing</span></a></h3><p>只追踪 OS 内核将线程从 CPU 上换出的函数，并记录当时的时间戳和用户态堆栈。相对来说，开销小了很多：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">    Off-CPU Tracing --------------------------------------------&gt;</span>
<span class="line">                         |                   |</span>
<span class="line">                         B                   B</span>
<span class="line">                         A                   A</span>
<span class="line">    A(---------.                                .----------)</span>
<span class="line">               |                                |</span>
<span class="line">               B(--------.                   .--)</span>
<span class="line">                         |                   |         user-land</span>
<span class="line">   - - - - - - - - - - syscall - - - - - - - - - - - - - - - - -</span>
<span class="line">                         |                   |         kernel</span>
<span class="line">                         X     Off-CPU       |</span>
<span class="line">                       block . . . . . interrupt</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="overhead" tabindex="-1"><a class="header-anchor" href="#overhead"><span>Overhead</span></a></h2><p>开销是性能追踪中最重要的因素。相对来说，Perf 需要将追踪得到的数据返回用户态并写入文件中，所以产生的数据量和追踪的时间成正比，并且可能受到磁盘 I/O 的限制；而使用 eBPF 则会在内核态捕获并追踪 <strong>唯一</strong> 的堆栈，这意味着追踪数据量并不会随着时间而线性增长。</p><p>比如，通过 <a href="https://ebpf.io/" target="_blank" rel="noopener noreferrer">eBPF</a>/<a href="https://github.com/iovisor/bcc" target="_blank" rel="noopener noreferrer">BCC</a> 工具 <code>offcputime</code>，可以直接得到 Flame Graph 工具能够接受的输入格式，生成 Off CPU 火焰图。当然用 Perf 也可以，就是开销大一点啦。</p><h2 id="off-cpu-sampling" tabindex="-1"><a class="header-anchor" href="#off-cpu-sampling"><span>Off CPU Sampling</span></a></h2><p>使用 BCC 工具 <code>offcputime</code> 采样：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">/usr/share/bcc/tools/offcputime <span class="token parameter variable">-df</span> <span class="token parameter variable">-p</span> PID <span class="token number">30</span> <span class="token operator">&gt;</span> out.stacks</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>采样完毕后，使用火焰图工具生成火焰图：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">git</span> clone https://github.com/brendangregg/FlameGraph</span>
<span class="line"><span class="token builtin class-name">cd</span> FlameGraph</span>
<span class="line">./flamegraph.pl <span class="token parameter variable">--color</span><span class="token operator">=</span>io <span class="token parameter variable">--title</span><span class="token operator">=</span><span class="token string">&quot;Off-CPU Time Flame Graph&quot;</span> <span class="token parameter variable">--countname</span><span class="token operator">=</span>us <span class="token operator">&lt;</span> out.stacks <span class="token operator">&gt;</span> out.svg</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="references" tabindex="-1"><a class="header-anchor" href="#references"><span>References</span></a></h2><p><a href="https://www.brendangregg.com/offcpuanalysis.html" target="_blank" rel="noopener noreferrer">Off-CPU Analysis</a></p><p><a href="https://www.brendangregg.com/FlameGraphs/offcpuflamegraphs.html" target="_blank" rel="noopener noreferrer">Off-CPU Flame Graphs</a></p><p><a href="https://www.brendangregg.com/blog/2015-02-26/linux-perf-off-cpu-flame-graph.html" target="_blank" rel="noopener noreferrer">Linux perf_events Off-CPU Time Flame Graph</a></p>`,31)]))}const t=e(i,[["render",r],["__file","Linux Off CPU Analyze.html.vue"]]),d=JSON.parse('{"path":"/notes/Performance/Linux%20Off%20CPU%20Analyze.html","title":"Linux Performance - Off CPU Analyze","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Background","slug":"background","link":"#background","children":[]},{"level":2,"title":"Differences","slug":"differences","link":"#differences","children":[{"level":3,"title":"CPU Sampling","slug":"cpu-sampling","link":"#cpu-sampling","children":[]},{"level":3,"title":"Application Tracing","slug":"application-tracing","link":"#application-tracing","children":[]},{"level":3,"title":"Off-CPU Tracing","slug":"off-cpu-tracing","link":"#off-cpu-tracing","children":[]}]},{"level":2,"title":"Overhead","slug":"overhead","link":"#overhead","children":[]},{"level":2,"title":"Off CPU Sampling","slug":"off-cpu-sampling","link":"#off-cpu-sampling","children":[]},{"level":2,"title":"References","slug":"references","link":"#references","children":[]}],"git":{},"filePathRelative":"notes/Performance/Linux Off CPU Analyze.md"}');export{t as comp,d as data};
