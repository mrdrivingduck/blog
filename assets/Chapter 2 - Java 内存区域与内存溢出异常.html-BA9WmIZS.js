import{_ as e,c as l,a as t,o as i}from"./app-BeHGwf2X.js";const n={};function r(s,a){return i(),l("div",null,a[0]||(a[0]=[t('<h1 id="chapter-2-java-内存区域与内存溢出异常" tabindex="-1"><a class="header-anchor" href="#chapter-2-java-内存区域与内存溢出异常"><span>Chapter 2 - Java 内存区域与内存溢出异常</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 01 / 24 20:26 🧨🧧</p><p>Ningbo, Zhejiang, China</p><hr><h2 id="_2-1-概述" tabindex="-1"><a class="header-anchor" href="#_2-1-概述"><span>2.1 概述</span></a></h2><p>在 JVM 的自动内存管理机制的帮助下，不再需要为每一个 <code>new</code> 操作分配对应的 <code>delete/free</code> 代码。</p><h2 id="_2-2-运行时数据区域" tabindex="-1"><a class="header-anchor" href="#_2-2-运行时数据区域"><span>2.2 运行时数据区域</span></a></h2><p>JVM 管理的内存被划分为不同区域。</p><h3 id="_2-2-1-程序计数器-program-counter-register" tabindex="-1"><a class="header-anchor" href="#_2-2-1-程序计数器-program-counter-register"><span>2.2.1 程序计数器 (Program Counter Register)</span></a></h3><p>当前线程所执行的字节码的行号指示器。各条线程之间的计数器互不影响，独立存储，是线程私有的内存。</p><h3 id="_2-2-2-java-虚拟机栈-java-virtual-machine-stack" tabindex="-1"><a class="header-anchor" href="#_2-2-2-java-虚拟机栈-java-virtual-machine-stack"><span>2.2.2 Java 虚拟机栈 (Java Virtual Machine Stack)</span></a></h3><p>由线程私有，生命周期与线程相同，描述的是 Java 函数执行的线程内存模型。</p><ul><li>当一个 Java 函数被调用时，JVM 会创建栈帧存储局部变量表等信息</li><li>调用完毕，栈帧出栈</li></ul><p>局部变量表中存放编译期可知的数据：</p><ul><li>JVM 基本数据类型</li><li>对象引用 (指向对象起始地址的引用指针)</li><li>returnAddress 类型</li></ul><p>这些数据在局部变量表中以 <strong>局部变量槽 (slot)</strong> 来表示，局部变量槽在编译期间完成分配 (栈帧中需要的局部变量大小是可以提前确定的)。</p><h3 id="_2-2-3-本地方法栈-native-method-stacks" tabindex="-1"><a class="header-anchor" href="#_2-2-3-本地方法栈-native-method-stacks"><span>2.2.3 本地方法栈 (Native Method Stacks)</span></a></h3><p>与虚拟机栈发挥的作用类似。</p><ul><li>虚拟机栈为执行 Java 函数 (字节码) 服务</li><li>本地方法栈为虚拟机用到的本地函数服务 (意思是非 Java 函数)</li></ul><h3 id="_2-2-4-java-堆-java-heap" tabindex="-1"><a class="header-anchor" href="#_2-2-4-java-堆-java-heap"><span>2.2.4 Java 堆 (Java Heap)</span></a></h3><p>Java Heap 是 JVM 所管理的内存中最大的一块，是 <strong>所有线程共享</strong> 的一块内存区域，作用是存放所有的对象实例。Java Heap 是垃圾收集器管理的内存区域，因此也被称为 <em>GC Heap</em>。所有线程共享的 Java Heap 上可以划分出各线程私有的 <em>分配缓冲区 (Thread Local Allocation Buffer, TLAB)</em>：</p><ul><li>提升对象分配时的效率</li><li>将 Java Heap 细分的目的只是为了更好地回收内存，或更快地分配内存</li></ul><p>Java Heap 在物理上可以是不连续的，但在逻辑上是连续的。Java Heap 可以被实现为是固定的，也可以是可扩展的。</p><h3 id="_2-2-5-方法区-method-area" tabindex="-1"><a class="header-anchor" href="#_2-2-5-方法区-method-area"><span>2.2.5 方法区 (Method Area)</span></a></h3><p>也是各个线程共享的内存区域，存储 JVM 加载的类型信息、常量、静态变量、JIT 编译器编译后的代码缓存。在实现上，不需要连续内存，大小可扩展，甚至还可以不实现垃圾收集。</p><h3 id="_2-2-6-运行时常量池-runtime-constant-pool" tabindex="-1"><a class="header-anchor" href="#_2-2-6-运行时常量池-runtime-constant-pool"><span>2.2.6 运行时常量池 (Runtime Constant Pool)</span></a></h3><p>是 <strong>方法区</strong> 的一部分。JVM 严格规定了 Class 文件每一部分的格式，其中。常量池表 (Constant Pool Table) 用于存放编译期生成的常量与符号引用。</p><h3 id="_2-2-7-直接内存" tabindex="-1"><a class="header-anchor" href="#_2-2-7-直接内存"><span>2.2.7 直接内存</span></a></h3><p>绕过 JVM 分配的内存，不位于 Java Heap 中，不属于运行时数据区。</p><h2 id="_2-3-hotspot-虚拟机对象探秘" tabindex="-1"><a class="header-anchor" href="#_2-3-hotspot-虚拟机对象探秘"><span>2.3 HotSpot 虚拟机对象探秘</span></a></h2><h3 id="_2-3-1-对象的创建" tabindex="-1"><a class="header-anchor" href="#_2-3-1-对象的创建"><span>2.3.1 对象的创建</span></a></h3><p>JVM 遇到 <code>new</code> 指令时，首先去检查指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析、初始化。如果没有，则需要执行类加载。接下来，为新生对象分配内存：</p><ul><li>将一块固定大小的内存从堆上划分出来</li><li>类加载后，对象所需要的内存大小可以确定</li></ul><p>另外，考虑到分配内存时的线程安全问题，解决方案有：</p><ol><li>对分配内存空间进行同步：JVM 使用 CAS + 失败重试保证更新的原子性</li><li>为每个线程在 JVM 中划分私有区域 (TLAB)：只有本地缓冲用完，分配新的内存时才需要同步锁定</li></ol><p>内存分配完毕后，JVM 将分配的内存空间初始化为 0，保证了对象的字段在 Java 代码中不需要初始化就能直接使用。JVM 对对象进行设置，将信息存放在对象的 Object Header 中，从 JVM 的视角来看，新的对象已经分配完成。但从 Java 代码的视角看，还需要执行对象的构造函数，这样才构造出了一个真正可用的对象。</p><h3 id="_2-3-2-对象的内存布局" tabindex="-1"><a class="header-anchor" href="#_2-3-2-对象的内存布局"><span>2.3.2 对象的内存布局</span></a></h3><p>对象在堆内存中的存储布局可以划分为三部分：</p><ul><li>对象头 (Header)</li><li>实例数据 (Instant Data)</li><li>对齐补充 (Padding)</li></ul><p>对象头包含两部分信息：</p><ol><li>存储对象自身的运行时数据 (Mark Word, 32-bit 或 64-bit) <ul><li>HashCode</li><li>GC 年龄</li><li>锁状态</li><li>持有的锁等</li></ul></li><li>类型指针，指向对象类型 metadata 的指针 <ul><li>JVM 通过这个类来确定该对象是哪个类的实例</li><li>如果是数组，还额外需要记录数组的长度</li></ul></li></ol><p>实例数据部分存储了对象真正存储的有效信息，包括 Java 代码中定义的各种字段。HotSpot 虚拟机会有一个默认的字段分配顺序，使相同宽度的字段被存放到一起；满足这一条件的前提下，父类中定义的变量会出现在子类之前。由于 HotSpot 虚拟机的自动内存管理系统要求对象起始地址对齐 8B，由于对象头已被设计为固定长度，并对齐 8B，若实例数据不足 8B，将会被填充以对齐 8B。</p><h3 id="_2-3-3-对象的访问定位" tabindex="-1"><a class="header-anchor" href="#_2-3-3-对象的访问定位"><span>2.3.3 对象的访问定位</span></a></h3><p>Java 程序通过栈上的对象引用来操作堆上的具体对象。JVM 规范没有定义对象的具体访问方式，由 JVM 的实现决定：</p><ul><li>句柄访问 <ul><li>Java Heap 中划出一块内存作为句柄池</li><li>对象引用存储的是句柄地址</li><li>句柄中包含对象实例数据与类型数据各自的地址</li></ul></li><li>直接指针访问 <ul><li>对象引用直接存储对象的地址</li></ul></li></ul><p>句柄访问的优势：在对象被移动 (GC 时很普遍) 时只会改变句柄中的实例数据地址，对象引用不会被修改。</p><p>直接指针访问的优势：</p><ul><li>速度更快，节省了一次指针定位的开销</li><li>HotSpot 使用这种方式进行对象访问</li></ul>',49)]))}const p=e(n,[["render",r],["__file","Chapter 2 - Java 内存区域与内存溢出异常.html.vue"]]),o=JSON.parse('{"path":"/understanding-the-jvm-notes/Part%202%20-%20%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Chapter%202%20-%20Java%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8.html","title":"Chapter 2 - Java 内存区域与内存溢出异常","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"2.1 概述","slug":"_2-1-概述","link":"#_2-1-概述","children":[]},{"level":2,"title":"2.2 运行时数据区域","slug":"_2-2-运行时数据区域","link":"#_2-2-运行时数据区域","children":[{"level":3,"title":"2.2.1 程序计数器 (Program Counter Register)","slug":"_2-2-1-程序计数器-program-counter-register","link":"#_2-2-1-程序计数器-program-counter-register","children":[]},{"level":3,"title":"2.2.2 Java 虚拟机栈 (Java Virtual Machine Stack)","slug":"_2-2-2-java-虚拟机栈-java-virtual-machine-stack","link":"#_2-2-2-java-虚拟机栈-java-virtual-machine-stack","children":[]},{"level":3,"title":"2.2.3 本地方法栈 (Native Method Stacks)","slug":"_2-2-3-本地方法栈-native-method-stacks","link":"#_2-2-3-本地方法栈-native-method-stacks","children":[]},{"level":3,"title":"2.2.4 Java 堆 (Java Heap)","slug":"_2-2-4-java-堆-java-heap","link":"#_2-2-4-java-堆-java-heap","children":[]},{"level":3,"title":"2.2.5 方法区 (Method Area)","slug":"_2-2-5-方法区-method-area","link":"#_2-2-5-方法区-method-area","children":[]},{"level":3,"title":"2.2.6 运行时常量池 (Runtime Constant Pool)","slug":"_2-2-6-运行时常量池-runtime-constant-pool","link":"#_2-2-6-运行时常量池-runtime-constant-pool","children":[]},{"level":3,"title":"2.2.7 直接内存","slug":"_2-2-7-直接内存","link":"#_2-2-7-直接内存","children":[]}]},{"level":2,"title":"2.3 HotSpot 虚拟机对象探秘","slug":"_2-3-hotspot-虚拟机对象探秘","link":"#_2-3-hotspot-虚拟机对象探秘","children":[{"level":3,"title":"2.3.1 对象的创建","slug":"_2-3-1-对象的创建","link":"#_2-3-1-对象的创建","children":[]},{"level":3,"title":"2.3.2 对象的内存布局","slug":"_2-3-2-对象的内存布局","link":"#_2-3-2-对象的内存布局","children":[]},{"level":3,"title":"2.3.3 对象的访问定位","slug":"_2-3-3-对象的访问定位","link":"#_2-3-3-对象的访问定位","children":[]}]}],"git":{},"filePathRelative":"understanding-the-jvm-notes/Part 2 - 自动内存管理/Chapter 2 - Java 内存区域与内存溢出异常.md"}');export{p as comp,o as data};
