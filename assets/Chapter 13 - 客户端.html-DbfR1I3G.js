import{_ as s,c as a,a as e,o as l}from"./app-BeHGwf2X.js";const i={};function c(p,n){return l(),a("div",null,n[0]||(n[0]=[e(`<h1 id="chapter-13-客户端" tabindex="-1"><a class="header-anchor" href="#chapter-13-客户端"><span>Chapter 13 - 客户端</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 06 / 06 17:09</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="客户端状态" tabindex="-1"><a class="header-anchor" href="#客户端状态"><span>客户端状态</span></a></h2><p>Redis 通过 <strong>I/O 多路复用</strong> 来实现与多个客户端建立网络连接。Redis 服务器如何维护所有客户端的状态？</p><p>对于每个与服务器连接的客户端，服务器建立了 <code>redisClient</code> 结构维护该客户端的信息。这个信息以链表的形式维护在服务器状态结构体中：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line">    list <span class="token operator">*</span>clients<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而每个客户端的状态维护在 <code>redisClient</code> 结构体中：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">int</span> fd<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    robj <span class="token operator">*</span>name<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">int</span> flags<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    sds querybuf<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">int</span> argc<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    redisCommand <span class="token operator">*</span>cmd<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>REDIS_REPLY_CHUNK_BYTES<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">int</span> bufpos<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    list <span class="token operator">*</span>reply<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">int</span> authenticated<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">time_t</span> ctime<span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">time_t</span> lastinteraction<span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">time_t</span> obuf_soft_limit_reached_time<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span> redisClient<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="套接字描述符" tabindex="-1"><a class="header-anchor" href="#套接字描述符"><span>套接字描述符</span></a></h3><p><code>fd</code> 记录了客户端正在使用的 socket 描述符。当其为 <code>-1</code> 时，代表该客户端是一个伪客户端：</p><ul><li>载入 AOF 文件还原数据库状态</li><li>执行 Lua 脚本中包含的 Redis 命令</li></ul><h3 id="客户端名称" tabindex="-1"><a class="header-anchor" href="#客户端名称"><span>客户端名称</span></a></h3><p>默认情况下，客户端是没有名字的。可以通过命令设置名称，让客户端的身份变得更清晰。如果客户端没有名字，<code>name</code> 为 <code>NULL</code>；否则指向一个字符串对象。</p><h3 id="标志" tabindex="-1"><a class="header-anchor" href="#标志"><span>标志</span></a></h3><p><code>flag</code> 记录了客户端的角色、状态等。</p><h3 id="输入缓冲区" tabindex="-1"><a class="header-anchor" href="#输入缓冲区"><span>输入缓冲区</span></a></h3><p><code>querybuf</code> 用于保存客户端发送的命令请求。缓冲区的大小会随着客户端输入的内容动态减小或扩大，如果大小超过 1GB，则该客户端会被服务器关闭。</p><h3 id="命令请求与参数" tabindex="-1"><a class="header-anchor" href="#命令请求与参数"><span>命令请求与参数</span></a></h3><p><code>argv</code> 和 <code>argc</code> 保存服务器对输入缓冲区中的命令进行解析后，得到的拆分后的命令及其参数。</p><blockquote><p>与从 shell 运行 <code>main(argv, argc)</code> 类似。</p></blockquote><h3 id="命令的实现函数" tabindex="-1"><a class="header-anchor" href="#命令的实现函数"><span>命令的实现函数</span></a></h3><p>服务器根据 <code>argv[0]</code> 的值，使 <code>cmd</code> 指针指向对应的 <code>redisCommand</code> 结构体。这个结构体中保存了命令的实现函数、标志、命令的执行次数、总执行时长等。之后服务器可以通过 <code>redisCommand</code>、<code>argv</code>、<code>argc</code>，来调用命令对应的实现函数。</p><p>所有的 <code>redisCommand</code> 结构体被维护在一个字典中，称为 <strong>命令表</strong>。字典的 key 是 SDS 字符串，对应了命令的名字；字典的 value 对应 Redis 命令的 <code>redisCommand</code> 结构体。</p><h3 id="输出缓冲区" tabindex="-1"><a class="header-anchor" href="#输出缓冲区"><span>输出缓冲区</span></a></h3><p>用于保存执行命令后得到的结果。每个客户端有两个可用的输出缓冲区</p><ul><li><code>buf[REDIS_REPLY_CHUNK_BYTES]</code> 对应一个固定长度的缓冲区，由 <code>bufpos</code> 记录已使用的字节数；默认为 16KB <ul><li>用于保存长度较小的回复</li></ul></li><li><code>reply</code> 对应一个可变大小的缓冲区，由它来组织一个由多个字符串对象构成的链表 <ul><li>处理 <code>buf</code> 放不下的情况</li></ul></li></ul><h3 id="身份认证" tabindex="-1"><a class="header-anchor" href="#身份认证"><span>身份认证</span></a></h3><p><code>authenticated</code> 记录客户端是否通过了身份认证。</p><h3 id="时间" tabindex="-1"><a class="header-anchor" href="#时间"><span>时间</span></a></h3><ul><li><code>ctime</code> 记录了客户端的创建时间，可用于计算连接已经持续了多久</li><li><code>lastinteraction</code> 记录了客户端与服务器最后一次互动的时间，可用于计算客户端空闲了多久</li><li><code>obuf_soft_limit_reached_time</code> 记录了输出缓冲区第一次到达软性限制的时间</li></ul><hr><h2 id="客户端的创建与关闭" tabindex="-1"><a class="header-anchor" href="#客户端的创建与关闭"><span>客户端的创建与关闭</span></a></h2><p>在客户端使用 <code>connect</code> 连接到服务器后，该客户端的状态就会被添加到服务器状态 <code>client</code> 链表末尾。</p><p>客户端可能因为多种原因而被关闭：</p><ul><li>客户端进程结束</li><li>客户端发送了不符合协议格式的命令请求</li><li>客户端称为 <code>CLIENT KILL</code> 命令的目标</li><li>客户端空闲时间超过阈值</li><li>客户端发送的命令请求超过输入缓冲区限制</li><li>发送给客户端的结果超出输出缓冲区的限制</li></ul><p>为了避免发送给客户端的结果过大，占用过多服务器资源，服务器会时刻检查客户端输出缓冲区的大小。</p><ul><li>硬性限制 - 如果输出缓冲区大小超过了硬性限制，则立刻关闭客户端</li><li>软性限制 - 如果输出缓冲区大小超过了软性限制，客户端在 <code>obuf_soft_limit_reached_time</code> 记录下该时刻 <ul><li>如果客户端一直超出软性限制，持续时间超过阈值，则服务器关闭客户端</li><li>如果输出缓冲区的大小在指定时间内不再超出软性限制，则 <code>obuf_soft_limit_reached_time</code> 清零</li></ul></li></ul><hr><h2 id="伪客户端" tabindex="-1"><a class="header-anchor" href="#伪客户端"><span>伪客户端</span></a></h2><p>Redis 服务器在初始化时会创建一个负责执行 Lua 脚本中 Redis 命令的伪客户端，这个客户端在服务器运行期间一直存在，直到服务器被关闭：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line">    redisClient <span class="token operator">*</span>lua_client<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而服务器载入 AOF 文件而创建的伪客户端将在载入完成之后被关闭。</p>`,45)]))}const d=s(i,[["render",c],["__file","Chapter 13 - 客户端.html.vue"]]),o=JSON.parse('{"path":"/redis-implementation-notes/Part%202%20-%20%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/Chapter%2013%20-%20%E5%AE%A2%E6%88%B7%E7%AB%AF.html","title":"Chapter 13 - 客户端","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"客户端状态","slug":"客户端状态","link":"#客户端状态","children":[{"level":3,"title":"套接字描述符","slug":"套接字描述符","link":"#套接字描述符","children":[]},{"level":3,"title":"客户端名称","slug":"客户端名称","link":"#客户端名称","children":[]},{"level":3,"title":"标志","slug":"标志","link":"#标志","children":[]},{"level":3,"title":"输入缓冲区","slug":"输入缓冲区","link":"#输入缓冲区","children":[]},{"level":3,"title":"命令请求与参数","slug":"命令请求与参数","link":"#命令请求与参数","children":[]},{"level":3,"title":"命令的实现函数","slug":"命令的实现函数","link":"#命令的实现函数","children":[]},{"level":3,"title":"输出缓冲区","slug":"输出缓冲区","link":"#输出缓冲区","children":[]},{"level":3,"title":"身份认证","slug":"身份认证","link":"#身份认证","children":[]},{"level":3,"title":"时间","slug":"时间","link":"#时间","children":[]}]},{"level":2,"title":"客户端的创建与关闭","slug":"客户端的创建与关闭","link":"#客户端的创建与关闭","children":[]},{"level":2,"title":"伪客户端","slug":"伪客户端","link":"#伪客户端","children":[]}],"git":{},"filePathRelative":"redis-implementation-notes/Part 2 - 单机数据库的实现/Chapter 13 - 客户端.md"}');export{d as comp,o as data};
