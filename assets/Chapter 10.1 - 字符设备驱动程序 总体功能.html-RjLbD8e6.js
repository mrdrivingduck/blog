import{_ as n,c as a,a as e,o as t}from"./app-BeHGwf2X.js";const c="/blog/assets/10-1-C-6iC0PB.png",l="/blog/assets/10-3-CozzwBdi.png",o="/blog/assets/10-4-DxJrfCr9.png",p="/blog/assets/10-5-Cv-jNF2x.png",i="/blog/assets/10-6-BUsFlSje.png",d={};function r(u,s){return t(),a("div",null,s[0]||(s[0]=[e('<h1 id="chapter-10-1-字符设备驱动程序-总体功能" tabindex="-1"><a class="header-anchor" href="#chapter-10-1-字符设备驱动程序-总体功能"><span>Chapter 10.1 - 字符设备驱动程序 总体功能</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 08 / 24 23:41</p><p>Ningbo, Zhejiang, China</p><hr><p>在 Linux 0.12 中，字符设备主要包括 <strong>控制终端设备</strong> 和 <strong>串行终端设备</strong>。</p><hr><h2 id="_10-1-总体功能" tabindex="-1"><a class="header-anchor" href="#_10-1-总体功能"><span>10.1 总体功能</span></a></h2><h3 id="_10-1-1-终端驱动程序基本原理" tabindex="-1"><a class="header-anchor" href="#_10-1-1-终端驱动程序基本原理"><span>10.1.1 终端驱动程序基本原理</span></a></h3><p>终端驱动程序用于控制终端设备，在 <strong>终端设备</strong> 和 <strong>进程</strong> 之间传输数据，并对传输的数据进行一定的处理。用户在键盘上键入原始数据，通过驱动程序处理后，传送给一个接收进程；进程向终端发送的数据，在驱动程序处理后，显示到终端屏幕或发送到远程终端。根据驱动程序对待输入、输出数据的方式，终端工作模式分为：</p><ul><li>规范 (canonical) 模式：使用 <strong>行规则函数</strong> 对指定字符进行变换</li><li>非规范 (non-canonical) 模式：行规则函数仅在终端和进程之间传递数据，不进行变换处理</li></ul><p><img src="'+c+`" alt="10-1"></p><h3 id="_10-1-2-linux-支持的终端设备类型" tabindex="-1"><a class="header-anchor" href="#_10-1-2-linux-支持的终端设备类型"><span>10.1.2 Linux 支持的终端设备类型</span></a></h3><p>终端是一种字符型设备，有很多种类型，使用 tty 来简称各类终端设备 (Teletype 的缩写)。终端设备分为以下类型：</p><ol><li>串行端口终端 /dev/ttySn：计算机把每个串口都看作是一个字符设备</li><li>伪终端 /dev/ptyp, /dev/ttyp：功能类似一般终端的设备，不与任何终端硬件相关，配对使用 - 主设备 + 从设备；两个程序可以通过逻辑设备互相交流</li><li>控制终端 /dev/tty</li><li>控制台 /dev/ttyn, /dev/console：计算机显示器</li><li>其它类型终端</li></ol><h3 id="_10-1-3-终端基本数据结构" tabindex="-1"><a class="header-anchor" href="#_10-1-3-终端基本数据结构"><span>10.1.3 终端基本数据结构</span></a></h3><p>每个终端设备都有一个 <code>tty_struct</code> 数据结构，保存该设备的所有信息。Linux 内核使用数组 <code>tty_table[]</code> 保存系统中每个终端设备的信息。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">tty_struct</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">termios</span> termios<span class="token punctuation">;</span> <span class="token comment">// 终端 I/O 属性和控制字符数据结构</span></span>
<span class="line">    <span class="token keyword">int</span> pgrp<span class="token punctuation">;</span> <span class="token comment">// 所属进程组</span></span>
<span class="line">    <span class="token keyword">int</span> stopped<span class="token punctuation">;</span> <span class="token comment">// 停止标志</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>write<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tty_struct</span> <span class="token operator">*</span> tty<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// tty 写函数指针</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">tty_queue</span> read_q<span class="token punctuation">;</span> <span class="token comment">// tty 读队列</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">tty_queue</span> write_q<span class="token punctuation">;</span> <span class="token comment">// tty 写队列</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">tty_queue</span> secondary<span class="token punctuation">;</span> <span class="token comment">// tty 辅助队列</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">tty_struct</span> tty_table<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Linux 0.12 内核支持三个终端设备：</p><ul><li>一个控制台设备</li><li>两个串行终端设备</li></ul><p>终端所处理的数据被保存在 3 个 <code>tty_queue</code> 结构的字符缓冲队列中：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">tty_queue</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> data<span class="token punctuation">;</span> <span class="token comment">// ?</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> head<span class="token punctuation">;</span> <span class="token comment">// 数据头指针</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> tail<span class="token punctuation">;</span> <span class="token comment">// 数据尾指针</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span> proc_list<span class="token punctuation">;</span> <span class="token comment">// 等待缓冲队列的进程列表</span></span>
<span class="line">    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 队列缓冲区</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个 tty 字符队列的缓冲区长度为 1K 字节</p><ul><li>读缓冲队列 <code>read_q</code> 存放来自键盘或串行终端输入的原始字符</li><li>写缓冲队列 <code>write_q</code> 存放输出到控制台显示屏或串行终端的数据</li><li>辅助队列 <code>secondary</code> 用于存放从 <code>read_q</code> 中取出并进行 <strong>行规则变换</strong> 后的数据；转换后，以字符行为单位供应用程序读取使用</li></ul><p>当读取用户输入的数据时，中断处理程序只负责把原始字符放入输入缓冲队列。中断处理过程调用的 C 函数 <code>copy_to_cooked()</code> 负责处理字符的变换工作，将 <code>read_q</code> 中的字符经过处理，放入 <code>secondary</code> 中。如果终端设备设置了回显标志 <code>L_ECHO</code>，则也把该字符放入写队列 <code>write_q</code> 中，并调用终端写函数把字符显示在屏幕上。<code>termios</code> 结构保存了设备的所有控制标志：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">termios</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> c_iflag<span class="token punctuation">;</span> <span class="token comment">// 输入模式标志</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> c_oflag<span class="token punctuation">;</span> <span class="token comment">// 输出模式标志</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> c_cflag<span class="token punctuation">;</span> <span class="token comment">// 控制模式标志</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> c_lflag<span class="token punctuation">;</span> <span class="token comment">// 本地模式标志</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> c_line<span class="token punctuation">;</span> <span class="token comment">// 线路规程 (速率)</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> c_cc<span class="token punctuation">[</span>NCCS<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 控制字符数组</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>c_iflag</code> 实现了 POSIX.1 定义的所有 11 个输入标志，终端驱动程序利用这些标志控制如何对输入字符进行变换</li><li><code>c_oflag</code> - 终端驱动程序使用这些标志控制如何把字符输出到终端上</li><li><code>c_cflag</code> - 定义串行终端传输特性 - 波特率、字符比特位数、停止位数</li><li><code>c_lflag</code> - 控制驱动程序与用户的交互</li><li><code>c_cc[]</code> 数组定义了终端所有可以修改的特殊字符</li></ul><h3 id="_10-1-4-规范模式和非规范模式" tabindex="-1"><a class="header-anchor" href="#_10-1-4-规范模式和非规范模式"><span>10.1.4 规范模式和非规范模式</span></a></h3><h4 id="_10-1-4-1-规范模式" tabindex="-1"><a class="header-anchor" href="#_10-1-4-1-规范模式"><span>10.1.4.1 规范模式</span></a></h4><p><code>c_lflag</code> 中的 ICANON 标志置位。此时输入字符会被装配成行，进程以字符行为单位进行读取。一行字符输入后，终端驱动程序立刻返回。行的界定符：</p><ul><li><code>NL</code></li><li><code>EOL</code></li><li><code>EOL2</code></li><li><code>EOF</code>：会被处理程序删除，其它字符会作为一行的最后一个字符返回给调用程序</li></ul><h4 id="_10-1-4-2-非规范模式" tabindex="-1"><a class="header-anchor" href="#_10-1-4-2-非规范模式"><span>10.1.4.2 非规范模式</span></a></h4><p>终端驱动程序不对字符进行处理。输入数据也没有行的概念。终端驱动程序何时返回读进程由 MIN 和 TIME 的值决定 - 位于 <code>c_cc[]</code> 中。</p><h3 id="_10-1-5-控制台终端和串行终端设备" tabindex="-1"><a class="header-anchor" href="#_10-1-5-控制台终端和串行终端设备"><span>10.1.5 控制台终端和串行终端设备</span></a></h3><p>Linux 0.12 仅支持这两种终端设备：</p><blockquote><p>我的理解是一个用于本地，一个用于远程。因此肯定多了一部分和串口通信相关的代码。而其它部分一定有功能相同的部分。</p></blockquote><p><img src="`+l+'" alt="10-3"></p><h4 id="_10-1-5-1-控制台驱动程序" tabindex="-1"><a class="header-anchor" href="#_10-1-5-1-控制台驱动程序"><span>10.1.5.1 控制台驱动程序</span></a></h4><ul><li><code>keyboard.S</code> - 处理用户键入的字符，把它们放入读缓冲队列</li><li><code>console.c</code> - 实现控制台终端收到代码后的输出处理</li></ul><p>用户在键盘上键入一个字符，引发键盘中断响应：INT 33。<strong>键盘中断处理程序</strong> 从 <strong>键盘控制器</strong> 读入对应的键盘扫描码，翻译成对应的字符后，放入 tty 读队列 <code>read_q</code> 中。然后调用中断处理程序的 C 函数 <code>do_tty_interrupt</code>。其中调用 <strong>行规则函数</strong> <code>copy_to_cooked()</code> 对该字符进行过滤处理，并放入 tty 辅助队列 <code>secondary</code> 和写队列 <code>write_q</code> 中，调用 <strong>写控制台函数</strong> <code>con_write()</code> 进行显示操作。整个过程的示意图如图所示：</p><p><img src="'+o+'" alt="10-4"></p><p>对于 tty 写操作，终端驱动程序时一个字符一个字符进行处理的。当写缓冲队列 <code>write_q</code> 未满时，程序从用户缓冲区取一个字符，经过处理后放入 <code>write_q</code> 中。当用户数据全部放入 <code>write_q</code> 或此时 <code>write_q</code> 已满，就调用 <code>tty_struct</code> 指定的写函数，将 <code>write_q</code> 中的数据输出到控制台。程序与操作的关系如图所示：</p><p><img src="'+p+'" alt="10-5"></p><h4 id="_10-1-5-2-串行终端驱动程序" tabindex="-1"><a class="header-anchor" href="#_10-1-5-2-串行终端驱动程序"><span>10.1.5.2 串行终端驱动程序</span></a></h4><ul><li><code>serial.c</code>：对串行端口进行初始化操作</li><li><code>rs_io.s</code>：串行终端处理过程</li></ul><p>引起系统串行中断的情况：</p><ol><li>modem 状态发生变化</li><li>线路状态发生变化</li><li>接收到字符</li><li>在 <strong>中断允许标志寄存器</strong> 中设置了 <strong>发送保持寄存器中断允许标志</strong>，需要发送字符</li></ol><p>对于前两种情况，读取相应的状态寄存器值即可使其复位。接收到字符的情况下，首先把字符放入读缓冲队列中，再调用行规则函数处理后放入辅助队列。对于要发送字符的情况，首先从写缓冲队列尾部取出字符发送出去，再判断写缓冲队列是否为空，若还有字符，则循环执行发送操作。</p><p>处理过程：对于一个接在串行端口上的中断，键入的字符通过串行线路传送到主机，引发主机串行口的中断请求。串行口中断处理程序将字符放入串行终端的读缓冲队列中，然后调用中断处理过程中的 C 函数 <code>do_tty_interrupt()</code>，而该函数又会直接调用行规则函数 <code>copy_to_cooked()</code>，对字符进行处理，并放入辅助队列。同时该字符也会被放入写队列，并调用写串口终端的函数 <code>rs_write()</code>，将字符送回串行终端进行回显。</p><p>串行终端的 <code>tty_struct</code> 数据结构的写函数是 <code>rs_write()</code>：</p><ul><li>该函数会取消对 <strong>发送保持寄存器</strong> 的 <strong>空允许中断</strong> 的屏蔽</li><li>发送保持寄存器为空时，引起串行中断的产生</li><li>串行中断处理过程从写缓冲队列中取出字符，放入发送保持寄存器中</li><li>一次中断发送一个字符</li><li>写缓冲队列为空时，屏蔽发送保持寄存器的 <strong>空允许中断</strong>，从而禁止此类中断的发生</li></ul><p>程序与操作的关系如图所示：</p><p><img src="'+i+'" alt="10-6"></p><h3 id="_10-1-6-终端驱动程序接口" tabindex="-1"><a class="header-anchor" href="#_10-1-6-终端驱动程序接口"><span>10.1.6 终端驱动程序接口</span></a></h3><p>通常，用户通过 <strong>文件系统</strong> 与设备打交道。每个设备都有一个文件名称，因此在文件系统中占用一个类型为设备的 inode，用户可以直接使用文件系统的系统调用来访问设备。而终端驱动程序需要向文件系统提供调用的接口函数 - 在 <code>tty_io.c</code> 中实现：</p><ul><li>读终端函数 <code>tty_read()</code></li><li>写终端函数 <code>tty_write()</code></li><li>行规则函数 <code>copy_to_cooked()</code></li></ul><p>在 <code>tty_ioctl.c</code> 程序中，实现了修改终端参数的输入输出控制函数 <code>tty_ioctl()</code> (修改 <code>termios</code> 结构体)。对于不同的终端设备，可以有不同的行规则程序与之匹配。但 Linux 0.12 中仅有一个行规则函数。</p>',57)]))}const _=n(d,[["render",r],["__file","Chapter 10.1 - 字符设备驱动程序 总体功能.html.vue"]]),m=JSON.parse('{"path":"/linux-kernel-comments-notes/Chapter%2010%20-%20%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/Chapter%2010.1%20-%20%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%20%E6%80%BB%E4%BD%93%E5%8A%9F%E8%83%BD.html","title":"Chapter 10.1 - 字符设备驱动程序 总体功能","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"10.1 总体功能","slug":"_10-1-总体功能","link":"#_10-1-总体功能","children":[{"level":3,"title":"10.1.1 终端驱动程序基本原理","slug":"_10-1-1-终端驱动程序基本原理","link":"#_10-1-1-终端驱动程序基本原理","children":[]},{"level":3,"title":"10.1.2 Linux 支持的终端设备类型","slug":"_10-1-2-linux-支持的终端设备类型","link":"#_10-1-2-linux-支持的终端设备类型","children":[]},{"level":3,"title":"10.1.3 终端基本数据结构","slug":"_10-1-3-终端基本数据结构","link":"#_10-1-3-终端基本数据结构","children":[]},{"level":3,"title":"10.1.4 规范模式和非规范模式","slug":"_10-1-4-规范模式和非规范模式","link":"#_10-1-4-规范模式和非规范模式","children":[]},{"level":3,"title":"10.1.5 控制台终端和串行终端设备","slug":"_10-1-5-控制台终端和串行终端设备","link":"#_10-1-5-控制台终端和串行终端设备","children":[]},{"level":3,"title":"10.1.6 终端驱动程序接口","slug":"_10-1-6-终端驱动程序接口","link":"#_10-1-6-终端驱动程序接口","children":[]}]}],"git":{},"filePathRelative":"linux-kernel-comments-notes/Chapter 10 - 字符设备驱动程序/Chapter 10.1 - 字符设备驱动程序 总体功能.md"}');export{_ as comp,m as data};
