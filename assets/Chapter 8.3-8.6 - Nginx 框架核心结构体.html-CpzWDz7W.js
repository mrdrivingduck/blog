import{_ as s,c as a,a as e,o as c}from"./app-BeHGwf2X.js";const p={};function t(l,n){return c(),a("div",null,n[0]||(n[0]=[e(`<h1 id="chapter-8-3-8-6-nginx-框架核心结构体" tabindex="-1"><a class="header-anchor" href="#chapter-8-3-8-6-nginx-框架核心结构体"><span>Chapter 8.3-8.6 - Nginx 框架核心结构体</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 07 / 20 13:59</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="_8-3-nginx-框架中的核心结构体-ngx-cycle-t" tabindex="-1"><a class="header-anchor" href="#_8-3-nginx-框架中的核心结构体-ngx-cycle-t"><span>8.3 Nginx 框架中的核心结构体 <code>ngx_cycle_t</code></span></a></h2><p>Nginx 核心的框架代码围绕着这个结构体展开。每个进程 (master / worker / cache manager / cache loader) 都会拥有一个唯一的 <code>ngx_cyclt_t</code> 结构体。Nginx 的启动初始化、正常运行都以这个结构体为中心。</p><h3 id="_8-3-1-ngx-listening-t-结构体" tabindex="-1"><a class="header-anchor" href="#_8-3-1-ngx-listening-t-结构体"><span>8.3.1 <code>ngx_listening_t</code> 结构体</span></a></h3><p>Nginx 作为一个 Web 服务器，需要监听端口以处理其中的网络事件。在 Nginx 中，每个 <code>ngx_listening_t</code> 结构体都代表着一个监听端口。这样的结构体组成的数组会被维护在 <code>ngx_cycle_t</code> 核心结构体中：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ngx_listening_s</span> <span class="token class-name">ngx_listening_t</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">ngx_listening_s</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">ngx_socket_t</span> fd<span class="token punctuation">;</span> <span class="token comment">// socket 句柄</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>sockaddr<span class="token punctuation">;</span> <span class="token comment">// 监听地址</span></span>
<span class="line">    <span class="token class-name">socklen_t</span> socklen<span class="token punctuation">;</span> <span class="token comment">// 地址长度</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">size_t</span> addr_text_max_len<span class="token punctuation">;</span> <span class="token comment">// IP 地址字符串最大长度</span></span>
<span class="line">    <span class="token class-name">ngx_str_t</span> addr_text<span class="token punctuation">;</span> <span class="token comment">// 字符串形式的 IP 地址</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">int</span> type<span class="token punctuation">;</span> <span class="token comment">// socket 类型</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">int</span> backlog<span class="token punctuation">;</span> <span class="token comment">// backlog 队列</span></span>
<span class="line">    <span class="token keyword">int</span> rcvbuf<span class="token punctuation">;</span> <span class="token comment">// 内核 socket 接收缓冲区</span></span>
<span class="line">    <span class="token keyword">int</span> sndbuf<span class="token punctuation">;</span> <span class="token comment">// 内核 socket 发送缓冲区</span></span>
<span class="line"></span>
<span class="line">    ngx_connection_handler_pt handler<span class="token punctuation">;</span> <span class="token comment">// 新的 TCP 连接建立成功后的处理方法</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">void</span> <span class="token operator">*</span>servers<span class="token punctuation">;</span> <span class="token comment">// 保存当前监听端口对应的所有主机名</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 日志对象指针</span></span>
<span class="line">    <span class="token class-name">ngx_log_t</span> log<span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">ngx_log_t</span> <span class="token operator">*</span>logp<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">size_t</span> pool_size<span class="token punctuation">;</span> <span class="token comment">// 为新的 TCP 连接创建的内存池大小</span></span>
<span class="line">    <span class="token class-name">ngx_msec_t</span> post_accept_timeout<span class="token punctuation">;</span> <span class="token comment">// 连接建立后，指定时间内没有收到用户数据，则丢弃连接</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">ngx_listening_t</span> <span class="token operator">*</span>previous<span class="token punctuation">;</span> <span class="token comment">// 多个结构体由该指针串成单链表</span></span>
<span class="line">    <span class="token class-name">ngx_connection_t</span> <span class="token operator">*</span>connection<span class="token punctuation">;</span> <span class="token comment">// 指向对应的连接结构体</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">unsigned</span> open<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 当前监听句柄是否有效的标志位</span></span>
<span class="line">    <span class="token keyword">unsigned</span> remain<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 初始化新的 ngx_cycle_t 结构体 (运行时更新 Nginx) 时，保留原先打开的监听端口</span></span>
<span class="line">    <span class="token keyword">unsigned</span> ignore<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 跳过设置当前结构体中的 socket</span></span>
<span class="line">    <span class="token keyword">unsigned</span> bound<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 未被使用</span></span>
<span class="line">    <span class="token keyword">unsigned</span> inherited<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 是否继承自前一个进程</span></span>
<span class="line">    <span class="token keyword">unsigned</span> nonblocking_accept<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 未使用</span></span>
<span class="line">    <span class="token keyword">unsigned</span> listen<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 当前结构体对应的 socket 是否已经在监听</span></span>
<span class="line">    <span class="token keyword">unsigned</span> nonblocking<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// socket 是否阻塞</span></span>
<span class="line">    <span class="token keyword">unsigned</span> shared<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 无意义</span></span>
<span class="line">    <span class="token keyword">unsigned</span> addr_ntop<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 将网络地址转换为字符串形式的地址</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，<code>handler</code> 成员在这个监听端口上成功建立 TCP 连接后就会被回调：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>ngx_connection_handler_pt<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">ngx_connection_t</span> <span class="token operator">*</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_8-3-2-ngx-cycle-t-结构体" tabindex="-1"><a class="header-anchor" href="#_8-3-2-ngx-cycle-t-结构体"><span>8.3.2 ngx_cycle_t 结构体</span></a></h3><p>该结构体中保存着 Nginx 配置文件的路径。因此，在初始化时，Nginx 框架就要通过读取配置文件来填充数据结构。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ngx_cycle_s</span> <span class="token class-name">ngx_cycle_t</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">ngx_cycle_s</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>conf_ctx<span class="token punctuation">;</span> <span class="token comment">// 保存所有模块配置项结构体的指针</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">ngx_pool_t</span> <span class="token operator">*</span>pool<span class="token punctuation">;</span> <span class="token comment">// 内存池</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">ngx_log_t</span> <span class="token operator">*</span>log<span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">ngx_log_t</span> new_log<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">ngx_uint_t</span> files_n<span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">ngx_connection_t</span> <span class="token operator">*</span><span class="token operator">*</span>files<span class="token punctuation">;</span> <span class="token comment">// 所有连接</span></span>
<span class="line">    <span class="token class-name">ngx_connection_t</span> <span class="token operator">*</span>free_connections<span class="token punctuation">;</span> <span class="token comment">// 可用连接池</span></span>
<span class="line">    <span class="token class-name">ngx_uint_t</span> free_connection_n<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">ngx_queue_t</span> resuable_connections_queue<span class="token punctuation">;</span> <span class="token comment">// 可重复使用的 ngx_connection_t 连接队列</span></span>
<span class="line">    <span class="token class-name">ngx_array_t</span> listening<span class="token punctuation">;</span> <span class="token comment">// 监听端口 ngx_listening_t 的动态数组</span></span>
<span class="line">    <span class="token class-name">ngx_array_t</span> pathes<span class="token punctuation">;</span> <span class="token comment">// Nginx 要操作的所有目录，如果不存在则试图创建，如果不成功则启动失败</span></span>
<span class="line">    <span class="token class-name">ngx_list_t</span> open_files<span class="token punctuation">;</span> <span class="token comment">// Nginx 已经打开的所有文件</span></span>
<span class="line">    <span class="token class-name">ngx_list_t</span> shared_memory<span class="token punctuation">;</span> <span class="token comment">// 共享内存链表</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">ngx_uint_t</span> connection_n<span class="token punctuation">;</span> <span class="token comment">// 当前进程的连接总数</span></span>
<span class="line">    <span class="token class-name">ngx_connection_t</span> <span class="token operator">*</span>connections<span class="token punctuation">;</span> <span class="token comment">// 当前进程的所有连接对象</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">ngx_event_t</span> <span class="token operator">*</span>read_events<span class="token punctuation">;</span> <span class="token comment">// 当前进程的所有读事件对象</span></span>
<span class="line">    <span class="token class-name">ngx_event_t</span> <span class="token operator">*</span>write_events<span class="token punctuation">;</span> <span class="token comment">// 当前进程的所有写事件对象</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">ngx_cycle_t</span> <span class="token operator">*</span>old_cycle<span class="token punctuation">;</span> <span class="token comment">// 用于引用前一个 ngx_cycle_t 对象的成员</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">ngx_str_t</span> conf_file<span class="token punctuation">;</span> <span class="token comment">// 配置文件相对于安装目录的路径</span></span>
<span class="line">    <span class="token class-name">ngx_str_t</span> conf_param<span class="token punctuation">;</span> <span class="token comment">// 需要特殊处理的命令行参数</span></span>
<span class="line">    <span class="token class-name">ngx_str_t</span> conf_prefix<span class="token punctuation">;</span> <span class="token comment">// 配置文件所在的目录路径</span></span>
<span class="line">    <span class="token class-name">ngx_str_t</span> prefix<span class="token punctuation">;</span> <span class="token comment">// Nginx 安装目录</span></span>
<span class="line">    <span class="token class-name">ngx_str_t</span> lock_file<span class="token punctuation">;</span> <span class="token comment">// 用于进程同步的文件锁名称</span></span>
<span class="line">    <span class="token class-name">ngx_str_t</span> hostname<span class="token punctuation">;</span> <span class="token comment">// gethostname() 系统调用得到的主机名</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在构造这个结构体的函数中，大部分的属性都会被初始化。</p><h2 id="_8-4-nginx-启动时框架的处理流程" tabindex="-1"><a class="header-anchor" href="#_8-4-nginx-启动时框架的处理流程"><span>8.4 Nginx 启动时框架的处理流程</span></a></h2><ol><li>解析命令行参数，确定配置文件路径，创建一个临时的 <code>ngx_cycle_t</code> 变量存放配置文件路径</li><li>(平滑升级)，旧的 master 进程通过 <code>fork()</code> 和 <code>execve()</code> 启动新版本的 master 进程，并通过环境变量传递升级信息</li><li>调用所有核心模块的 <code>create_conf()</code> 函数，构造各模块用于存储配置项的数据结构</li><li>调用配置模块提供的配置项解析函数，遍历配置文件中的所有配置项 (获取要监听的端口)</li><li>调用所有模块的 <code>init_conf()</code> 函数，在配置项解析完毕后可以做一些处理工作</li><li>将 <code>ngx_cycle_t</code> 结构体中保存的目录或文件打开，初始化用于进程通信的共享内存</li><li>根据配置中解析的待监听端口 (保存在 <code>ngx_listening_t</code> 中)，设置 socket 句柄并监听端口</li><li>调用所有模块的 <code>init_module()</code> 函数</li></ol><p>接下来，如果 Nginx 被配置为单进程工作模式，则调用 <code>ngx_single_process_cycle()</code> 函数进入单进程工作模式，调用所有模块的 <code>init_process()</code> 函数，启动完毕。如果 Nginx 被配置为 master / worker 模式，则还要按照配置文件中指定的数目启动子进程，再调用所有模块的 <code>init_process()</code> 函数；另外，还要按情况启动 cache manager 子进程和 cache loader 子进程。</p><h2 id="_8-5-worker-进程是如何工作的" tabindex="-1"><a class="header-anchor" href="#_8-5-worker-进程是如何工作的"><span>8.5 Worker 进程是如何工作的</span></a></h2><p>主要关注 worker 进程的循环 <code>worker_process_cycle()</code> 函数。在这个循环中，程序不断对四个全局标志位进行检测，并对标志位执行相应的函数。Nginx 采用信号来设置这些标志位 - <code>ngx_signal_handler()</code> 函数根据接收到的信号，设置这些标志位：</p><table><thead><tr><th>信号</th><th>标志位</th><th>意义</th></tr></thead><tbody><tr><td><code>QUIT</code></td><td><code>sig_atomic_t ngx_quit</code></td><td>优雅地关闭进程</td></tr><tr><td><code>TERM</code> / <code>INT</code></td><td><code>sig_atomic_t ngx_terminate</code></td><td>强制关闭进程</td></tr><tr><td><code>USR1</code></td><td><code>sig_atomic_t ngx_reopen</code></td><td>重新打开所有文件</td></tr></tbody></table><ol><li>首先检测 <code>ngx_existing</code> 标志位是否为 <code>1</code>。如果为 <code>1</code>，则开始准备关闭 worker 进程 (这个标志由 <code>ngx_quit</code> 设置) <ul><li>对于正在处理的连接，调用关闭连接的函数</li><li>检查 <code>ngx_event_timer_rbtree</code> 是否还有定时事件要执行</li><li>调用所有模块的 <code>exit_process()</code> 函数，销毁内存池，退出 worker 进程</li></ul></li><li>调用 <code>ngx_process_events_and_timers()</code> 函数处理定时事件 (事件模块的核心函数)</li><li>检查 <code>ngx_terminate</code> 标志位，如果置位，则立刻调用所有模块的 <code>exit_process()</code> 函数，并销毁内存池，退出 worker 进程</li><li>检查 <code>ngx_quit</code> 标志位，如果置位，则优雅地关闭连接 - 首先将进程的名称修改，然后关闭所有监听的端口，并设置 <code>ngx_exiting</code> 标志为 <code>1</code>，继续向下执行</li><li>检查 <code>ngx_reopen</code> 标志位，如果置位，则需要重新打开所有文件</li><li>回到 1，进入下一个循环</li></ol><h2 id="_8-6-master-进程是如何工作的" tabindex="-1"><a class="header-anchor" href="#_8-6-master-进程是如何工作的"><span>8.6 Master 进程是如何工作的</span></a></h2><p>Master 进程不处理网络事件，只会管理 worker 子进程来实现重启服务、平滑升级、更换日志文件、更换配置文件等功能。Master 进程的主循环也是通过检查由信号设置的标志位来实现的，同样，<code>ngx_signal_handler()</code> 函数根据接收到的信号设置这些标志位。</p><table><thead><tr><th>信号</th><th>标志位</th><th>意义</th></tr></thead><tbody><tr><td><code>QUIT</code></td><td><code>ngx_quit</code></td><td>优雅地关闭服务</td></tr><tr><td><code>TERM</code> / <code>INT</code></td><td><code>ngx_terminate</code></td><td>强制关闭服务</td></tr><tr><td><code>USR1</code></td><td><code>ngx_reopen</code></td><td>重新打开服务中的所有文件</td></tr><tr><td><code>WINCH</code></td><td><code>ngx_noaccept</code></td><td>所有子进程不再处理新的连接</td></tr><tr><td><code>USR2</code></td><td><code>ngx_change_binary</code></td><td>平滑升级到新版本的 Nginx</td></tr><tr><td><code>HUP</code></td><td><code>ngx_reconfigure</code></td><td>重新读取配置文件，并使服务对新配置项生效</td></tr><tr><td><code>CHLD</code></td><td><code>ngx_reap</code></td><td>有子进程意外结束，此时需要监控所有的子进程</td></tr><tr><td></td><td><code>ngx_restart</code></td><td></td></tr></tbody></table><p>Master 进程的所有子进程信息都被维护在一个数组中，用于管理子进程：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NGX_MAX_PROCESSES</span> <span class="token expression"><span class="token number">1024</span> </span><span class="token comment">// 最多 1024 个子进程</span></span></span>
<span class="line"></span>
<span class="line"><span class="token class-name">ngx_int_t</span> ngx_process_slot<span class="token punctuation">;</span> <span class="token comment">// 当前操作的进程下标</span></span>
<span class="line"></span>
<span class="line"><span class="token class-name">ngx_int_t</span> ngx_last_process<span class="token punctuation">;</span> <span class="token comment">// 有意义进程的最大下标</span></span>
<span class="line"></span>
<span class="line"><span class="token class-name">ngx_process_t</span> ngx_processes<span class="token punctuation">[</span>NGX_MAX_PROCESS<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 子进程数组</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">ngx_pid_t</span> pid<span class="token punctuation">;</span> <span class="token comment">// 进程 ID</span></span>
<span class="line">    <span class="token keyword">int</span> status<span class="token punctuation">;</span> <span class="token comment">// 有 waitpid() 获取到的进程状态</span></span>
<span class="line">    <span class="token class-name">ngx_socket_t</span> channel<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 用于 master 与 worker 之间的通信</span></span>
<span class="line"></span>
<span class="line">    ngx_spawn_proc_pt proc<span class="token punctuation">;</span> <span class="token comment">// 子进程的循环执行函数</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">;</span> <span class="token comment">// 函数指针</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span> <span class="token comment">// 进程名称</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">unsigned</span> respawn<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 标志位，重新生成子进程</span></span>
<span class="line">    <span class="token keyword">unsigned</span> just_spawn<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 标志位，正在生成子进程</span></span>
<span class="line">    <span class="token keyword">unsigned</span> detached<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 标志位，正在进行父子进程分离</span></span>
<span class="line">    <span class="token keyword">unsigned</span> exiting<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 标志位，进程正在退出</span></span>
<span class="line">    <span class="token keyword">unsigned</span> exited<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 标志位，进程已经退出</span></span>
<span class="line"><span class="token punctuation">}</span> <span class="token class-name">ngx_process_t</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Master 进程如何启动子进程？首先通过 <code>fork()</code> 系统调用产生子进程，并在 <code>ngx_processes</code> 数组中选择一个还未使用的槽来存储这个子进程的相关信息。在构造子进程时，需要将子进程将要执行的工作循环函数指针作为参数。因此 worker 进程、cache manager 进程、cache loader 进程的工作循环的定义方式都是一致的：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token comment">// 产生子进程调用的函数</span></span>
<span class="line"><span class="token class-name">ngx_pid_t</span> <span class="token function">ngx_spawn_process</span><span class="token punctuation">(</span><span class="token class-name">ngx_cycle_t</span> <span class="token operator">*</span>cycle<span class="token punctuation">,</span> ngx_spawn_proc_pt proc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token class-name">ngx_int_t</span> respawn<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>ngx_spawn_proc_pt<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">ngx_cycle_t</span> <span class="token operator">*</span>cycle<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 子进程工作循环函数指针定义</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ngx_worker_process_cycle</span><span class="token punctuation">(</span><span class="token class-name">ngx_cycle_t</span> <span class="token operator">*</span>cycle<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Worker 进程工作循环</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ngx_cache_manager_process_cycle</span><span class="token punctuation">(</span><span class="token class-name">ngx_cycle_t</span> <span class="token operator">*</span>cycle<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Cache 进程工作循环</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当子进程意外退出时，master 进程会收到来自内核的 <code>CHLD</code> 信号。通过遍历 <code>ngx_processes</code> 数组，维护子进程的状态。在 master 进程的工作循环中，对上述八个标志位进行检测，如果标志位被置位，则进入相应的分支进行处理：</p><ol><li>(由内核 <code>CHLD</code> 信号激活) <code>ngx_reap</code> 标志置位，则遍历 <code>ngx_processes</code> 数组并检查每个子进程的状态，重新拉起非正常退出的子进程，返回 <code>live</code> 标志</li><li>如果 <code>live</code> 标志为 0 (所有子进程正常退出) 且 <code>ngx_terminate</code> / <code>ngx_quit</code> 标志位为 1 时，开始退出 master 进程，删除存储 pid 的文件</li><li>调用所有模块的 <code>exit_master()</code> 函数</li><li>调用 <code>ngx_master_process_exit()</code> 关闭进程打开的监听端口</li><li>销毁内存池，退出 master 进程</li><li>如果 <code>ngx_terminate</code> 标志置位，则向所有子进程发送 <code>TERM</code> 信号 (强制关闭)，然后挂起进程等待内核信号在第 1 步激活进程</li><li>如果 <code>ngx_quit</code> 标志置位，则要开始着手优雅地退出服务 - 向所有子进程发送 <code>QUIT</code> 信号 (优雅关闭)</li><li>接上步，关闭所有监听端口，挂起 master 进程并等待内核信号在第 1 步激活进程</li><li>如果 <code>ngx_reconfigure</code> 标志置位，则需要重新读取配置文件 - Nginx 会重新初始化 <code>ngx_cycle_t</code> 结构体</li><li>接上步，用新的 <code>ngx_cycle_t</code> 拉起新的 worker 进程</li><li>接上步，根据缓存模块的加载情况，决定是否拉起 cache manager 进程或 cache loader 进程，把 <code>live</code> 标志置位</li><li>接上步，向使用原有配置的 worker 进程发送 <code>QUIT</code> 信号，要求它们优雅地结束服务</li><li>如果 <code>ngx_restart</code> 标志置位，那么就要拉起 worker 进程</li><li>接上步，根据缓存模块情况选择是否启动 cache manager 进程或 cache loader 进程</li><li>如果 <code>ngx_reopen</code> 标志置位，则重新打开所有文件</li><li>接上步，向所有子进程发送 <code>USR1</code> 信号，要求子进程重新打开所有文件</li><li>如果 <code>ngx_change_binary</code> 标志置位，则平滑升级 Nginx，使用新的子进程启动新版本的 Nginx 程序</li><li>如果 <code>ngx_noaccept</code> 标志置位，则向所有子进程发送 <code>QUIT</code>，并设置 <code>ngx_noaccepting</code> 表示停止接受新的连接，然后返回第 1 步进入下一个循环</li></ol>`,32)]))}const i=s(p,[["render",t],["__file","Chapter 8.3-8.6 - Nginx 框架核心结构体.html.vue"]]),d=JSON.parse('{"path":"/understanding-nginx-notes/Part%203%20-%20%E6%B7%B1%E5%85%A5%20Nginx/Chapter%208.3-8.6%20-%20Nginx%20%E6%A1%86%E6%9E%B6%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84%E4%BD%93.html","title":"Chapter 8.3-8.6 - Nginx 框架核心结构体","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"8.3 Nginx 框架中的核心结构体 ngx_cycle_t","slug":"_8-3-nginx-框架中的核心结构体-ngx-cycle-t","link":"#_8-3-nginx-框架中的核心结构体-ngx-cycle-t","children":[{"level":3,"title":"8.3.1 ngx_listening_t 结构体","slug":"_8-3-1-ngx-listening-t-结构体","link":"#_8-3-1-ngx-listening-t-结构体","children":[]},{"level":3,"title":"8.3.2 ngx_cycle_t 结构体","slug":"_8-3-2-ngx-cycle-t-结构体","link":"#_8-3-2-ngx-cycle-t-结构体","children":[]}]},{"level":2,"title":"8.4 Nginx 启动时框架的处理流程","slug":"_8-4-nginx-启动时框架的处理流程","link":"#_8-4-nginx-启动时框架的处理流程","children":[]},{"level":2,"title":"8.5 Worker 进程是如何工作的","slug":"_8-5-worker-进程是如何工作的","link":"#_8-5-worker-进程是如何工作的","children":[]},{"level":2,"title":"8.6 Master 进程是如何工作的","slug":"_8-6-master-进程是如何工作的","link":"#_8-6-master-进程是如何工作的","children":[]}],"git":{},"filePathRelative":"understanding-nginx-notes/Part 3 - 深入 Nginx/Chapter 8.3-8.6 - Nginx 框架核心结构体.md"}');export{i as comp,d as data};
