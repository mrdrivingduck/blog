import{_ as t,c as i,a as o,o as l}from"./app-BeHGwf2X.js";const n={};function r(a,e){return l(),i("div",null,e[0]||(e[0]=[o('<h1 id="algorithm-rb-tree" tabindex="-1"><a class="header-anchor" href="#algorithm-rb-tree"><span>Algorithm - RB-Tree</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 11 / 13 21:56</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="about" tabindex="-1"><a class="header-anchor" href="#about"><span>About</span></a></h2><p>众所周知，二叉搜索树能够提升查找的性能：结点的左子树下所有结点都比该结点小，右子树下所有结点都比该结点大。理想情况下，每次砍掉了一半需要搜索的对象，时间复杂度为 <code>O(log(n))</code>。但树的失衡将导致时间复杂度的退化为 <code>O(n)</code>，所以应当采用一些手段维护二叉搜索树的平衡。</p><h2 id="avl" tabindex="-1"><a class="header-anchor" href="#avl"><span>AVL</span></a></h2><p>平衡二叉树。在定义上，要求所有子树的高度差不超过 <code>1</code>，是一种 <strong>严格定义</strong> 的平衡二叉树：</p><ul><li>一旦不满足条件，就要进行旋转</li><li>旋转较为耗时</li><li>维护代价高</li></ul><p>因此 AVL 更适合插入和删除较少，而查询较多的情况，据说在 <em>Windows NT</em> 内核中广泛存在。</p><h2 id="rb-tree" tabindex="-1"><a class="header-anchor" href="#rb-tree"><span>RB-Tree</span></a></h2><p><strong>红黑树</strong> 是一种比较常见的数据结构，使得对数据的搜索、插入、删除都能保持 <code>O(log(n))</code> 的时间复杂度。C++ STL 的 map、JDK 中的 TreeMap 等，都是使用红黑树实现的。红黑树是 <strong>相对平衡</strong> 的，或者说是 <strong>弱平衡</strong> 的，平衡条件没有 AVL 那么苛刻，因此 RB-Tree 的高度可能比 AVL 略高些，但是显著减少了因维护平衡性而旋转的次数。所以在搜索、插入、删除操作都较多的情况下性能较好，得到了广泛的使用。</p><h3 id="definition" tabindex="-1"><a class="header-anchor" href="#definition"><span>Definition</span></a></h3><p>RB-Tree 也是一种二叉搜索树，但所有结点额外维护各自的颜色：要么是红，要么是黑。RB-Tree 的规则：</p><ol><li>root 结点为 <strong>黑色</strong></li><li>任意从 root 到叶子结点的路径不包含 <strong>连续</strong> 的 <strong>红色结点</strong> (即，红结点的子结点肯定是黑结点)</li><li>任意从 root 到叶子结点的路径上黑色结点总数相同 (以此保证平衡性)</li></ol><p>根据以上定义，最不平衡的一种情况，最长路径也不会超过最短路径的两倍。😨</p><ul><li><code>root(黑) -&gt; 黑 -&gt; 黑</code></li><li><code>root(黑) -&gt; 红 -&gt; 黑 -&gt; 红 -&gt; 黑 -&gt; 红</code></li></ul><p>关于查找，和普通的二叉搜索树的方法一致，复杂的点主要在于插入和删除。插入和删除会破坏红黑树的定义，导致需要进行旋转；而旋转时，又会造成结点颜色不符合定义，要对结点进行重新着色。在插入结点时，为了方便，一般默认将插入的结点设置为红色，因为插入黑色肯定会破坏定义导致旋转。</p><h3 id="modification" tabindex="-1"><a class="header-anchor" href="#modification"><span>Modification</span></a></h3><p>具体插入和删除的算法没有看。很久之前写过 AVL 的都给我整得够呛，主要就是递归的旋转 + 变色吧。网上有一个 <em>alibaba</em> 的老哥写得不错：</p><ul><li>https://www.cnblogs.com/fanzhidongyzby/p/3187912.html</li><li>https://github.com/fanzhidongyzby/RBTree</li></ul>',22)]))}const h=t(n,[["render",r],["__file","Algorithm RB-Tree.html.vue"]]),d=JSON.parse('{"path":"/notes/Algorithm/Algorithm%20RB-Tree.html","title":"Algorithm - RB-Tree","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"About","slug":"about","link":"#about","children":[]},{"level":2,"title":"AVL","slug":"avl","link":"#avl","children":[]},{"level":2,"title":"RB-Tree","slug":"rb-tree","link":"#rb-tree","children":[{"level":3,"title":"Definition","slug":"definition","link":"#definition","children":[]},{"level":3,"title":"Modification","slug":"modification","link":"#modification","children":[]}]}],"git":{},"filePathRelative":"notes/Algorithm/Algorithm RB-Tree.md"}');export{h as comp,d as data};
