import{_ as i,c as s,a as n,o as a}from"./app-BeHGwf2X.js";const l={};function t(o,e){return a(),s("div",null,e[0]||(e[0]=[n(`<h1 id="chapter-7-system-configuration-logging-system-time-batch-jobs-and-users" tabindex="-1"><a class="header-anchor" href="#chapter-7-system-configuration-logging-system-time-batch-jobs-and-users"><span>Chapter 7 - System Configuration: Logging, System Time, Batch Jobs, and Users</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 07 / 01 21:25</p><p>@NUAA, Nanjing, Jiangsu, China</p><hr><h2 id="_7-1-the-structure-of-etc" tabindex="-1"><a class="header-anchor" href="#_7-1-the-structure-of-etc"><span>7.1 The Structure of /etc</span></a></h2><p>大部分的配置文件存放在 <code>/etc</code> 下的子目录中：</p><ul><li>针对单机的自定义配置文件，比如： <ul><li>用户信息 - <code>/etc/passwd</code></li><li>网络细节 - <code>/etc/network</code></li></ul></li><li>通用的应用信息不存放在 <code>/etc</code> 下</li></ul><h2 id="_7-2-system-logging" tabindex="-1"><a class="header-anchor" href="#_7-2-system-logging"><span>7.2 System Logging</span></a></h2><p>大部分系统程序会将其诊断信息输出到 <code>syslog</code> 服务上。<code>syslog</code> 等待消息输入，根据接受到消息的类型，将其输出到文件、屏幕、用户，或简单忽略。</p><h3 id="_7-2-1-the-system-logger" tabindex="-1"><a class="header-anchor" href="#_7-2-1-the-system-logger"><span>7.2.1 The System Logger</span></a></h3><p><code>rsyslogd</code>：new version of <code>syslogd</code>。在 <code>/var/log</code> 中有很多日志信息，但很多文件不是由系统日志维护的。</p><h3 id="_7-2-2-configuration-files" tabindex="-1"><a class="header-anchor" href="#_7-2-2-configuration-files"><span>7.2.2 Configuration Files</span></a></h3><p><code>rsyslogd</code> 的基本配置文件位于 <code>/etc/rsyslog.conf</code>，其中包含了多种规则，包含：</p><ul><li>selector - how to catch logs</li><li>action - where to send them</li></ul><p>selector 表示记录日志的信息类型，位于左侧；action 表示日志被输出到何处，位于右侧。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">kern.*                  /dev/console</span>
<span class="line">*.info;authpriv.none    /var/log/messages</span>
<span class="line">authpriv.*              /var/log/secure,root</span>
<span class="line">mail.*                  /var/log/maillog</span>
<span class="line">cron.*                  /var/log/cron</span>
<span class="line">*.emerg                 *</span>
<span class="line">local7.*                /var/log/boot.log</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="facility-and-priority" tabindex="-1"><a class="header-anchor" href="#facility-and-priority"><span>Facility and Priority</span></a></h4><p>selector 需要匹配日志消息的 facility 和 priority：</p><ul><li>Facility <ul><li>消息中包含何种信息，比如包含 <code>kern</code>、<code>mail</code> 等</li></ul></li><li>Priority <ul><li>在 facility 和 <code>.</code> 之后</li><li>Order (from lowest to highest): <ul><li>debug</li><li>info</li><li>notice</li><li>warning</li><li>err</li><li>crit</li><li>alert/emerg</li></ul></li><li>使用 <code>.none</code> 的优先级可以除去某个 facility</li></ul></li></ul><h4 id="extended-syntax" tabindex="-1"><a class="header-anchor" href="#extended-syntax"><span>Extended Syntax</span></a></h4><p>rsyslogd 继承了 syslogd 的语法，配置文件的扩展叫做 <em>directives</em>，通常由 <code>$</code> 开头，可以用于载入额外的配置文件。</p><h4 id="troubleshooting" tabindex="-1"><a class="header-anchor" href="#troubleshooting"><span>Troubleshooting</span></a></h4><p>使用 <code>logger</code> 命令可以注入日志。</p><h2 id="_7-3-user-management-files" tabindex="-1"><a class="header-anchor" href="#_7-3-user-management-files"><span>7.3 User Management Files</span></a></h2><p>Unix 系统允许多个独立用户存在。在内核层面，用户被简单地表示为 <em>user ID</em>。为了方便记忆，在用户空间会被表示为 <em>username</em>。</p><h3 id="_7-3-1-the-etc-passwd-file" tabindex="-1"><a class="header-anchor" href="#_7-3-1-the-etc-passwd-file"><span>7.3.1 The /etc/passwd File</span></a></h3><p>明文的 <code>/etc/passwd</code> 将 usernames 和 user IDs 进行映射：</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ cat /etc/passwd</span>
<span class="line">root:x:0:0:root:/root:/bin/bash</span>
<span class="line">daemon:*:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span>
<span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span>
<span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span>
<span class="line">sync:x:4:65534:sync:/bin:/bin/sync</span>
<span class="line">mrdrivingduck:x:1000:1000:,,,:/home/mrdrivingduck:/bin/bash</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每行的内容分别为：</p><ul><li>Username</li><li>加密后的用户密码 <ul><li>密码本身存储在 <em>shadow</em> 文件中 - <code>/etc/shadow</code><ul><li>普通用户没有对该文件的读权限</li><li>密码以加密形式保存在 shadow 文件中 - Unix 密码永远不会明文存储</li></ul></li><li><code>x</code> 表示加密的密码存储在 shadow 文件中</li><li><code>*</code> 表示用户无法登陆</li><li><code></code> 则表示登陆无需密码</li></ul></li><li>user ID (UID)</li><li>group ID (GID)</li><li>用户的 real name</li><li>用户的主目录</li><li>用户的 shell</li></ul><p>该文件中不允许注释和空行。</p><h3 id="_7-3-2-special-users" tabindex="-1"><a class="header-anchor" href="#_7-3-2-special-users"><span>7.3.2 Special Users</span></a></h3><p>superuser：root 的 UID 和 GID 总为 0。有一些用户是没有登陆权限的。<em>nobody</em> 用户是无特权用户，将无法向系统写入任何数据。不能登陆的用户被称作 <em>pseudo-users</em>，系统能够以它们的 UID 启动进程，常用于安全性原因而启动。</p><h3 id="_7-3-3-the-etc-shadow-file" tabindex="-1"><a class="header-anchor" href="#_7-3-3-the-etc-shadow-file"><span>7.3.3 The /etc/shadow File</span></a></h3><h3 id="_7-3-4-manipulating-users-and-passwords" tabindex="-1"><a class="header-anchor" href="#_7-3-4-manipulating-users-and-passwords"><span>7.3.4 Manipulating Users and Passwords</span></a></h3><p>使用 <code>passwd</code> 命令与 <code>/etc/passwd</code> 进行交互，修改用户的密码：</p><ul><li><code>-f</code> 用于改变用户的 real name</li><li><code>-s</code> 用于改变用户的 shell</li></ul><p><code>passwd</code> 是一个 suid-root 程序，只有 root 用户才能修改 <code>/etc/passwd</code>。</p><h3 id="_7-3-5-working-with-groups" tabindex="-1"><a class="header-anchor" href="#_7-3-5-working-with-groups"><span>7.3.5 Working with Groups</span></a></h3><p>Unix 通过 groups 来实现特定用户之间的文件共享，在多用户共享一台主机时相当重要。在 <code>/etc/group</code> 文件中定义了 group ID：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">root:*:0:juser</span>
<span class="line">daemon:*:1:</span>
<span class="line">bin:*:2:</span>
<span class="line">user:*:1000:</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每行的内容为：</p><ul><li>group name</li><li>group password - 很少用到</li><li>group ID - 必须是唯一的，并出现在 <code>/etc/passwd</code> 中的 GID 中</li><li>属于该 group 的可选用户</li></ul><p>Linux 通常为新用户创建一个同名的 group。</p><h2 id="_7-4-getty-and-login" tabindex="-1"><a class="header-anchor" href="#_7-4-getty-and-login"><span>7.4 getty and login</span></a></h2><p><code>getty</code> 是绑定 terminal 并显示登录界面的程序：</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ ps ao args | grep getty</span>
<span class="line">/sbin/agetty --noclear tty1 linux</span>
<span class="line">/sbin/agetty --keep-baud 115200 38400 9600 ttyS0 vt220</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中的数字为波特率，只是为了向后兼容，现在已经很少使用。在输入登录的用户名后，<code>getty</code> 将自身替换为 <code>login</code> 程序。如果密码正确，<code>login</code> 程序再将自身替换为 shell 程序 (通过 <code>exec()</code>)。但目前的登录主要通过：</p><ul><li>图形接口 - <code>gdm</code></li><li>远程 - SSH</li></ul><h2 id="_7-5-setting-the-time" tabindex="-1"><a class="header-anchor" href="#_7-5-setting-the-time"><span>7.5 Setting the Time</span></a></h2><p>内核维护系统时钟。PC 硬件中包含一个电池供电的 <em>real-time clock (RTC)</em>。内核通常在启动时将其时间设置为与 RTC 一致，可以通过 <code>hwclock</code> 命令将目前的系统时间复位为 RTC 硬件时间，也可以将系统的时间设置到 RTC 中。</p><h3 id="_7-5-1-kernel-time-representation-and-time-zones" tabindex="-1"><a class="header-anchor" href="#_7-5-1-kernel-time-representation-and-time-zones"><span>7.5.1 Kernel Time Representation and Time Zones</span></a></h3><p>内核的系统时钟将目前时间表示为 1970.1.1 00:00 到现在的秒数：</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ date +%s</span>
<span class="line">1561984433</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>本地时区由 <code>/etc/localtime</code> 控制。时区文件位于 <code>/usr/share/zoneinfo</code>，里面包含了时区和时区的别名。如果想要手动修改时区：</p><ul><li>要么将 <code>/usr/share/zoneinfo</code> 中的一个文件拷贝到 <code>/etc/localtime</code></li><li>或者使用 Linux 上的时区工具</li></ul><h3 id="_7-5-2-network-time" tabindex="-1"><a class="header-anchor" href="#_7-5-2-network-time"><span>7.5.2 Network Time</span></a></h3><p><em>Network Time Protocol (NTP)</em> 使用远程服务器维护时间：</p><ol><li>找到距离 ISP 最近的 NTP 时间服务器</li><li>将服务器配置在 <code>/etc/ntpd.conf</code> 中</li><li>在启动时运行 <code>dtpdate server</code></li><li>之后运行 <code>ntpd</code></li></ol><h2 id="_7-6-scheduling-recurring-tasks-with-cron" tabindex="-1"><a class="header-anchor" href="#_7-6-scheduling-recurring-tasks-with-cron"><span>7.6 Scheduling Recurring Tasks with cron</span></a></h2><p>Unix cron 服务会以固定频率重复运行程序。由 cron 运行的程序被称为 <em>cron job</em>。通常，可以运行 <code>crontab</code> 命令，在 crontab 文件中加入条目：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">15 09 * * * /home/juser/bin/spmake</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>前五个参数分别为：</p><ul><li>Minute</li><li>Hour</li><li>Day of month</li><li>Month</li><li>Day of week</li></ul><p>其中，<code>*</code> 代表所有的值，任意一个域可以使用 <code>,</code> 分隔多个值。可以将 cron job 编辑在文件中，通过 <code>cron file</code> 命令安装 cron 文件；也可以通过 <code>cron -e</code> 编辑、安装一步到位。</p><h3 id="_7-6-3-the-future-of-cron" tabindex="-1"><a class="header-anchor" href="#_7-6-3-the-future-of-cron"><span>7.6.3 The Future of cron</span></a></h3><p>cron 工具是 Linux 最古老的组件之一。</p><h2 id="_7-7-scheduling-one-time-tasks-with-at" tabindex="-1"><a class="header-anchor" href="#_7-7-scheduling-one-time-tasks-with-at"><span>7.7 Scheduling One-Time Tasks with at</span></a></h2><p>使用 <code>at</code> 服务运行将来某个时刻只执行一次的命令：</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ at 22:30</span>
<span class="line">at&gt; myjob</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>CTRL-D</code> 结束输入 (<code>at</code> 工具使用标准输入读取命令)。<code>atq</code> 用于确认。<code>atrm</code> 用于删除。</p><h2 id="_7-8-understanding-user-ids-and-user-switching" tabindex="-1"><a class="header-anchor" href="#_7-8-understanding-user-ids-and-user-switching"><span>7.8 Understanding User IDs and User Switching</span></a></h2><p>有两种方法修改 user ID：</p><ul><li>setuid executable</li><li>通过 <code>setuid()</code> 家族的系统调用</li></ul><p>内核有一些基本的规则，限制了一个进程能做什么或不能做什么：</p><ul><li>运行于 root (UID == 0) 的进程可以使用 <code>setuid()</code> 变成任何用户的进程</li><li>不运行于 root 的进程对于 <code>setuid()</code> 的使用具有很严格的限制，大部分状况下不行</li><li>任何进程可以执行 setuid 程序，只要具有足够的文件权限</li></ul><h3 id="_7-8-1-process-ownership-effective-uid-real-uid-and-saved-uid" tabindex="-1"><a class="header-anchor" href="#_7-8-1-process-ownership-effective-uid-real-uid-and-saved-uid"><span>7.8.1 Process Ownership, Effective UID, Real UID, and Saved UID</span></a></h3><p>每个进程拥有多个 UID：</p><ul><li>effective UID (euid) - 定义了进程的访问权限</li><li>real UID (ruid) - 标识了谁启动了该进程</li></ul><p>当使用 <code>setuid()</code> 时，内核修改了 euid，但保留了 ruid。创建该进程的用户依然可以发送信号给该进程，或杀死进程，即使进程由其他用户执行。Linux 默认 euid 和 ruid 相同。</p><p><code>ps</code> 等程序默认展示 euid：</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ ps -eo pid,euser,ruser,comm</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>此外，还有 saved user ID 和 file system user ID。</p><p>利用运行在 root 用户的程序漏洞是系统入侵的主要方法。</p><h2 id="_7-9-user-identification-and-authentication" tabindex="-1"><a class="header-anchor" href="#_7-9-user-identification-and-authentication"><span>7.9 User Identification and Authentication</span></a></h2><ul><li>Identification：who users are</li><li>Authentication：prove that they are who they say they are</li><li>Authorization：define and limit what users are allowed to do</li></ul><p>所有的 authentication 发生在用户空间中，因为内核不知道 username。</p><ol><li>进程通过 <code>geteuid()</code> 系统调用向内核询问自己的 euid</li><li>进程打开 <code>/etc/passwd</code> 并读取</li><li>每次读取一行</li><li>将每一行进行分割，找到 user ID</li><li>将 user ID 与内核返回的 ID 进行比较，若相同，则找到了对应的 username 并进行使用</li></ol><h3 id="_7-9-1-using-libraries-for-user-information" tabindex="-1"><a class="header-anchor" href="#_7-9-1-using-libraries-for-user-information"><span>7.9.1 Using Libraries for User Information</span></a></h3><p>在通过 <code>geteuid()</code> 系统调用获得 euid 后，使用标准库中的 <code>getpwuid()</code> 获得 username。关于验证密码，在传统的实现方式中的局限：</p><ul><li>对于加密协议有没系统性的标准</li><li>假设能够访问加密后的密码</li></ul><h2 id="_7-10-pam" tabindex="-1"><a class="header-anchor" href="#_7-10-pam"><span>7.10 PAM</span></a></h2><p>为了使认证更具灵活性，1995 年，Sun Microsystems 提出了新标准：Pluggable Authentication Modules (PAM)，一系列用于认证的共享库。</p><p>由于支持多种认证场景，PAM 部署了大量动态加载的认证模块，每个模块执行特定的功能。PAM 几乎支持了 Linux 系统上需要认证的每一个程序。</p><h3 id="_7-10-1-pam-configuration" tabindex="-1"><a class="header-anchor" href="#_7-10-1-pam-configuration"><span>7.10.1 PAM Configuration</span></a></h3><p>PAM 的配置文件位于 <code>/etc/pam.d</code> 目录下。配置文件中的每一行包含：</p><ul><li>Function Type - 用户程序想要 PAM 执行的功能 <ul><li>auth - 认证用户</li><li>account - 检查用户账号状态 (是否被授权做某事)</li><li>session - 仅在当前会话中执行 sth.</li><li>password - 修改用户的密码或其它证书</li></ul></li><li>Control Argument - PAM 在当前行执行成功或失败后执行的动作 <ul><li>sufficient <ul><li>如果当前行认证成功，则 PAM 不需要再检查其它行</li><li>否则 PAM 需要继续检查其它行</li></ul></li><li>requisite <ul><li>如果当前行认证成功，PAM 还需要检查其它行</li><li>如果当前行认证失败，则总体认证失败</li></ul></li><li>required <ul><li>如果当前行认证成功，PAM 还需要检查其它行</li><li>如果当前行认证失败，PAM 继续检查其它行，但总会返回不成功的认证</li></ul></li></ul></li><li>Module - 该行需要使用的模块 <ul><li>可以在模块名后面带参数</li></ul></li></ul><p>Function Type 和 Module 共同决定了 PAM 的动作</p><h3 id="_7-10-2-notes-on-pam" tabindex="-1"><a class="header-anchor" href="#_7-10-2-notes-on-pam"><span>7.10.2 Notes on PAM</span></a></h3><h3 id="_7-10-3-pam-and-passwords" tabindex="-1"><a class="header-anchor" href="#_7-10-3-pam-and-passwords"><span>7.10.3 PAM and Passwords</span></a></h3><p><code>/etc/login.defs</code> 中保存了 shadow 文件中使用的加密算法，但很少在安装了 PAM 的机器上使用，因为 PAM 的配置文件中包含了这些信息。PAM 从哪里获得密码加密的模式呢？</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ grep password.*unix /etc/pam.d/*</span>
<span class="line">/etc/pam.d/password-auth:password    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtok</span>
<span class="line">/etc/pam.d/password-auth-ac:password    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtok</span>
<span class="line">/etc/pam.d/system-auth:password    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtok</span>
<span class="line">/etc/pam.d/system-auth-ac:password    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtok</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以得知，PAM 使用 SHA-512 来加密密码，但加密只用于设置密码时 (password)，而不是 PAM 认证密码时 (auth)。对于 auth 功能，没有任何的加密参数。<code>pam_unix.so</code> 试图将算法猜出来，直到没有可以尝试的算法。</p>`,104)]))}const r=i(l,[["render",t],["__file","Chapter 7 - System Configuration.html.vue"]]),c=JSON.parse('{"path":"/how-linux-works-notes/Chapter%207%20-%20System%20Configuration.html","title":"Chapter 7 - System Configuration: Logging, System Time, Batch Jobs, and Users","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"7.1 The Structure of /etc","slug":"_7-1-the-structure-of-etc","link":"#_7-1-the-structure-of-etc","children":[]},{"level":2,"title":"7.2 System Logging","slug":"_7-2-system-logging","link":"#_7-2-system-logging","children":[{"level":3,"title":"7.2.1 The System Logger","slug":"_7-2-1-the-system-logger","link":"#_7-2-1-the-system-logger","children":[]},{"level":3,"title":"7.2.2 Configuration Files","slug":"_7-2-2-configuration-files","link":"#_7-2-2-configuration-files","children":[]}]},{"level":2,"title":"7.3 User Management Files","slug":"_7-3-user-management-files","link":"#_7-3-user-management-files","children":[{"level":3,"title":"7.3.1 The /etc/passwd File","slug":"_7-3-1-the-etc-passwd-file","link":"#_7-3-1-the-etc-passwd-file","children":[]},{"level":3,"title":"7.3.2 Special Users","slug":"_7-3-2-special-users","link":"#_7-3-2-special-users","children":[]},{"level":3,"title":"7.3.3 The /etc/shadow File","slug":"_7-3-3-the-etc-shadow-file","link":"#_7-3-3-the-etc-shadow-file","children":[]},{"level":3,"title":"7.3.4 Manipulating Users and Passwords","slug":"_7-3-4-manipulating-users-and-passwords","link":"#_7-3-4-manipulating-users-and-passwords","children":[]},{"level":3,"title":"7.3.5 Working with Groups","slug":"_7-3-5-working-with-groups","link":"#_7-3-5-working-with-groups","children":[]}]},{"level":2,"title":"7.4 getty and login","slug":"_7-4-getty-and-login","link":"#_7-4-getty-and-login","children":[]},{"level":2,"title":"7.5 Setting the Time","slug":"_7-5-setting-the-time","link":"#_7-5-setting-the-time","children":[{"level":3,"title":"7.5.1 Kernel Time Representation and Time Zones","slug":"_7-5-1-kernel-time-representation-and-time-zones","link":"#_7-5-1-kernel-time-representation-and-time-zones","children":[]},{"level":3,"title":"7.5.2 Network Time","slug":"_7-5-2-network-time","link":"#_7-5-2-network-time","children":[]}]},{"level":2,"title":"7.6 Scheduling Recurring Tasks with cron","slug":"_7-6-scheduling-recurring-tasks-with-cron","link":"#_7-6-scheduling-recurring-tasks-with-cron","children":[{"level":3,"title":"7.6.3 The Future of cron","slug":"_7-6-3-the-future-of-cron","link":"#_7-6-3-the-future-of-cron","children":[]}]},{"level":2,"title":"7.7 Scheduling One-Time Tasks with at","slug":"_7-7-scheduling-one-time-tasks-with-at","link":"#_7-7-scheduling-one-time-tasks-with-at","children":[]},{"level":2,"title":"7.8 Understanding User IDs and User Switching","slug":"_7-8-understanding-user-ids-and-user-switching","link":"#_7-8-understanding-user-ids-and-user-switching","children":[{"level":3,"title":"7.8.1 Process Ownership, Effective UID, Real UID, and Saved UID","slug":"_7-8-1-process-ownership-effective-uid-real-uid-and-saved-uid","link":"#_7-8-1-process-ownership-effective-uid-real-uid-and-saved-uid","children":[]}]},{"level":2,"title":"7.9 User Identification and Authentication","slug":"_7-9-user-identification-and-authentication","link":"#_7-9-user-identification-and-authentication","children":[{"level":3,"title":"7.9.1 Using Libraries for User Information","slug":"_7-9-1-using-libraries-for-user-information","link":"#_7-9-1-using-libraries-for-user-information","children":[]}]},{"level":2,"title":"7.10 PAM","slug":"_7-10-pam","link":"#_7-10-pam","children":[{"level":3,"title":"7.10.1 PAM Configuration","slug":"_7-10-1-pam-configuration","link":"#_7-10-1-pam-configuration","children":[]},{"level":3,"title":"7.10.2 Notes on PAM","slug":"_7-10-2-notes-on-pam","link":"#_7-10-2-notes-on-pam","children":[]},{"level":3,"title":"7.10.3 PAM and Passwords","slug":"_7-10-3-pam-and-passwords","link":"#_7-10-3-pam-and-passwords","children":[]}]}],"git":{},"filePathRelative":"how-linux-works-notes/Chapter 7 - System Configuration.md"}');export{r as comp,c as data};
