import{_ as a,c as n,a as s,o as l}from"./app-7eKjwDat.js";const i={};function c(r,e){return l(),n("div",null,e[0]||(e[0]=[s(`<h1 id="chapter-14-服务器" tabindex="-1"><a class="header-anchor" href="#chapter-14-服务器"><span>Chapter 14 - 服务器</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 06 / 07 14:02</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="命令请求的执行过程" tabindex="-1"><a class="header-anchor" href="#命令请求的执行过程"><span>命令请求的执行过程</span></a></h2><h3 id="客户端发送命令请求" tabindex="-1"><a class="header-anchor" href="#客户端发送命令请求"><span>客户端发送命令请求</span></a></h3><p>客户端会将用户输入的命令转换为协议，然后发送给服务器。</p><h3 id="服务器读取命令请求" tabindex="-1"><a class="header-anchor" href="#服务器读取命令请求"><span>服务器读取命令请求</span></a></h3><ol><li>服务器从 socket 中读取协议内容，并保存到输入缓冲区中</li><li>对输入缓冲区中的命令进行协议解析，将参数和参数个数保存到 <code>argv</code> 和 <code>argc</code> 中</li><li>调用相应的命令执行器</li></ol><h3 id="命令执行器" tabindex="-1"><a class="header-anchor" href="#命令执行器"><span>命令执行器</span></a></h3><p>命令执行器首先根据 <code>argv[0]</code> 参数，在命令表中查找参数指定的命令，并保存到客户端状态的 <code>cmd</code> 中。</p><p><code>redisCommand</code> 结构体的主要属性：</p><ul><li><code>char *name</code> 命令名</li><li><code>redisCommnadProc *proc</code> 函数指针，指向命令的实现函数</li><li><code>int arity</code> 命令参数的个数</li><li><code>char *sflags</code> 命令属性</li><li><code>int flags</code> 对上述属性分析出的二进制 flag</li><li><code>long long calls</code> 服务器执行命令的次数</li><li><code>long long milliseconds</code> 服务器执行命令耗费的总时长</li></ul><p>在执行命令前，程序还需要进行一些预备操作：</p><ul><li>检查 <code>cmd</code> 指针是否为 <code>NULL</code> (说明找不到命令的实现)</li><li>检查参数个数 <code>arity</code> 和 <code>argc</code> 是否一致</li><li>检查客户端是否经过了身份验证</li><li>检查服务器的内存占用情况，必要情况下，对内存进行回收</li><li>检查服务器是否正在进行数据载入、阻塞、事务等过程，一些命令不允许被执行</li></ul><p>接下来，调用命令的实现函数：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line">client<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span><span class="token function">proc</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>命令的回复将会被保存在 <code>client</code> 结构的输出缓冲区中。</p><p>执行完命令实现函数后，服务器还要执行一些后续的动作：</p><ul><li>添加日志</li><li>统计命令的执行次数与时长</li><li>AOF 持久化</li><li>如果有从服务器，则刚执行的命令将传播给所有从服务器</li></ul><p>之后，服务器将命令回复以协议的形式发送给客户端，客户端对协议进行解析后，向用户展示结果。</p><hr><h2 id="servercron-函数" tabindex="-1"><a class="header-anchor" href="#servercron-函数"><span>serverCron 函数</span></a></h2><p>这个函数默认每 100ms 执行一次，主要是对服务器的资源进行管理，保持服务器自身的良好运转。</p><h3 id="更新服务器的时间缓存" tabindex="-1"><a class="header-anchor" href="#更新服务器的时间缓存"><span>更新服务器的时间缓存</span></a></h3><p>为了减少为获取时间而进行系统调用，服务器状态中缓存了时间，精度不高。</p><h3 id="更新-lru-时钟" tabindex="-1"><a class="header-anchor" href="#更新-lru-时钟"><span>更新 LRU 时钟</span></a></h3><p>服务器状态中时间缓存的一种，服务器的 LRU 时钟可用于计算对象或客户端的空闲时间。</p><h3 id="更新服务器每秒执行的命令次数" tabindex="-1"><a class="header-anchor" href="#更新服务器每秒执行的命令次数"><span>更新服务器每秒执行的命令次数</span></a></h3><p>服务器状态中保存了上一次抽样时，服务器的时间以及已执行的命令数量。下一次抽样时，根据两次抽样的时间差、命令数量差，取得这期间每毫秒执行的命令数量，并缓存到一个环形数组中。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line">    <span class="token keyword">long</span> <span class="token keyword">long</span> ops_sec_last_sample_time<span class="token punctuation">;</span> <span class="token comment">// 上一次抽样的时间</span></span>
<span class="line">    <span class="token keyword">long</span> <span class="token keyword">long</span> ops_sec_last_sample_ops<span class="token punctuation">;</span> <span class="token comment">// 上一次抽样时服务器已执行命令的数量</span></span>
<span class="line">    <span class="token keyword">long</span> <span class="token keyword">long</span> ops_sec_samples<span class="token punctuation">[</span>REDIS_OPS_SEC_SAMPLES<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 抽样结果环形数组</span></span>
<span class="line">    <span class="token keyword">int</span> ops_sec_index<span class="token punctuation">;</span> <span class="token comment">// 数组当前索引</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="更新服务器的内存峰值" tabindex="-1"><a class="header-anchor" href="#更新服务器的内存峰值"><span>更新服务器的内存峰值</span></a></h3><p>如果当前服务器内存使用量大于内存峰值，则更新这个属性。</p><h3 id="处理-sigterm-信号" tabindex="-1"><a class="header-anchor" href="#处理-sigterm-信号"><span>处理 SIGTERM 信号</span></a></h3><p>Redis 启动后会为 SIGTERM 信号注册一个处理函数，在收到该信号时，打开服务器状态的 <code>shutdown_asap</code> 标志。在 <code>serverCron</code> 函数中，会对这个标志进行检查，决定是否关闭服务器。在关闭服务器之前，服务器会先进行持久化操作。</p><h3 id="管理客户端资源" tabindex="-1"><a class="header-anchor" href="#管理客户端资源"><span>管理客户端资源</span></a></h3><ul><li>客户端与服务器之间的连接已超时 (没有互动)，则释放客户端</li><li>如果客户端的输入缓冲区超过一定的长度，则释放并重新分配一个默认大小的输入缓冲区</li></ul><h3 id="管理数据库资源" tabindex="-1"><a class="header-anchor" href="#管理数据库资源"><span>管理数据库资源</span></a></h3><p>对服务器中的 <strong>一部分</strong> 数据库进行检查，删除其中的过期 key。</p><h3 id="执行被延迟的-bgwriteaof" tabindex="-1"><a class="header-anchor" href="#执行被延迟的-bgwriteaof"><span>执行被延迟的 <code>BGWRITEAOF</code></span></a></h3><p>如果这个标志为 1，且 <code>BGSAVE</code> 和 <code>BGREWRITEAOF</code> 命令都没有在执行，那么执行这个命令。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line">    <span class="token keyword">int</span> aof_rewrite_scheduled<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="检查持久化操作的运行状态" tabindex="-1"><a class="header-anchor" href="#检查持久化操作的运行状态"><span>检查持久化操作的运行状态</span></a></h3><p>检查自动保存或 AOF 重写的条件是否满足，如果满足且服务器没有正在进行持久化操作，则引发新的持久化操作。</p><h3 id="将-aof-缓冲区中的内容写入-aof-文件。" tabindex="-1"><a class="header-anchor" href="#将-aof-缓冲区中的内容写入-aof-文件。"><span>将 AOF 缓冲区中的内容写入 AOF 文件。</span></a></h3><h3 id="关闭异步客户端" tabindex="-1"><a class="header-anchor" href="#关闭异步客户端"><span>关闭异步客户端</span></a></h3><h3 id="增加-cronloop-计数器的值" tabindex="-1"><a class="header-anchor" href="#增加-cronloop-计数器的值"><span>增加 cronloop 计数器的值</span></a></h3><p>在服务器状态中记录了 <code>serverCron</code> 函数的执行次数。</p><hr><h2 id="服务器初始化" tabindex="-1"><a class="header-anchor" href="#服务器初始化"><span>服务器初始化</span></a></h2><h3 id="初始化服务器状态结构" tabindex="-1"><a class="header-anchor" href="#初始化服务器状态结构"><span>初始化服务器状态结构</span></a></h3><p>初始化服务器的第一步 - 创建一个 <code>struct redisServer</code> 作为服务器的状态：</p><ul><li>设置服务器的运行 ID</li><li>设置服务器的默认运行频率</li><li>设置服务器的默认配置文件路径</li><li>设置服务器的运行架构</li><li>设置服务器的默认端口号</li><li>设置服务器的默认 RDB / AOF 持久化条件</li><li>初始化服务器的 LRU 时钟</li><li>创建命令表</li></ul><h3 id="载入配置选项" tabindex="-1"><a class="header-anchor" href="#载入配置选项"><span>载入配置选项</span></a></h3><p>由用户指定的覆盖默认配置的选项，对 <code>struct redisServer</code> 中已经初始化的默认值进行修改。</p><h3 id="初始化服务器数据结构" tabindex="-1"><a class="header-anchor" href="#初始化服务器数据结构"><span>初始化服务器数据结构</span></a></h3><p>在之前的初始化过程中，程序只创建了 <strong>命令表</strong>，其它的表不能提前创建，否则将无法应用用户指定的配置。在这一步中，用户自定义的配置已经在 <code>struct redisServer</code> 中了，此时可以进行数据结构的初始化：</p><ul><li>初始化 <code>client</code> 链表</li><li>初始化 <code>db</code> 数组 (所有的数据库)</li><li>初始化保存频道订阅信息的字典、链表</li><li>初始化执行 Lua 脚本的 Lua 环境</li><li>初始化保存慢查询日志的属性</li></ul><blockquote><p>实际上的主要工作就是用 <code>struct redisServer</code> 中的指针去开辟数据结构的内存，并初始化。</p></blockquote><p>另外，做好与网络或磁盘 I/O 相关的一切准备：</p><ul><li>为服务器设置信号处理器 (比如 <code>SIGTERM</code>)</li><li>创建共享的对象 (类比 Java 中的 Integer Cache)</li><li>打开服务器的监听端口，为 socket 关联 connect 处理器</li><li>为 <code>serverCron</code> 函数创建时间事件</li><li>如果 AOF 持久化功能开启，那么打开现有的 AOF 文件；否则新建并打开一个 AOF 文件</li><li>初始化服务器后台的 I/O 模块</li></ul><h3 id="还原数据库状态" tabindex="-1"><a class="header-anchor" href="#还原数据库状态"><span>还原数据库状态</span></a></h3><p>载入 AOF 或 RDB 文件来还原数据库的状态，并在控制台上打印还原数据库耗费的时长。</p><h3 id="执行时间循环" tabindex="-1"><a class="header-anchor" href="#执行时间循环"><span>执行时间循环</span></a></h3><p>进入到服务器的事件循环中，初始化结束。接下来，服务器可以接受客户端的连接请求并执行命令了。</p>`,66)]))}const t=a(i,[["render",c],["__file","Chapter 14 - 服务器.html.vue"]]),o=JSON.parse('{"path":"/redis-implementation-notes/Part%202%20-%20%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/Chapter%2014%20-%20%E6%9C%8D%E5%8A%A1%E5%99%A8.html","title":"Chapter 14 - 服务器","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"命令请求的执行过程","slug":"命令请求的执行过程","link":"#命令请求的执行过程","children":[{"level":3,"title":"客户端发送命令请求","slug":"客户端发送命令请求","link":"#客户端发送命令请求","children":[]},{"level":3,"title":"服务器读取命令请求","slug":"服务器读取命令请求","link":"#服务器读取命令请求","children":[]},{"level":3,"title":"命令执行器","slug":"命令执行器","link":"#命令执行器","children":[]}]},{"level":2,"title":"serverCron 函数","slug":"servercron-函数","link":"#servercron-函数","children":[{"level":3,"title":"更新服务器的时间缓存","slug":"更新服务器的时间缓存","link":"#更新服务器的时间缓存","children":[]},{"level":3,"title":"更新 LRU 时钟","slug":"更新-lru-时钟","link":"#更新-lru-时钟","children":[]},{"level":3,"title":"更新服务器每秒执行的命令次数","slug":"更新服务器每秒执行的命令次数","link":"#更新服务器每秒执行的命令次数","children":[]},{"level":3,"title":"更新服务器的内存峰值","slug":"更新服务器的内存峰值","link":"#更新服务器的内存峰值","children":[]},{"level":3,"title":"处理 SIGTERM 信号","slug":"处理-sigterm-信号","link":"#处理-sigterm-信号","children":[]},{"level":3,"title":"管理客户端资源","slug":"管理客户端资源","link":"#管理客户端资源","children":[]},{"level":3,"title":"管理数据库资源","slug":"管理数据库资源","link":"#管理数据库资源","children":[]},{"level":3,"title":"执行被延迟的 BGWRITEAOF","slug":"执行被延迟的-bgwriteaof","link":"#执行被延迟的-bgwriteaof","children":[]},{"level":3,"title":"检查持久化操作的运行状态","slug":"检查持久化操作的运行状态","link":"#检查持久化操作的运行状态","children":[]},{"level":3,"title":"将 AOF 缓冲区中的内容写入 AOF 文件。","slug":"将-aof-缓冲区中的内容写入-aof-文件。","link":"#将-aof-缓冲区中的内容写入-aof-文件。","children":[]},{"level":3,"title":"关闭异步客户端","slug":"关闭异步客户端","link":"#关闭异步客户端","children":[]},{"level":3,"title":"增加 cronloop 计数器的值","slug":"增加-cronloop-计数器的值","link":"#增加-cronloop-计数器的值","children":[]}]},{"level":2,"title":"服务器初始化","slug":"服务器初始化","link":"#服务器初始化","children":[{"level":3,"title":"初始化服务器状态结构","slug":"初始化服务器状态结构","link":"#初始化服务器状态结构","children":[]},{"level":3,"title":"载入配置选项","slug":"载入配置选项","link":"#载入配置选项","children":[]},{"level":3,"title":"初始化服务器数据结构","slug":"初始化服务器数据结构","link":"#初始化服务器数据结构","children":[]},{"level":3,"title":"还原数据库状态","slug":"还原数据库状态","link":"#还原数据库状态","children":[]},{"level":3,"title":"执行时间循环","slug":"执行时间循环","link":"#执行时间循环","children":[]}]}],"git":{},"filePathRelative":"redis-implementation-notes/Part 2 - 单机数据库的实现/Chapter 14 - 服务器.md"}');export{t as comp,o as data};
