import{_ as r,c as i,a as o,o as l}from"./app-7eKjwDat.js";const n="/blog/assets/docker-architecture-D9qMe0dG.png",c={};function a(t,e){return l(),i("div",null,e[0]||(e[0]=[o('<h1 id="docker-libcontainer" tabindex="-1"><a class="header-anchor" href="#docker-libcontainer"><span>Docker - Libcontainer</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 09 / 20 0:34</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="docker-architecture" tabindex="-1"><a class="header-anchor" href="#docker-architecture"><span>Docker Architecture</span></a></h2><p>Docker 使用了传统的 C-S 架构模式。Docker 的后端是松耦合的：</p><img src="'+n+'" alt="docker-architecture" style="zoom:50%;"><p>Docker daemon 是 Docker 架构中的主要用户接口，提供了一个 API Server 来接收 Docker client 的请求，然后根据请求分发到不同的模块执行相应的动作。</p><h3 id="docker-daemon" tabindex="-1"><a class="header-anchor" href="#docker-daemon"><span>Docker Daemon</span></a></h3><p>Docker 最核心的后台进程，负责响应来自 Docker client 的请求，然后将这些请求翻译为相应的系统调用，完成容器管理操作。其启动过程相当复杂，主要需要进行的工作包含：</p><ul><li>初始化 Docker 容器的配置信息</li><li>检测系统支持及用户权限</li><li>配置 daemon 的工作路径</li><li>配置容器所需要的文件环境</li><li>创建 daemon 网络</li><li>初始化 execdriver</li><li>创建 daemon 实例</li><li>恢复已有的 Docker 容器</li></ul><h3 id="docker-client" tabindex="-1"><a class="header-anchor" href="#docker-client"><span>Docker Client</span></a></h3><p>Docker 客户端是一个泛称，不止是 Docker 官方的 CLI 工具，同时泛指所有遵循 Docker API 协议的客户端。以 Docker CLI 为例，客户端需要进行的工作有：</p><ul><li>解析命令 flag</li><li>创建一个 client 实例</li><li>找到命令对应的执行函数 (通过命令名 + 反射机制)，向 daemon 发起请求，附带解析出的参数</li><li>读取来自 daemon 的运行结果</li></ul><h3 id="drivers" tabindex="-1"><a class="header-anchor" href="#drivers"><span>Drivers</span></a></h3><p>Docker 将底层系统调用屏蔽后，封装为统一的驱动方便调用者使用：</p><ul><li>Execdriver - 对 Linux namespaces、cgroups 等系统调用进行了二次封装，默认的实现是 Docker 官方实现的 libcontainer 库</li><li>Volumedriver - 是 volume 数据卷存储操作的最终执行者，负责 volume 的增删改查</li><li>Graphdriver - 所有与容器镜像相关操作的最终执行者，记录镜像层之间的关系，已经支持的 graphdriver 包含： <ul><li>aufs</li><li>btrfs</li><li>zfs</li><li>devicemapper</li><li>overlay</li><li>vfs</li></ul></li></ul><h3 id="network" tabindex="-1"><a class="header-anchor" href="#network"><span>Network</span></a></h3><p>由单独的 libnetwork 库实现，负责创建容器通信所需网络、容器的 network namespace、虚拟网卡、IP、端口等。</p><h2 id="libcontainer" tabindex="-1"><a class="header-anchor" href="#libcontainer"><span>Libcontainer</span></a></h2><p>容器是一个与宿主机 <strong>共享内核</strong> 但与系统中其它进程资源相隔离的执行环境。Docker 通过对 namespace、cgroups、capabilities 以及文件系统的管理和分配来隔离出一个容器运行环境。</p><p>在客户端接收到 <code>docker run</code> 命令后，客户端通过解析命令行参数，向 Docker daemon 的 API server 发送请求。Docker daemon 接收到请求后，利用请求中的参数实例化一个 container 对象，创建容器，并响应客户端。</p><p>客户端接收到响应后，会再次发送 <code>start</code> 的请求，这一次，容器才会被真正启动。API server 接收到 <code>start</code> 命令后，会告诉 Docker daemon 启动容器。此时，创建容器需要的 <strong>配置信息</strong> 已经在上一步容器创建的过程中赋值完毕，Docker daemon 将调用 <code>daemon.ContainerStart()</code> 启动容器。接下来的任务就交给 execdriver 乃至 libcontainer 负责命令 OS 启动容器。Docker daemon 将为 execdriver 提供三个参数：</p><ul><li><code>commandv</code> - 该容器需要的所有配置信息</li><li><code>pipes</code> - 用于将容器的 STDIN、STDOUT、STDERR 与 daemon 相连接 (相当于先 <code>pipe()</code> 再 <code>fork()</code>)</li><li><code>startCallback()</code> - 回调函数</li></ul><p>接下来的工作将会在 execdriver 中展开。</p><h3 id="创建逻辑容器-container" tabindex="-1"><a class="header-anchor" href="#创建逻辑容器-container"><span>创建逻辑容器 Container</span></a></h3><p>Execdriver 接收到容器启动的配置信息后，会首先加载一个预定义的模板配置 (里面都是容器启动的默认值)，然后向这个模板中依次填充 daemon 传来的配置信息 (其中包含了容器的 namespace、cgroups，以及未来容器将要运行的进程信息和参数)。根据这个配置，execdriver 将会创建一个 <strong>逻辑容器对象</strong> Container。</p><blockquote><p>创建逻辑容器的过程需要使用到 <strong>工厂模式</strong>。对于 Docker daemon 来说，只需要提供一套配置信息就够了；而对于 libcontainer 来说，由于其封装了不同 OS 的底层细节，因此需要根据不同的平台创建出完全不同的逻辑容器对象。</p></blockquote><p>创建逻辑容器对象的具体操作：</p><ul><li>验证容器运行的根目录、容器 ID、容器配置的合法性</li><li>验证容器 ID 不会发生冲突</li><li>在容器运行的根目录下创建容器工作目录</li><li>返回一个逻辑容器对象 (包含容器启动后需要的所有配置、容器 ID、容器工作目录)</li></ul><h3 id="启动逻辑容器-container" tabindex="-1"><a class="header-anchor" href="#启动逻辑容器-container"><span>启动逻辑容器 Container</span></a></h3><p>在这一阶段将会创建两个 Process 实例。一个名为 Process，是将要在容器内运行的进程，其创建参数就是 Docker daemon 传入的参数 (进程启动命令、参数、环境变量、输入流、输出流、错误流)；另一个名为 ParentProcess，负责 <strong>从容器外部</strong> 处理物理容器的启动工作。</p><p>ParentProcess 的创建位于这一步中：</p><ul><li>创建一个管道，用于与未来容器内的进程进行通信 (在容器内网卡初始化完成之前)</li><li>构造用于启动容器内 init 进程的 cmd 对象，为 cmd 对象从 Container 对象中获取启动命令、参数等信息</li><li>为 cmd 对象添加环境变量 <code>LIBCONTAINER_INITTYPE=standard</code> 告诉容器进程当前执行 <strong>创建</strong> 操作 (与 <code>docker exec</code> 区别)</li><li>将容器需要的 namespace 添加到 cmd 对象的 <code>Cloneflags</code> 中</li><li>将 Container 对象中的容器配置与 Process 的 EntryPoint 信息合并，加入到 ParentProcess 中</li></ul><p>接下来逻辑容器开始启动物理容器。</p><h3 id="用逻辑容器创建物理容器" tabindex="-1"><a class="header-anchor" href="#用逻辑容器创建物理容器"><span>用逻辑容器创建物理容器</span></a></h3><ul><li>使用上述 cmd 对象创建一个新进程，并为其设置 namespace</li><li>把容器进程的 PID 加入到 cgroup 中管理，至此隔离环境初步创建完成</li><li>创建容器内部的网络设备 <code>lo</code> 和 <code>veth</code></li><li>ParentProcess 通过管道发送容器配置到容器内进程中</li><li>ParentProcess 通过管道等待容器内进程初始化完毕</li></ul><p>也就是说，ParentProcess 基于 cmd 对象启动了一个子进程作为容器内的初始进程。之后，ParentProcess 通过管道来指引容器内进程的初始化过程。即，它首先需要与这个容器进程隔离开，然后在容器外部对这个进程进行管理和维护。</p><p>在容器内部，子进程自行完成如下初始化工作：</p><ul><li>获得与 ParentProcess 相连的管道描述符</li><li>通过管道获取 ParentProcess 传来的容器配置 (namespace、网络等)</li><li>从容器配置信息中获取并设置容器的环境变量</li><li>设置容器自身的 namespace</li><li>初始化网络设备 (网络设备初始化完成之前只能通过管道通信)</li><li>设置路由</li><li>创建 mount namespace</li><li>在 mount namespace 中设置挂载点并挂载 rootfs 和文件设备，切换进程的 <code>root</code> 到 rootfs 的根路径</li><li>写入 hostname 等信息</li><li>比较父进程 ID 是否发生改变</li><li>最终使用 <code>execve()</code> 执行容器配置中的命令和参数 <ul><li><code>Args[0]</code> 对应 EntryPoint</li><li><code>Args[1,2,3]</code> 对应指令后的参数</li></ul></li></ul><h2 id="docker-daemon-与容器之间的通信方式" tabindex="-1"><a class="header-anchor" href="#docker-daemon-与容器之间的通信方式"><span>Docker Daemon 与容器之间的通信方式</span></a></h2><p>有如下几种可选方式：</p><ul><li>通过 signal - 因为 namespace 使得信号操作变得复杂</li><li>对内存进行轮询访问 - 效率低下</li><li>Socket 通信 - 容器初始状态下网络栈也是隔离的，无法通信</li><li>文件和文件描述符 (管道)</li></ul><p>首先由 ParentProcess 创建一对管道，然后 clone 出子进程，子进程默认打开了这个管道描述符。ParentProcess 将容器配置等信息发送到子进程后，关闭了自己这一端的发送管道，然后等待子进程完成初始化后发送 EOF 关闭相反方向的管道。</p><hr>',46)]))}const s=r(c,[["render",a],["__file","Docker Libcontainer.html.vue"]]),p=JSON.parse('{"path":"/notes/Docker/Docker%20Libcontainer.html","title":"Docker - Libcontainer","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Docker Architecture","slug":"docker-architecture","link":"#docker-architecture","children":[{"level":3,"title":"Docker Daemon","slug":"docker-daemon","link":"#docker-daemon","children":[]},{"level":3,"title":"Docker Client","slug":"docker-client","link":"#docker-client","children":[]},{"level":3,"title":"Drivers","slug":"drivers","link":"#drivers","children":[]},{"level":3,"title":"Network","slug":"network","link":"#network","children":[]}]},{"level":2,"title":"Libcontainer","slug":"libcontainer","link":"#libcontainer","children":[{"level":3,"title":"创建逻辑容器 Container","slug":"创建逻辑容器-container","link":"#创建逻辑容器-container","children":[]},{"level":3,"title":"启动逻辑容器 Container","slug":"启动逻辑容器-container","link":"#启动逻辑容器-container","children":[]},{"level":3,"title":"用逻辑容器创建物理容器","slug":"用逻辑容器创建物理容器","link":"#用逻辑容器创建物理容器","children":[]}]},{"level":2,"title":"Docker Daemon 与容器之间的通信方式","slug":"docker-daemon-与容器之间的通信方式","link":"#docker-daemon-与容器之间的通信方式","children":[]}],"git":{},"filePathRelative":"notes/Docker/Docker Libcontainer.md"}');export{s as comp,p as data};
