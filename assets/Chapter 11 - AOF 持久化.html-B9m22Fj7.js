import{_ as a,c as n,a as s,o as l}from"./app-7eKjwDat.js";const i={};function t(p,e){return l(),n("div",null,e[0]||(e[0]=[s(`<h1 id="chapter-11-aof-持久化" tabindex="-1"><a class="header-anchor" href="#chapter-11-aof-持久化"><span>Chapter 11 - AOF 持久化</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 06 / 05 15:50</p><p>Nanjing, Jiangsu, China</p><hr><p>AOF (Append Only File) 通过保存 Redis 服务器所执行的写命令来记录数据库状态。在服务器启动时，可以直接载入 AOF 文件中保存的命令，还原服务器关闭之前的数据库状态。</p><hr><h2 id="implementation-of-aof" tabindex="-1"><a class="header-anchor" href="#implementation-of-aof"><span>Implementation of AOF</span></a></h2><p>AOF 持久化功能由三个步骤实现：</p><ul><li>命令追加</li><li>文件写入</li><li>文件同步</li></ul><h3 id="命令追加" tabindex="-1"><a class="header-anchor" href="#命令追加"><span>命令追加</span></a></h3><p>服务器执行完一个写命令之后，会按照 AOF 的格式把被执行的命令 append 到服务器中的 <code>aof_buf</code> 缓冲区中。这个缓冲区被维护在服务器状态中：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"></span>
<span class="line">    sds aof_buf<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="文件写入与同步" tabindex="-1"><a class="header-anchor" href="#文件写入与同步"><span>文件写入与同步</span></a></h3><p>Redis 的服务器进程是一个 <em>事件循环</em>，在每一轮循环中，主要干了三件事情：</p><ul><li>处理文件事件 (接收客户端命令并发送回复)</li><li>处理时间事件 (周期性定时事件)</li><li>刷新 AOF</li></ul><p>刷新 AOF 的行为有三种 (默认使用 everysec，可以通过配置修改)：</p><ul><li>always - 将 AOF 缓冲区中的所有内容 <strong>写入</strong> 并 <strong>同步</strong> 到 AOF 文件</li><li>everysec - 将 AOF 缓冲区中的所有内容 <strong>写入</strong> AOF 文件，如果距离上次同步超过 1s，则 <strong>同步</strong> AOF 文件</li><li>no - 将 AOF 缓冲区中的所有内容 <strong>写入</strong> AOF 文件，但 <strong>不同步</strong></li></ul><blockquote><p>文件的写入和同步有何区别？</p><p>为加快对文件的读写，OS 通常会在内存中为文件开辟高速缓冲。当缓冲被填满，或超过指定时限后，才将缓冲区的内容真正同步到磁盘上。效率的提升会带来安全问题 (如果计算机发生停机，内存中还未同步到磁盘上的数据将丢失)。OS 提供 <code>fsync</code> 和 <code>fdatasync</code> 两个同步的函数，可以强制立刻将缓冲区中的数据写入到硬盘里。</p></blockquote><p>以上三种 AOF 行为：</p><ul><li>always - 性能最差，但同时也是最安全的</li><li>everysec - 是性能与安全性的折衷，最多只会丢失一秒钟内的命令</li><li>no - 由 OS 控制何时同步，所以性能最好；但该模式的 <strong>单次同步时长</strong> 最长；若发生故障，将丢失从上一次同步开始的所有数据</li></ul><h3 id="aof-文件载入与还原" tabindex="-1"><a class="header-anchor" href="#aof-文件载入与还原"><span>AOF 文件载入与还原</span></a></h3><p>Redis 会创建一个不带网络连接的伪客户端，然后依次执行 AOF 文件中的命令，就能够恢复数据库的状态。</p><hr><h2 id="aof-rewrite" tabindex="-1"><a class="header-anchor" href="#aof-rewrite"><span>AOF Rewrite</span></a></h2><p>由于 AOF 是 append only 的，那么文件中的内容必然会越来越多。Redis 能够创建一个新的 AOF 文件，并在其中删除冗余命令，同时保持数据库状态不变，然后原子地替换旧的 AOF 文件。</p><p>从原理上来说，读取某个时刻的数据库状态，就能够替代之前一切对于数据库进行写操作的命令。在重写之后，AOF 文件中只包含还原当前数据库状态所必须的命令。因此，只需要使用 <code>SADD</code> 或 <code>RPUSH</code> 记录数据库的状态，就能压缩 AOF 文件。</p><p>在重写期间必然会产生大量的写入操作。为了不阻塞服务器主进程，AOF 重写应当由子进程在后台完成：</p><ul><li>子进程 AOF 重写期间，服务器主进程可以继续接收请求命令</li><li>子进程带有服务器主进程的 <strong>数据副本</strong>，因此，在子进程写入数据期间，数据不会受到主进程的影响</li></ul><p>仅剩的一个问题是，子进程在进行 AOF 重写期间，服务器主进程执行的命令没有被记录。为了解决这个问题，Redis 设置了一个 AOF 重写缓冲区，这个缓冲区只有在 AOF 重写期间才会被启用。在 AOF 重写期间，服务器主进程每执行一条命令，同时也需要在 AOF 重写缓冲区中记录。</p><p>当子进程完成 AOF 重写后，会向主进程发送一个信号。在主进程的信号处理函数中：</p><ol><li>将 AOF 重写缓冲区中的内容加入到新的 AOF 文件中</li><li>原子地将新的 AOF 文件覆盖现有的 AOF 文件</li></ol><p>整个 AOF 重写的过程中，只有在执行这个信号处理函数时，服务器主进程会被阻塞。使 AOF 重写对服务器性能造成的影响降到了最低。</p><blockquote><p>怎么和 JVM 的 GC 过程有些类似呢...</p></blockquote>`,34)]))}const r=a(i,[["render",t],["__file","Chapter 11 - AOF 持久化.html.vue"]]),c=JSON.parse('{"path":"/redis-implementation-notes/Part%202%20-%20%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/Chapter%2011%20-%20AOF%20%E6%8C%81%E4%B9%85%E5%8C%96.html","title":"Chapter 11 - AOF 持久化","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Implementation of AOF","slug":"implementation-of-aof","link":"#implementation-of-aof","children":[{"level":3,"title":"命令追加","slug":"命令追加","link":"#命令追加","children":[]},{"level":3,"title":"文件写入与同步","slug":"文件写入与同步","link":"#文件写入与同步","children":[]},{"level":3,"title":"AOF 文件载入与还原","slug":"aof-文件载入与还原","link":"#aof-文件载入与还原","children":[]}]},{"level":2,"title":"AOF Rewrite","slug":"aof-rewrite","link":"#aof-rewrite","children":[]}],"git":{},"filePathRelative":"redis-implementation-notes/Part 2 - 单机数据库的实现/Chapter 11 - AOF 持久化.md"}');export{r as comp,c as data};
