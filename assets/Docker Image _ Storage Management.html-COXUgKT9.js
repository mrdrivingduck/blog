import{_ as n,c as s,a as i,o as l}from"./app-BeHGwf2X.js";const a="/blog/assets/union-mount-6LvQXF3q.png",o={};function c(d,e){return l(),s("div",null,e[0]||(e[0]=[i('<h1 id="docker-image-storage-management" tabindex="-1"><a class="header-anchor" href="#docker-image-storage-management"><span>Docker - Image &amp; Storage Management</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 09 / 21 17:46</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="docker-镜像管理" tabindex="-1"><a class="header-anchor" href="#docker-镜像管理"><span>Docker 镜像管理</span></a></h2><p>Docker 镜像是一个只读版的 Docker 容器模板，含有启动 Docker 容器所需的文件结构和内容，是 Docker 容器的静态视角。</p><h3 id="rootfs" tabindex="-1"><a class="header-anchor" href="#rootfs"><span>rootfs</span></a></h3><p>rootfs 是 Docker 容器启动时，内部进程可见的文件系统，也就是 Docker 容器的根目录。通常包含一个 OS 运行所需的文件系统，比如 <code>/bin</code>、<code>/lib</code>、<code>/usr</code> 等。</p><p>传统 Linux 内核启动时，会挂载一个只读的 rootfs，在系统检测其完整性后，再将其切换为可读写模式。在 Docker 中，Docker daemon 为 Docker 容器挂载 rootfs 时，也会将其设置为只读模式。挂载完毕后，利用 <em>联合挂载 (union mount)</em> 技术在 rootfs 的挂载点上再挂载一个空的读写文件系统。当 Docker 容器运行过程中，文件系统发生变化时，发生变化的内容将会写到读写文件系统，并隐藏只读文件系统中的旧版本文件。</p><h3 id="docker-镜像的特点" tabindex="-1"><a class="header-anchor" href="#docker-镜像的特点"><span>Docker 镜像的特点</span></a></h3><ul><li>分层 <ul><li>修改容器中的文件时，只对最上层读写文件系统进行变动，不覆盖下层已有文件系统的内容</li><li><code>docker commit</code> 提交修改后的文件系统时，只保存读写文件系统中的被更新过的文件</li></ul></li><li>写时复制 <ul><li>只有对只读文件系统中的文件修改时，才将其复制到读写文件系统中，并应用修改</li></ul></li><li>内容寻址 <ul><li>对镜像层的内容计算校验和，生成一个内容 hash 作为镜像层 (文件系统) 的唯一标志</li></ul></li><li>联合挂载 <ul><li>联合挂载技术可以在 <strong>一个挂载点</strong> 同时挂载多个文件系统，多个文件系统中的目录将被整合</li></ul></li></ul><img src="'+a+`" alt="union-mount" style="zoom:50%;"><h3 id="镜像构建过程" tabindex="-1"><a class="header-anchor" href="#镜像构建过程"><span>镜像构建过程</span></a></h3><p>如果使用 <code>docker commit</code> 命令 - 只提交容器镜像发生了变更的部分 (即读写文件系统)：</p><ol><li>确定是否暂停容器运行</li><li>将容器的 <strong>可读写层</strong> 打包</li><li>在层存储中注册打包后的可读写层 (也就是带有差异的文件集合)</li><li>更新镜像历史信息，在镜像存储中创建新的镜像，记录元数据</li><li>给镜像添加 tag 信息 (如果指定)</li></ol><p>如果使用 Dockerfile + <code>docker build</code> 命令构建镜像：</p><ol><li>Docker client 在本地准备好构建上下文，然后将上下文信息发送到 Docker server</li><li>Docker server 创建一个临时目录，将上下文中的文件系统解压到这个目录下</li><li>读取并解析 Dockerfile，遍历指令，分发到不同的模块执行</li><li>为每条指令生成一个临时容器，执行一条指令，就使用 <code>commit</code> 生成一个镜像层</li><li>Dockerfile 中所有指令对应的层的集合，就是 build 的结果</li><li>如果指定了 tag 参数，那么给镜像打上对应的 tag</li></ol><hr><h2 id="docker-存储管理" tabindex="-1"><a class="header-anchor" href="#docker-存储管理"><span>Docker 存储管理</span></a></h2><h3 id="docker-镜像元数据管理" tabindex="-1"><a class="header-anchor" href="#docker-镜像元数据管理"><span>Docker 镜像元数据管理</span></a></h3><p>Docker 镜像在设计上将 <strong>元数据</strong> 与 <strong>文件</strong> 的存储完全隔离。</p><h4 id="repository-元数据" tabindex="-1"><a class="header-anchor" href="#repository-元数据"><span>Repository 元数据</span></a></h4><p>Repository 是具有某个功能的 Docker 镜像的 <strong>所有迭代版本</strong> 构成的镜像库。 其元数据包含所有 repository 的名字及其名下所有版本镜像的名字 + tag (比如 <code>ubuntu:20.04</code>)，以及该版本镜像相应的镜像 ID (目前 Docker 使用 SHA256 来计算镜像 ID)。这些元数据用于管理 repository 与镜像 ID 的映射关系。</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ sudo cat /var/lib/docker/image/overlay2/repositories.json | python -mjson.tool</span>
<span class="line">{</span>
<span class="line">    &quot;Repositories&quot;: {</span>
<span class="line">        &quot;hello-world&quot;: {</span>
<span class="line">            &quot;hello-world:latest&quot;: &quot;sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b&quot;,</span>
<span class="line">            &quot;hello-world@sha256:4cf9c47f86df71d48364001ede3a4fcd85ae80ce02ebad74156906caff5378bc&quot;: &quot;sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b&quot;</span>
<span class="line">        }</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="image-元数据" tabindex="-1"><a class="header-anchor" href="#image-元数据"><span>Image 元数据</span></a></h4><p>其中包含了镜像的一些元信息，如：</p><ul><li>镜像架构</li><li>OS</li><li>镜像默认配置</li><li>容器 ID 和配置</li><li>创建时间</li><li>Docker 版本</li><li>镜像构建历史</li><li>rootfs</li></ul><p>将镜像与构建镜像的镜像层关联了起来。Docker 会根据 <code>diff_ids</code> 计算出镜像层的存储索引 chainID。</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ sudo cat /var/lib/docker/image/overlay2/imagedb/content/sha256/bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b | python -mjson.tool</span>
<span class="line">{</span>
<span class="line">    &quot;architecture&quot;: &quot;amd64&quot;,</span>
<span class="line">    &quot;config&quot;: {</span>
<span class="line">        &quot;ArgsEscaped&quot;: true,</span>
<span class="line">        &quot;AttachStderr&quot;: false,</span>
<span class="line">        &quot;AttachStdin&quot;: false,</span>
<span class="line">        &quot;AttachStdout&quot;: false,</span>
<span class="line">        &quot;Cmd&quot;: [</span>
<span class="line">            &quot;/hello&quot;</span>
<span class="line">        ],</span>
<span class="line">        &quot;Domainname&quot;: &quot;&quot;,</span>
<span class="line">        &quot;Entrypoint&quot;: null,</span>
<span class="line">        &quot;Env&quot;: [</span>
<span class="line">            &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span>
<span class="line">        ],</span>
<span class="line">        &quot;Hostname&quot;: &quot;&quot;,</span>
<span class="line">        &quot;Image&quot;: &quot;sha256:eb850c6a1aedb3d5c62c3a484ff01b6b4aade130b950e3bf3e9c016f17f70c34&quot;,</span>
<span class="line">        &quot;Labels&quot;: null,</span>
<span class="line">        &quot;OnBuild&quot;: null,</span>
<span class="line">        &quot;OpenStdin&quot;: false,</span>
<span class="line">        &quot;StdinOnce&quot;: false,</span>
<span class="line">        &quot;Tty&quot;: false,</span>
<span class="line">        &quot;User&quot;: &quot;&quot;,</span>
<span class="line">        &quot;Volumes&quot;: null,</span>
<span class="line">        &quot;WorkingDir&quot;: &quot;&quot;</span>
<span class="line">    },</span>
<span class="line">    &quot;container&quot;: &quot;71237a2659e6419aee44fc0b51ffbd12859d1a50ba202e02c2586ed999def583&quot;,</span>
<span class="line">    &quot;container_config&quot;: {</span>
<span class="line">        &quot;ArgsEscaped&quot;: true,</span>
<span class="line">        &quot;AttachStderr&quot;: false,</span>
<span class="line">        &quot;AttachStdin&quot;: false,</span>
<span class="line">        &quot;AttachStdout&quot;: false,</span>
<span class="line">        &quot;Cmd&quot;: [</span>
<span class="line">            &quot;/bin/sh&quot;,</span>
<span class="line">            &quot;-c&quot;,</span>
<span class="line">            &quot;#(nop) &quot;,</span>
<span class="line">            &quot;CMD [\\&quot;/hello\\&quot;]&quot;</span>
<span class="line">        ],</span>
<span class="line">        &quot;Domainname&quot;: &quot;&quot;,</span>
<span class="line">        &quot;Entrypoint&quot;: null,</span>
<span class="line">        &quot;Env&quot;: [</span>
<span class="line">            &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span>
<span class="line">        ],</span>
<span class="line">        &quot;Hostname&quot;: &quot;71237a2659e6&quot;,</span>
<span class="line">        &quot;Image&quot;: &quot;sha256:eb850c6a1aedb3d5c62c3a484ff01b6b4aade130b950e3bf3e9c016f17f70c34&quot;,</span>
<span class="line">        &quot;Labels&quot;: {},</span>
<span class="line">        &quot;OnBuild&quot;: null,</span>
<span class="line">        &quot;OpenStdin&quot;: false,</span>
<span class="line">        &quot;StdinOnce&quot;: false,</span>
<span class="line">        &quot;Tty&quot;: false,</span>
<span class="line">        &quot;User&quot;: &quot;&quot;,</span>
<span class="line">        &quot;Volumes&quot;: null,</span>
<span class="line">        &quot;WorkingDir&quot;: &quot;&quot;</span>
<span class="line">    },</span>
<span class="line">    &quot;created&quot;: &quot;2020-01-03T01:21:37.263809283Z&quot;,</span>
<span class="line">    &quot;docker_version&quot;: &quot;18.06.1-ce&quot;,</span>
<span class="line">    &quot;history&quot;: [</span>
<span class="line">        {</span>
<span class="line">            &quot;created&quot;: &quot;2020-01-03T01:21:37.132606296Z&quot;,</span>
<span class="line">            &quot;created_by&quot;: &quot;/bin/sh -c #(nop) COPY file:7bf12aab75c3867a023fe3b8bd6d113d43a4fcc415f3cc27cbcf0fff37b65a02 in / &quot;</span>
<span class="line">        },</span>
<span class="line">        {</span>
<span class="line">            &quot;created&quot;: &quot;2020-01-03T01:21:37.263809283Z&quot;,</span>
<span class="line">            &quot;created_by&quot;: &quot;/bin/sh -c #(nop)  CMD [\\&quot;/hello\\&quot;]&quot;,</span>
<span class="line">            &quot;empty_layer&quot;: true</span>
<span class="line">        }</span>
<span class="line">    ],</span>
<span class="line">    &quot;os&quot;: &quot;linux&quot;,</span>
<span class="line">    &quot;rootfs&quot;: {</span>
<span class="line">        &quot;diff_ids&quot;: [</span>
<span class="line">            &quot;sha256:9c27e219663c25e0f28493790cc0b88bc973ba3b1686355f221c38a36978ac63&quot;</span>
<span class="line">        ],</span>
<span class="line">        &quot;type&quot;: &quot;layers&quot;</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="layer-元数据" tabindex="-1"><a class="header-anchor" href="#layer-元数据"><span>Layer 元数据</span></a></h4><p>对应每一个镜像层的元数据，实际上只包含这个镜像层的具体文件包。用户在 Docker 宿主机上下载了镜像层元数据后，Docker 会根据其中的文件包，以及 image 元数据，构建本地的 layer 元数据。新的镜像层上传到 registry 时，也只是上传文件包，本地元数据不会被上传。</p><p>Docker 定义了两种接口，分别用于描述只读镜像层和读写镜像层：</p><ul><li>roLayer (<code>/var/lib/docker/image/[graph_driver]/layerdb/sha256/[chainID]/</code>)</li><li>mountedLayer (<code>/var/lib/docker/image/[graph_driver]/layerdb/mounts/[container_id]/</code>)</li></ul><p>只读镜像层的元数据包含：</p><ul><li>chainID - 用于索引该镜像层，所以元数据的存储使用了这个 ID</li><li>diff - 镜像层校验码</li><li>parent - 父镜像层</li><li>cache-id</li><li>size - 镜像层大小</li></ul><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ sudo ls /var/lib/docker/image/overlay2/layerdb/sha256/9c27e219663c25e0f28493790cc0b88bc973ba3b1686355f221c38a36978ac63</span>
<span class="line">cache-id  diff  size  tar-split.json.gz</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，diff 使用 SHA256 基于该镜像层文件包中的内容计算而来，可以防止镜像层被篡改。而 chain-id 是用于索引该镜像层的 ID，由当前层和所有祖先镜像层的 diff 计算得到。如果镜像层位于最底层 (没有父镜像层)，那么 chain-id 就是 diff。</p><p>而读写镜像层的元数据有些不同：</p><ul><li>init-id</li><li>mount-id</li><li>parent</li></ul><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ sudo ls /var/lib/docker/image/overlay2/layerdb/mounts/2c5f1d785fd6f788caef17982901e898568ecfa4babb882d9487f9bc61a3a52b</span>
<span class="line">init-id  mount-id  parent</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>结合之后的存储驱动来理解它们各自的功能。</p><h3 id="docker-存储驱动" tabindex="-1"><a class="header-anchor" href="#docker-存储驱动"><span>Docker 存储驱动</span></a></h3><p>Docker 中管理文件系统的驱动为 GraphDriver，其中定义了一套统一的存储接口：</p><ul><li><code>String()</code> - 返回驱动名称字符串</li><li><code>Create()</code> - 创建新的镜像层</li><li><code>Remove()</code> - 删除一个镜像层 (根据指定的 ID)</li><li><code>Get()</code> - 返回指定 ID 层挂载点的绝对路径</li><li><code>Put()</code> - 释放一个层使用的资源</li><li><code>Exists()</code> - 查询指定 ID 的层是否存在</li><li><code>Status()</code> - 返回驱动的状态</li><li><code>Cleanup()</code> - 释放由这个驱动管理的所有资源</li></ul><p>另外，还有四个管理镜像层之间差异的接口：</p><ul><li><code>Diff()</code> - 将指定 ID 的层与其父镜像的改动文件打包返回</li><li><code>Changes()</code> - 返回指定镜像层与父镜像层的差异列表</li><li><code>ApplyDiff()</code> - 将差异应用到指定 ID 的层，返回新的镜像层大小</li><li><code>DiffSize()</code> - 计算指定 ID 层与父镜像层的差异，返回相对于基础文件系统的差异大小</li></ul><p>GraphDriver 中提供了一个实现上述四个函数的 <code>naiveDiffDriver</code> 结构。总之，在 Docker 中添加一个新的存储驱动时，要实现上述 12 个函数。</p><p>每个存储驱动都会向 GraphDriver 注册自己，加入到 GraphDriver 维护的 <code>drivers</code> 列表中。当需要创建一个存储驱动时，GraphDriver 会根据名字从 <code>drivers</code> 中找到驱动，调用其初始化函数，得到一个相应的 Driver 对象。优先级如下：</p><ol><li>从 <code>DOCKER_DRIVER</code> 和 <code>DefaultDriver</code> 环境变量中查找驱动名</li><li>从驱动优先级列表中查找一个可用的驱动 - aufs、btrfs、zfs、devicemapper、overlay、vfs</li><li>若上述驱动查不到可用的，那么查找所有注册过的驱动，找到第一个注册过的、可用的驱动并返回</li></ol><h4 id="aufs" tabindex="-1"><a class="header-anchor" href="#aufs"><span>AUFS</span></a></h4><p>AUFS (Advanced Multi-layered Unification Filesystem) 是一种 <strong>支持联合挂载</strong> 的文件系统，也就是支持将不同的目录挂载到同一个目录下，而挂载操作对用户来说透明。</p><p>AUFS 的每一层都是一个普通文件系统。在读取一个文件 A 时，将从最顶层的读写文件系统开始向下寻找，如果当前层没有，则根据层之间的关系到下一层文件系统中查找，直到找到第一个 A 文件并打开它。当要写入 A 文件时，如果 A 文件不存在，就在读写层中新建一个；否则也是从顶层开始查找，直到找到 A 文件，然后将 A 文件复制到读写层中，再应用修改。</p><blockquote><p>由此可以看出，在容器中第一次修改某个文件时，如果文件很大，将会产生巨大的磁盘 I/O 开销。</p></blockquote><p>在删除一个文件时，如果这个文件仅存在于读写层中，那么直接删除文件即可；否则需要先删除读写层中的备份，然后在读写层创建一个 <code>whiteout</code> 文件来标识这个文件不存在，而不是真正删除底层文件。</p><p>Docker 的工作目录位于 <code>/var/lib/docker</code>。在该目录下，如果使用了 AUFS 作为存储驱动，就会有一个 <code>aufs</code> 文件夹。该文件夹下会有三个目录：</p><ul><li><code>/mnt</code> - AUFS 的挂载目录</li><li><code>/diff</code> - 所有的文件系统数据</li><li><code>/layers</code> - 每一个层的层存储文件，记录层级关系</li></ul><p>最初只有 <code>/diff</code> 目录不为空，包含了文件系统的实际数据来源。最终这些文件系统 (层) 一起被挂载到 <code>/mnt</code> 目录上。</p><p>在 Docker 中，镜像管理部分和存储驱动部分的设计是分离的。在存储驱动中，镜像层或容器层拥有了新的标识 ID：</p><ul><li>在镜像层 (roLayer) 中称为 cache-id</li><li>在容器曾 (mountedLayer) 中称为 mount-id</li></ul><p>新建一个镜像层的步骤如下：</p><ol><li>在 <code>/mnt</code> 和 <code>/diff</code> 下创建与 mount-id 同名的子文件夹</li><li>在 <code>/layers</code> 目录下创建与 mount-id 同名的文件 (用于记录该层所依赖的所有其它层)</li><li>寻找该层依赖的所有镜像层，并将依赖的 mount-id 写入上述文件中 (父镜像层及其祖先镜像层)</li></ol><p>随后 GraphDriver 将 <code>/diff</code> 下所有属于容器镜像的层以 <strong>只读</strong> 方式挂载到 <code>/mnt</code> 下，然后再挂载一个名为 <code>&lt;mount-id&gt;-init</code> 的文件系统作为最后一个只读层。<code>&lt;mount_id&gt;-init</code> 的文件系统主要重新生成了以下文件：</p><ul><li><code>/dev/pts</code></li><li><code>/dev/shm</code></li><li><code>/proc</code></li><li><code>/sys</code></li><li><code>/.dockerinit</code></li><li><code>/.dockerenv</code></li><li><code>/etc/resolv.conf</code></li><li><code>/etc/hosts</code></li><li><code>/etc/hostname</code></li><li><code>/etc/console</code></li><li><code>/etc/mtab</code></li></ul><p>这些文件与容器内的 <strong>环境</strong> 息息相关，但并不适合被打包作为镜像的文件内容，而又不适合直接在宿主机上修改。所以 Docker 专门设计了这一层，单独处理这些文件。这一层 <strong>只会在容器启动时添加</strong>。只有这些文件在容器运行过程中被改变并 <code>docker commit</code> 后，才会持久化这些变化。否则，<strong>保存镜像时不会包含这些内容</strong>。严格来说，Docker 容器的文件系统层次为：</p><ul><li>最上层的读写文件系统</li><li>Init 层</li><li>只读层</li></ul><p>也就是说，所有文件系统的实际内容均保存在 <code>/diff</code> 下，包括可读写层目录。在容器启动时，这些文件系统会被联合挂载到 <code>/mnt</code> 下。<code>/mnt</code> 相当于是一个工作目录。当容器停止时，<code>/mnt</code> 目录下相应的 <code>&lt;mount-id&gt;</code> 目录被卸载，但是 <code>/diff</code> 目录下相应的文件夹依然存在。</p><p>最终，通过 <code>docker commit</code> 提交镜像后，最新的文件系统差异会保存到 <code>/diff</code> 文件夹下一个以新的 cache-id 命名的文件夹中，这就是新的镜像层。以原来的 mount-id 命名的文件夹依旧存在，直到对应的容器被删除。</p><h4 id="device-mapper" tabindex="-1"><a class="header-anchor" href="#device-mapper"><span>Device Mapper</span></a></h4><blockquote><p>没看懂...</p></blockquote><h4 id="overlay" tabindex="-1"><a class="header-anchor" href="#overlay"><span>Overlay</span></a></h4><p>OverlayFS 是一种新型的联合文件系统，允许用户将一个文件系统与另一个文件系统重叠，在上层文件系统中记录更改，而下层文件系统保持不变。与 AUFS 相比，OverlayFS 在设计上更简单，理论上性能更好。OverlayFS 中包含四类目录：</p><ul><li><code>lower</code> / <code>upper</code> - 被挂载的目录</li><li><code>merged</code> - 目录联合挂载点</li><li><code>work</code> - 辅助功能</li></ul><p>当同一个路径的两个文件分别存在于两个目录中时，位于 <code>upper</code> 中的文件将会屏蔽 <code>lower</code> 中的文件；对于同一个路径的文件夹，位于 <code>lower</code> 中的文件和文件夹将会与 <code>upper</code> 中的合并。</p><p>第一次以 write 方式打开一个位于 <code>lower</code> 中的文件时，OverlayFS 将执行 copy_up 将文件从 <code>lower</code> 复制到 <code>upper</code> 中，但 copy_up 的实现不符合 POSIX 标准。</p><p>最后为容器准备 rootfs 时，只需要将相应的四类目录联合挂载即可。</p><hr><h2 id="references" tabindex="-1"><a class="header-anchor" href="#references"><span>References</span></a></h2><p><a href="https://zhuanlan.zhihu.com/p/86890896" target="_blank" rel="noopener noreferrer">知乎 - Docker 容器实战 (七) - 容器中进程视野下的文件系统</a></p><p><a href="https://zh.wikipedia.org/wiki/Chroot" target="_blank" rel="noopener noreferrer">Wikipedia - chroot</a></p><p><a href="https://cloud.tencent.com/developer/article/1114569" target="_blank" rel="noopener noreferrer">腾讯云社区 - 干货 | Docker 文件系统的分层与隔离</a></p><hr>`,82)]))}const t=n(o,[["render",c],["__file","Docker Image _ Storage Management.html.vue"]]),u=JSON.parse('{"path":"/notes/Docker/Docker%20Image%20_%20Storage%20Management.html","title":"Docker - Image & Storage Management","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Docker 镜像管理","slug":"docker-镜像管理","link":"#docker-镜像管理","children":[{"level":3,"title":"rootfs","slug":"rootfs","link":"#rootfs","children":[]},{"level":3,"title":"Docker 镜像的特点","slug":"docker-镜像的特点","link":"#docker-镜像的特点","children":[]},{"level":3,"title":"镜像构建过程","slug":"镜像构建过程","link":"#镜像构建过程","children":[]}]},{"level":2,"title":"Docker 存储管理","slug":"docker-存储管理","link":"#docker-存储管理","children":[{"level":3,"title":"Docker 镜像元数据管理","slug":"docker-镜像元数据管理","link":"#docker-镜像元数据管理","children":[]},{"level":3,"title":"Docker 存储驱动","slug":"docker-存储驱动","link":"#docker-存储驱动","children":[]}]},{"level":2,"title":"References","slug":"references","link":"#references","children":[]}],"git":{},"filePathRelative":"notes/Docker/Docker Image & Storage Management.md"}');export{t as comp,u as data};
