import{_ as n,c as a,a as e,o as t}from"./app-BeHGwf2X.js";const l="/blog/assets/9-1-BB92Uzcx.png",p="/blog/assets/9-2-C0BfJAY5.png",c={};function o(i,s){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="chapter-9-1-块设备驱动程序-总体功能" tabindex="-1"><a class="header-anchor" href="#chapter-9-1-块设备驱动程序-总体功能"><span>Chapter 9.1 - 块设备驱动程序 总体功能</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 08 / 22 12:18</p><p>Ningbo, Zhejiang, China</p><hr><p>操作系统的所有设备可以粗略地分为两种类型：</p><ul><li>块设备：block device</li><li>字符型设备：character device</li></ul><p>块设备是一种可以以固定大小的数据块为单位进行寻址和访问的设备；字符型设备是一种以字符流作为操作对象的设备，不能进行寻址操作。为了便于管理和访问，OS 将这些设备统一以 <strong>设备号</strong> 进行分类，每个类型中的设备可再根据 <strong>从设备号</strong> 进行分类。</p><table><thead><tr><th>主设备号</th><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>/</td><td>/</td><td>/</td></tr><tr><td>1</td><td>ram</td><td>block/character</td><td>RAM，内存虚拟盘</td></tr><tr><td>2</td><td>fd</td><td>block</td><td>软盘驱动器</td></tr><tr><td>3</td><td>hd</td><td>block</td><td>硬盘驱动器</td></tr><tr><td>4</td><td>ttyx</td><td>character</td><td>虚拟或串行终端</td></tr><tr><td>5</td><td>tty</td><td>character</td><td>tty 设备</td></tr><tr><td>6</td><td>lp</td><td>character</td><td>打印机设备</td></tr></tbody></table><p>Linux 0.12 支持硬盘、软盘、内存虚拟盘三种块设备。<code>linux/kernel/blk_drv</code> 中的文件分类如下：</p><ul><li>对应各设备的驱动程序 <ul><li><code>hd.c</code>：硬盘驱动程序</li><li><code>floppy.c</code>：软盘驱动程序</li><li><code>ramdisk.c</code>：内存虚拟盘驱动程序</li></ul></li><li>用于内核中其它程序访问块设备的接口程序 <code>ll_rw_blk.c</code></li><li>块设备专用头文件 <code>blk.h</code></li></ul><hr><h2 id="_9-1-总体功能" tabindex="-1"><a class="header-anchor" href="#_9-1-总体功能"><span>9.1 总体功能</span></a></h2><p>内核每次读写的数据量以一个逻辑块 (1024B) 为单位，而块设备控制器以扇区 (512B) 为单位访问块设备。内核使用 <strong>读写请求项等待队列</strong> 来顺序地缓冲一次读写多个逻辑块的操作。程序需要读取一个逻辑块时，首先向 <strong>缓冲区管理程序</strong> 提出申请，然后进入睡眠等待状态。缓冲区管理程序首先在缓冲区中寻找以前是否已经读取过这块数据：</p><ul><li>若有，则将缓冲区头指针返回，并唤醒进程</li><li>若没有，则调用 <code>ll_rw_blk()</code>，向设备发出操作请求</li></ul><p>创建一个请求结构项，并以电梯算法插入请求结构项。若此时块设备的请求项队列为空，则表明设备不忙，直接向块设备控制器发出读数据命令。当块设备控制器将数据读入指定的缓冲区后，发出中断信号，调用 <em>后处理函数</em>：</p><ul><li>关闭设备</li><li>设置缓冲区数据更新标志</li><li>唤醒等待该块数据的进程</li></ul><h3 id="_9-1-1-块设备请求项和请求队列" tabindex="-1"><a class="header-anchor" href="#_9-1-1-块设备请求项和请求队列"><span>9.1.1 块设备请求项和请求队列</span></a></h3><p>对于各种块设备，内核维护一张块设备表 blk_dev[] 来进行管理，每种块设备都在块设备表中占有一项：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">blk_dev_struct</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>request_fn<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 请求项操作的函数指针</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">request</span> <span class="token operator">*</span> current_request<span class="token punctuation">;</span>  <span class="token comment">// 当前请求项</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">blk_dev_struct</span> blk_dev<span class="token punctuation">[</span>NR_BLK_DEV<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 7</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>第一个参数，用于对相应的块设备请求进行操作 <ul><li><code>do_rd_request()</code></li><li><code>do_hd_request()</code></li><li><code>do_floppy_request()</code></li></ul></li><li>第二个参数，指向本设备当前正在处理的请求项 (初始化为 NULL)</li></ul><p>内核发出操作时，利用相应的请求项操作函数 <code>do_XX_request()</code> 建立 <strong>块设备请求项</strong>，并利用 <strong>电梯算法</strong> 插入到请求项队列中。<strong>请求项队列</strong> 由 <strong>请求项数组</strong> 中的项构成：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">request</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">int</span> dev<span class="token punctuation">;</span> <span class="token comment">// 主设备号，-1 表示该项空闲</span></span>
<span class="line">    <span class="token keyword">int</span> cmd<span class="token punctuation">;</span> <span class="token comment">// READ == 0, WRITE == 1</span></span>
<span class="line">    <span class="token keyword">int</span> errors<span class="token punctuation">;</span> <span class="token comment">// 操作产生的错误次数</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sector<span class="token punctuation">;</span> <span class="token comment">// 起始扇区</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_sectors<span class="token punctuation">;</span> <span class="token comment">// 读/写扇区数</span></span>
<span class="line">    <span class="token keyword">char</span> <span class="token operator">*</span> buffer<span class="token punctuation">;</span> <span class="token comment">// 数据缓冲区</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span> waiting<span class="token punctuation">;</span> <span class="token comment">// 等待操作完成的任务</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">buffer_head</span> <span class="token operator">*</span> bh<span class="token punctuation">;</span> <span class="token comment">// 缓冲区头指针</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">request</span> <span class="token operator">*</span> next<span class="token punctuation">;</span> <span class="token comment">// 下一个请求项</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">request</span> request<span class="token punctuation">[</span>NR_REQUEST<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 32</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请求项数组共有 32 个空槽，而项与项之间利用 next 字段形成链表，即数组 + 链表结构：</p><ul><li>数组结构方便搜索空闲请求快</li><li>链表结构满足电梯算法的插入请求项操作</li></ul><p>这个请求项数组中保存了所有类型块设备的请求项。每个类型的块设备有一条自己的链表：</p><p><img src="`+l+'" alt="9-1"></p><p>若设备的 <code>current_request</code> 为 NULL，说明设备空闲。新建立的请求项被 <code>current_request</code> 指向后，会立刻调用对应设备的操作函数进行操作；若 <code>current_request</code> 不为 NULL，则利用电梯算法将请求项插入链表的适当位置。</p><p>另外，为了满足 <strong>读操作</strong> 的优先权，建立写操作请求的空闲项搜索范围为数组的前 2/3，剩下的 1/3 请求项专门为读操作建立请求使用。</p><h3 id="_9-1-2-块设备访问调度处理" tabindex="-1"><a class="header-anchor" href="#_9-1-2-块设备访问调度处理"><span>9.1.2 块设备访问调度处理</span></a></h3><p>对于内存来说，访问硬盘、软盘等块设备较为耗时。因此需要对链表中的请求项进行排序，使请求项访问的磁盘扇区数据块尽量依次进行操作。</p><p><strong>电梯算法</strong>：向一个方向移动，直至该方向上的最后一个请求；再向相反方向移动。对于磁盘来说，磁头一直向盘片圆心方向移动，或反之向盘片边缘移动。因此，内核并非按照请求项到来顺序对块设备进行处理，而是要对请求项的顺序进行优化处理。这部分称为 I/O 调度程序。Linux 0.1x 中仅对请求项进行了排序处理，目前流行的 Linux 内核还包含对访问相邻磁盘扇区的两个或多个请求进行合并处理。</p><h3 id="_9-1-3-块设备操作方式" tabindex="-1"><a class="header-anchor" href="#_9-1-3-块设备操作方式"><span>9.1.3 块设备操作方式</span></a></h3><p>首先理清三个对象之间的相互作用：</p><p><img src="'+p+'" alt="9-2"></p><blockquote><p>这么一看就比较清楚了。设备控制器和驱动器之间的事，交给内部的电路完成，kernel 只需要向设备控制器发送命令，然后设备控制器完成后发来中断，由 CPU 的中断处理程序完成相应功能即可。</p></blockquote><ul><li>首先，系统指明控制器引发中断后，应当调用的 C 函数</li><li>向块设备控制器发送读 / 写 / 复位等命令</li><li>控制器完成指定命令，发出中断请求信号，引发系统执行块设备的中断处理过程，在其中调用指定的 C 函数</li></ul><p>对于写盘操作：</p><ul><li>系统发出写命令</li><li>查询等待 <strong>控制状态寄存器</strong> 的 <strong>数据请求服务标志 DRQ</strong> 置位</li><li>置位后，系统向控制器缓冲区发送一个扇区的数据</li><li>控制器将数据写入驱动器后，产生中断请求信号</li><li>引发中断处理过程，并调用指定的 C 函数，在函数中判断是否还有数据要写；如果有，则再将一个扇区的数据送往控制寄存器</li><li>若所有数据都已写入驱动器，则进行后处理工作 <ul><li>唤醒等待请求项数据的进程</li><li>唤醒等待空闲请求项的进程</li><li>释放当前请求项，修改指针从链表中删除</li><li>释放锁定的相关缓冲区</li><li>调用请求项操作函数，执行下一个请求项</li></ul></li></ul><p>对于读盘操作：</p><ul><li>向控制器发出读命令</li><li>控制器将指定的一扇区数据从驱动器传到自己的缓冲区中，并发出中断请求</li><li>在预置的 C 函数中，将控制器缓冲中的数据复制到系统缓冲区中；若还有数据要读，则继续等待下一个中断信号</li><li>若所有数据都已经读到系统缓冲区中，则进行后处理工作</li></ul><p>对于虚拟盘设备，由于不牵扯到与外设之间的操作，因此没有中断处理过程。读写操作完全在 <code>do_rd_request()</code> 中实现。</p><p>注意：向控制器发送读写命令后，发送命令的函数会立刻返回，不会等待命令被执行的过程。在调用了 <code>ll_rw_block()</code> 之后，调用等待函数 <code>wait_on_buffer()</code> 让执行当前代码的进程立刻进入睡眠状态，直到 I/O结束，在 <code>end_request()</code> 中被唤醒。</p>',43)]))}const d=n(c,[["render",o],["__file","Chapter 9.1 - 块设备驱动程序 总体功能.html.vue"]]),u=JSON.parse('{"path":"/linux-kernel-comments-notes/Chapter%209%20-%20%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/Chapter%209.1%20-%20%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%20%E6%80%BB%E4%BD%93%E5%8A%9F%E8%83%BD.html","title":"Chapter 9.1 - 块设备驱动程序 总体功能","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"9.1 总体功能","slug":"_9-1-总体功能","link":"#_9-1-总体功能","children":[{"level":3,"title":"9.1.1 块设备请求项和请求队列","slug":"_9-1-1-块设备请求项和请求队列","link":"#_9-1-1-块设备请求项和请求队列","children":[]},{"level":3,"title":"9.1.2 块设备访问调度处理","slug":"_9-1-2-块设备访问调度处理","link":"#_9-1-2-块设备访问调度处理","children":[]},{"level":3,"title":"9.1.3 块设备操作方式","slug":"_9-1-3-块设备操作方式","link":"#_9-1-3-块设备操作方式","children":[]}]}],"git":{},"filePathRelative":"linux-kernel-comments-notes/Chapter 9 - 块设备驱动程序/Chapter 9.1 - 块设备驱动程序 总体功能.md"}');export{d as comp,u as data};
