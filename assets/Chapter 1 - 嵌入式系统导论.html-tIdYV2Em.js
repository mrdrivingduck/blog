import{_ as i,c as e,a,o as r}from"./app-7eKjwDat.js";const n={};function s(t,l){return r(),e("div",null,l[0]||(l[0]=[a('<h1 id="chapter-1-嵌入式系统导论" tabindex="-1"><a class="header-anchor" href="#chapter-1-嵌入式系统导论"><span>Chapter 1 - 嵌入式系统导论</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 11 / 04 14:50</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="_1-1-嵌入式系统的基本概念" tabindex="-1"><a class="header-anchor" href="#_1-1-嵌入式系统的基本概念"><span>1.1 嵌入式系统的基本概念</span></a></h2><p>嵌入式系统的 <strong>嵌入性</strong> 是它的根本特点：以嵌入为手段，以控制为目的的专用计算机。嵌入式计算机与通用计算机有着完全不同的技术要求、应用目标和技术发展方向：</p><ul><li>通用计算机系统 <ul><li>高速、海量的计算</li><li>总线速度无限提升</li><li>存储容量无限扩大</li><li>应用目标多样化</li></ul></li><li>嵌入式计算机系统 <ul><li>应用系统的智能化控制</li><li>可靠、可剪裁</li><li>满足对体积、功耗的严格要求</li><li>嵌入性、专用性、智能化、可靠性的提升</li></ul></li></ul><p>早期，嵌入式应用范围狭窄，由通用计算机进行改装后嵌入大型系统中。目前，嵌入式应用对计算机的功能、体积、功耗等指标的要求越来越苛刻，形成了现代计算机两大分支并行发展的时代——后 PC 时代。嵌入式系统走上了 <strong>单芯片化</strong> 的发展道路。</p><ul><li>Σ 模式：将通用计算机系统中的基本单元进行裁剪，直接芯片化</li><li>创新模式：按照嵌入式应用的要求，以全新的方式设计体系结构、指令系统、总线方式、管理模式、外设等</li></ul><p>历史证明，创新模式是嵌入式系统独立发展的正确道路。</p><p>嵌入式系统的特点：</p><ol><li>系统内核小，实时高效：嵌入式系统多用于小型电子设备，系统资源有限</li><li>专用性强：产品个性化强</li><li>系统精简：软硬件高效设计，量体裁衣、去除冗余</li><li>软件固化：固化在存储器芯片中，不存储于磁盘等载体中</li></ol><h2 id="_1-2-嵌入式系统的组成结构" tabindex="-1"><a class="header-anchor" href="#_1-2-嵌入式系统的组成结构"><span>1.2 嵌入式系统的组成结构</span></a></h2><p>为了便于 OS 在不同结构的硬件上移植，微软提出将 OS 底层与硬件相关的单独部分抽象出来，设计成单独的 <strong>硬件抽象层</strong>（Hardware Abstraction Layer, HAL），向 OS 提供对硬件进行抽象后的服务。OS 不再直接面对具体的硬件环境，而是面向这个中间层代表的逻辑上的硬件环境。</p><blockquote><p>HAL 可否理解为 VMM 的封装？这样不同的 OS 都可以像虚拟机一样运行，不用管物理硬件，管逻辑硬件即可。</p></blockquote><p>目前，HAL 通常以 <strong>板级支持包</strong>（BSP, Board Support Package）的形式实现。因此嵌入式系统形成了四层结构，从上到下：</p><ul><li>应用层</li><li>OS 层</li><li>中间层 (HAL)</li><li>硬件层</li></ul><h3 id="_1-2-1-硬件层" tabindex="-1"><a class="header-anchor" href="#_1-2-1-硬件层"><span>1.2.1 硬件层</span></a></h3><p>嵌入式处理器的特点：</p><ol><li>对实时多任务有很强的支持能力</li><li>很强的存储区保护能力</li><li>可扩展的处理器结构</li><li>低功耗</li></ol><p>嵌入式处理器的分类：</p><ol><li>嵌入式微控制器 (MicroController Unit, MCU)：又称单片机，将整个计算机系统集成到一块芯片中，以微处理器内核为核心，芯片内部集成 ROM、RAM、总线等外设；一个系列有多种衍生产品，固定内核 + 定制外设，以满足不同场景的需求</li><li>嵌入式微处理器 (Embedded Microprocessor Unit, EMPU)：基于通用计算机中的 CPU，在工作温度、抗电磁干扰、可靠性等方面做了增强</li><li>嵌入式 DSP 处理器 (Embedded Digital Signal Processor, EDSP)：对系统结构和指令进行了特殊设计，适合于执行 DSP 算法，编译效率高，执行速度高</li><li>嵌入式 SoC (System on Chip)：将处理器内核和外设作为标准库进行定制</li></ol><h3 id="_1-2-2-硬件抽象层" tabindex="-1"><a class="header-anchor" href="#_1-2-2-硬件抽象层"><span>1.2.2 硬件抽象层</span></a></h3><p>多以 BSP 形式实现，完成系统上电后最初的硬件初始化，并对底层硬件进行封装，使 OS 不再面对裸硬件。关于 BSP 有几种理解：</p><ul><li>BSP 是 OS 的驱动程序</li><li>板级开发工具</li><li>...</li></ul><p>BSP 的主要功能：</p><ol><li>片级初始化：将 CPU 从上电默认状态设置为系统要求的工作状态</li><li>板级初始化：对外设初始化，为随后 OS 的初始化建立运行条件</li><li>OS 初始化：为软件系统提供实时多任务的运行环境；BSP 将 CPU 的控制权交给 OS，OS 初始化完成后，将控制权交给应用程序入口</li></ol><p>OS 初始化不是 BSP 的主要工作，而是由 BSP 发起的。</p><blockquote><p>我的理解，BSP 相当于 BIOS，在启动时把 CPU 和外设设置好，并把控制权转交 OS。由于嵌入式系统中，OS 不在硬盘上，而是固化在 ROM 里，因此省去了从硬盘里搬运 OS 启动代码的步骤。OS 可以直接进行初始化，建立多任务的运行环境。</p></blockquote><h3 id="_1-2-3-应用层" tabindex="-1"><a class="header-anchor" href="#_1-2-3-应用层"><span>1.2.3 应用层</span></a></h3><blockquote><p>没啥东西</p></blockquote><h2 id="_1-3-嵌入式系统设计的基本方法" tabindex="-1"><a class="header-anchor" href="#_1-3-嵌入式系统设计的基本方法"><span>1.3 嵌入式系统设计的基本方法</span></a></h2><h2 id="_1-4-嵌入式操作系统的基本概念" tabindex="-1"><a class="header-anchor" href="#_1-4-嵌入式操作系统的基本概念"><span>1.4 嵌入式操作系统的基本概念</span></a></h2><p>实时系统：在限定时间内，能够提供所需要的服务水平的系统</p><ul><li>软实时：任务运行的逻辑正确，且越快越好，不严格限定任务运行时间的底线；时序得不到满足，只会引起性能严重下降，不产生严重后果</li><li>硬实时：逻辑准确无误且要求做到 <strong>及时</strong>；如果特定时序得不到满足，将会引起灾难性后果</li></ul><p>在实时系统中，系统正确性不仅取决于计算结果的正确性，还取决于正确结果产生的时间。为了满足实时性，<strong>系统行为就必须是可预测和可确定的</strong>。这是实时系统的本质特征。大多数嵌入式系统都是实时系统，且多是硬实时多任务系统。这就要求相应的嵌入式操作系统也必须是实时操作系统。OS 行为的可确定性是实时 OS 的本质特征——只有每个行为执行的时间都能预测，才能使实时得到保证。</p><blockquote><p>其实一直没想明白，行为执行的时间咋预测啊...... 😥</p></blockquote><p>嵌入式 OS 提高了系统的可靠性，系统至少不会崩溃，且要有一定自愈能力。通常，任务之间的通信和控制都由内核实现。系统受干扰后，一般只会导致一个任务受到破坏，有专门的系统监控任务对其进行修复（比如删除）。使用嵌入式实时 OS 的确定是增加了额外的 ROM/RAM 开销，以及 2%-5% 的 CPU 负荷。</p><p>嵌入式 OS 的特点：</p><ol><li>结构紧凑，尺寸微小：嵌入式系统不具备大容量的存储介质，OS 只能运行在优先的空间中，不能使用虚拟内存，中断的使用也受到限制</li><li>实时性强：大多数嵌入式 OS 工作在实时性要求很高的场合</li><li>可剪裁：开放自身，使开发者可以根据硬件环境对 OS 进行灵活的剪裁可配置，只使用需要的功能即可，即插即用</li><li>可靠性高：一旦开始运行就不需要人的过多干预，组成越简单，性能越可靠</li><li>特殊的开发调试环境</li></ol><p>嵌入式 OS 与通用 OS 的区别：</p><ol><li>设计目标不同 <ul><li>通用 OS 追求最大的吞吐率，强调系统整体性能最佳</li><li>丧失了系统行为的可确定性和可预测性</li><li>嵌入式 OS 始终保证系统行为的可预测性</li><li>在任何情况下，嵌入式 OS 都能为多个实时任务合理分配资源，满足实时性</li></ul></li><li>调度原则不同 <ul><li>通用 OS 为了达到最佳整体性能，采用公平的调度法则</li><li>嵌入式 OS 为了保证实时性，多采用基于优先级的可剥夺调度策略</li></ul></li><li>内存管理机制不同：嵌入式 OS 没有硬盘，内存资源有限，很少采用虚拟内存</li><li>稳定性与交互性不同</li><li>实时性不同</li></ol><h2 id="_1-5-初始-μc-os-ii-操作系统" tabindex="-1"><a class="header-anchor" href="#_1-5-初始-μc-os-ii-操作系统"><span>1.5 初始 μC/OS-II 操作系统</span></a></h2><p>于 1992 年由美国人 <em>Jean Labrosse</em> 编写，专为单片机嵌入式系统应用设计，主体代码由 ANSI C 编程，十分易于移植。</p><p>特点：</p><ol><li>开源，注解详尽，内核结构清晰，代码漂亮</li><li>可移植：绝大部分源码由 ANSI C 编写，有很强的移植性，与硬件相关的代码由汇编编写，已经被压到了最低限度，移植只需改写很少的代码；移植条件： <ul><li>CPU 必须有堆栈指针</li><li>有内部寄存器的入栈和出栈指令</li><li>C 编译器必须支持内嵌汇编 或 C 语言可链接汇编模块 (使 C 语言中能实现开关中断)</li></ul></li><li>可固化</li><li>可剪裁：提供条件编译配置常量</li><li>可剥夺：可剥夺的实时内核，准备就绪的高优先级任务总是可以剥夺正在运行的低优先级任务</li><li>多任务：可以管理 64 个任务，其中最好预留给 OS 8 个，每个任务必须赋予不同的优先级</li><li>可确定性：绝大部分函数的执行时间具有确定性，大部分系统服务的执行时间不依赖于应用程序数目的多少</li><li>任务栈：允许每个任务有自己的栈，每个栈的大小可以根据实际需要定义，以便节省 RAM 需求</li><li>系统服务：信号量、时间管理、消息队列等</li><li>中断管理：中断嵌套层数可达 255 层，高优先级任务可以在中断嵌套全部退出后立即执行</li><li>稳定性和可靠性：得到了 <em>美国联邦航空管理局</em> 的认证，能用于性命攸关、安全条件极为苛刻的系统中</li></ol><p>μC/OS-II 总共 16 个文件：</p><ul><li>11 个与 CPU 无关，移植后无需修改</li><li>3 个文件与 CPU 类型相关，移植时需要根据 CPU 类型进行修改</li><li>2 个文件与具体应用相关，可根据需要条件编译</li></ul><hr><h2 id="summary" tabindex="-1"><a class="header-anchor" href="#summary"><span>Summary</span></a></h2><p>That&#39;s it.</p><p>希望会比 Linux 好读一些</p>',53)]))}const o=i(n,[["render",s],["__file","Chapter 1 - 嵌入式系统导论.html.vue"]]),h=JSON.parse('{"path":"/uc-os-ii-code-notes/Chapter%201%20-%20%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA.html","title":"Chapter 1 - 嵌入式系统导论","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"1.1 嵌入式系统的基本概念","slug":"_1-1-嵌入式系统的基本概念","link":"#_1-1-嵌入式系统的基本概念","children":[]},{"level":2,"title":"1.2 嵌入式系统的组成结构","slug":"_1-2-嵌入式系统的组成结构","link":"#_1-2-嵌入式系统的组成结构","children":[{"level":3,"title":"1.2.1 硬件层","slug":"_1-2-1-硬件层","link":"#_1-2-1-硬件层","children":[]},{"level":3,"title":"1.2.2 硬件抽象层","slug":"_1-2-2-硬件抽象层","link":"#_1-2-2-硬件抽象层","children":[]},{"level":3,"title":"1.2.3 应用层","slug":"_1-2-3-应用层","link":"#_1-2-3-应用层","children":[]}]},{"level":2,"title":"1.3 嵌入式系统设计的基本方法","slug":"_1-3-嵌入式系统设计的基本方法","link":"#_1-3-嵌入式系统设计的基本方法","children":[]},{"level":2,"title":"1.4 嵌入式操作系统的基本概念","slug":"_1-4-嵌入式操作系统的基本概念","link":"#_1-4-嵌入式操作系统的基本概念","children":[]},{"level":2,"title":"1.5 初始 μC/OS-II 操作系统","slug":"_1-5-初始-μc-os-ii-操作系统","link":"#_1-5-初始-μc-os-ii-操作系统","children":[]},{"level":2,"title":"Summary","slug":"summary","link":"#summary","children":[]}],"git":{},"filePathRelative":"uc-os-ii-code-notes/Chapter 1 - 嵌入式系统导论.md"}');export{o as comp,h as data};
