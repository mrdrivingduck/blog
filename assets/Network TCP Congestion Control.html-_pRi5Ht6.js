import{_ as o,c as n,a as c,o as d}from"./app-BeHGwf2X.js";const l={};function t(r,e){return d(),n("div",null,e[0]||(e[0]=[c('<h1 id="network-tcp-congestion-control" tabindex="-1"><a class="header-anchor" href="#network-tcp-congestion-control"><span>Network - TCP Congestion Control</span></a></h1><p>Created by : Mr Dk.</p><p>2021 / 03 / 09 16:45</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="about" tabindex="-1"><a class="header-anchor" href="#about"><span>About</span></a></h2><p>拥塞控制是 TCP 通信的每一方需要执行的一系列行为，防止网络因为大规模的通信负载而瘫痪。当有理由认为网络即将进入拥塞状态时，减缓 TCP 传输速率。难点：</p><ul><li>如何准确判断合适减慢速度</li><li>如何减缓传输速度</li><li>何时恢复原有速度</li></ul><p>当某一路由器在单位时间内接收到的数据量多余可发送的数据量时，就需要把多余的部分存储起来。如果这种情况持续，那么存储资源将会耗尽，这种现象称为拥塞。如果不采取对策，那么网络性能将大受影响导致瘫痪。因此需要 TCP 通信的每一方都执行 <strong>拥塞控制机制</strong>。</p><p>发送方没有精确的方法知晓中间路由器的状态，常用的推断方式是观察是否有丢包发生。在 TCP 中，丢包被用于判断拥塞发生与否的指标，并衡量是否实施相应措施 (减缓发送)。</p><p>TCP 发送端的发送速率应该等于以下两种中的最小值：</p><ul><li>接收端的接收速率</li><li>传输速率</li></ul><p>反应网络传输能力的变量被称为 <strong>拥塞窗口 (congestion window, cwnd)</strong>，接收端的通知窗口为 <strong>awnd</strong>。发送端实际可用的窗口就是两者的最小值：<code>W = min { cwnd, awnd }</code>。也就是说，在发送端，还没有收到 ACK 回复的字节数不能多于 <code>W</code>。<code>W</code>、<code>cwnd</code>、<code>awnd</code> 都会随时间动态改变。</p><h2 id="algorithms" tabindex="-1"><a class="header-anchor" href="#algorithms"><span>Algorithms</span></a></h2><p>在 TCP 连接建立之初，由于无法获知可用的传输资源，<code>cwnd</code> 的初始值是无法确定的，而通信双方交换一个报文就可以获得 <code>awnd</code> 的值。获取 <code>cwnd</code> 的最佳做法是以越来越大的速率发出数据，直到出现丢包为止，这里就有两种策略：</p><ul><li>慢速启动发送</li><li>立刻以 (<code>awnd</code> 限制下的) 最大速率发送</li></ul><p>由于多个 TCP 连接共享网络传输路径，全速启动将会影响其它连接的传输性能。</p><p>TCP 发送方的拥塞控制操作是由 <strong>ACK 的接收</strong> 来驱动的。当接收到一个 ACK 后，拥塞控制机制可以决定是否再发一个数据包，是否再发更多的数据包，如何多发数据包等问题。由一个 ACK 到达触发的数据包传输被称为 <strong>自同步 (self-clocking)</strong> 关系。</p><h3 id="慢启动" tabindex="-1"><a class="header-anchor" href="#慢启动"><span>慢启动</span></a></h3><p>当一个新的 TCP 连接建立，或由 <strong>重传超时</strong> 导致了丢包时，需要执行慢启动。慢启动为 <code>cwnd</code> 指定了一个 <strong>初始窗口 (Initial Window)</strong>，通常是 SMSS (发送方最大段大小) 的整数倍。当接收到一个大于之前收到的 ACK 号的 ACK 号后，发送窗口扩大为原来的两倍，并发送数量等于窗口大小的数据包。如果这些数据包的 ACK 都被成功接收，那么窗口再扩大两倍。以指数函数的形式扩大窗口。概括：TCP 发送方每收到一个 ACK 就执行一次 <code>cwnd</code> 的增长操作。</p><h3 id="拥塞避免" tabindex="-1"><a class="header-anchor" href="#拥塞避免"><span>拥塞避免</span></a></h3><p><code>cwnd</code> 不可能以指数函数的形式无限增大。在到达 <strong>慢启动阈值 (slow start threshold, ssthresh)</strong> 后，意味着 <strong>可能</strong> 有更多可用的传输资源，如果立刻占用，将使共享路由器的其它连接出现严重的丢包和重传。<code>cwnd</code> 到达 ssthresh 后，将进入拥塞避免阶段。每个新的 ACK 到达，将会使 <code>cwnd</code> 有相应的 <strong>小幅增长</strong>，也称为累加增长。</p><p>每个 ACK 应答到来时，<code>cwnd</code> 增加 <code>1 / cwnd</code>。比如，<code>cwnd</code> 为 8，当 8 个 ACK 应答到来时，<code>cwnd</code> 将会增加 <code>8 * 1/8</code>，也就是 <code>1</code>，即线性增长。</p><h2 id="慢启动阈值" tabindex="-1"><a class="header-anchor" href="#慢启动阈值"><span>慢启动阈值</span></a></h2><p>在通常操作中，TCP 连接总是选择慢启动和拥塞避免算法中的一个。它们的区别在于 <code>cwnd</code> 以什么样的方式增大。慢启动阈值不是固定的，而是会随着时间改变。如果出现重传的情况，TCP 会认为窗口超出了网络传输能力，将慢启动阈值减小为当前窗口大小的一半。</p><h2 id="快速恢复算法" tabindex="-1"><a class="header-anchor" href="#快速恢复算法"><span>快速恢复算法</span></a></h2><p>BSD 4.2 (Tahoe) 中的 TCP 版本在检测到丢包后，不论使由于超时还是快速重传，都会重新进入慢启动状态，使得带宽利用率较为低下。需要针对不同的丢包情况，考虑是否需要重新回到慢启动状态：</p><ul><li>如果是超时引发的丢包，则重新进入慢启动：慢启动阈值变为 <code>cwnd</code> 的一半，<code>cwnd</code> 被重设为 <code>1</code></li><li>如果是重复 ACK (快速重传) 而引起的丢包，则没必要重新进入慢启动状态</li></ul><p>TCP 的标准使用了上述的核心思想：TCP 连接建立之初，设置慢启动阈值，在接收到新数据传输成功的 ACK 后，使用慢启动或拥塞避免算法更新 <code>cwnd</code>。当接收到三次重复的 ACK (快速重传信号) 时，执行快速恢复算法：</p><ul><li>慢启动阈值被设置为 <code>cwnd</code> 的一半 (防止网络拥塞)</li><li>启动快速重传算法，<code>cwnd</code> 被设置为 (ssthresh + 3 * SMSS)</li><li>每接收到一个重复 ACK (丢包已被重传并确认，新的数据包有发送机会)，<code>cwnd</code> 暂时增大 1</li><li>当收到新数据的 ACK 后，重新执行拥塞避免算法，<code>cwnd</code> 被设置为慢启动阈值</li></ul><blockquote><p>可以认为三个重复的 ACK 引发的重传占了三个本来可以传输的之后的数据包的流量，所以窗口增长到慢启动阈值 + 3 * SMSS。之后如果又收到一个重复 ACK，说明又要重传一次，又占了一个之后数据包的流量，所以窗口大小又增大了 1。</p><p>直到需要被重传的数据都被重传 (接收到了新数据的 ACK)，窗口才会恢复正常大小 (慢启动阈值)，并重新执行拥塞避免算法。</p></blockquote><h2 id="基于延迟的拥塞控制算法" tabindex="-1"><a class="header-anchor" href="#基于延迟的拥塞控制算法"><span>基于延迟的拥塞控制算法</span></a></h2><p>之前的拥塞控制算法基于丢包信息。而实际中，当发送端不断向网络中发送数据包时，不断增长的 RTT 就可以作为拥塞形成的信号。一些拥塞控制技术是基于这个发现而被提出的。</p><hr><h2 id="references" tabindex="-1"><a class="header-anchor" href="#references"><span>References</span></a></h2><p>TCP/IP 详解 - 卷 1：协议</p><p><a href="https://zhuanlan.zhihu.com/p/133307545" target="_blank" rel="noopener noreferrer">知乎专栏 - 30 张图解：TCP 重传、滑动窗口、流量控制、拥塞控制</a></p><hr>',38)]))}const s=o(l,[["render",t],["__file","Network TCP Congestion Control.html.vue"]]),i=JSON.parse('{"path":"/notes/Network/Network%20TCP%20Congestion%20Control.html","title":"Network - TCP Congestion Control","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"About","slug":"about","link":"#about","children":[]},{"level":2,"title":"Algorithms","slug":"algorithms","link":"#algorithms","children":[{"level":3,"title":"慢启动","slug":"慢启动","link":"#慢启动","children":[]},{"level":3,"title":"拥塞避免","slug":"拥塞避免","link":"#拥塞避免","children":[]}]},{"level":2,"title":"慢启动阈值","slug":"慢启动阈值","link":"#慢启动阈值","children":[]},{"level":2,"title":"快速恢复算法","slug":"快速恢复算法","link":"#快速恢复算法","children":[]},{"level":2,"title":"基于延迟的拥塞控制算法","slug":"基于延迟的拥塞控制算法","link":"#基于延迟的拥塞控制算法","children":[]},{"level":2,"title":"References","slug":"references","link":"#references","children":[]}],"git":{},"filePathRelative":"notes/Network/Network TCP Congestion Control.md"}');export{s as comp,i as data};
