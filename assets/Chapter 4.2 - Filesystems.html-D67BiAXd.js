import{_ as s,c as i,a as n,o as l}from"./app-BeHGwf2X.js";const a={};function t(c,e){return l(),i("div",null,e[0]||(e[0]=[n(`<h1 id="chapter-4-2-filesystems" tabindex="-1"><a class="header-anchor" href="#chapter-4-2-filesystems"><span>Chapter 4.2 - Filesystems</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 06 / 21 13:54</p><p>@Nanjing, Jiangsu, China</p><hr><p>对于磁盘来说，内核与用户空间之间的桥梁是文件系统。文件系统是一种数据库，包含能够将 block device 转变为不同等级的文件和目录的数据结构。</p><p>Virtual File System (VFS) 抽象层完成了文件系统的实现</p><ul><li>确保了所有文件系统的实现支持一个统一的接口</li><li>用户空间应用以相同的方式访问文件和目录</li></ul><h3 id="_4-2-1-filesystem-types" tabindex="-1"><a class="header-anchor" href="#_4-2-1-filesystem-types"><span>4.2.1 Filesystem Types</span></a></h3><p>Linux 文件系统支持专为 Linux 优化的文件系统，也支持 Windows FAT 家族的其它文件系统，还支持 ISO 9660 等通用文件系统：</p><ul><li>Forth Extended Filesystem (ext4) - Linux 默认的文件系统 <ul><li>ext2 是很长一段时间内 Linux 的默认系统</li><li>ext3 在 ext2 的基础上，在文件系统数据结构以外加入了一块缓存，加强数据完整性</li><li>ext4 文件系统在 ext3 的基础上，支持了更大的文件和更多数量的子目录</li></ul></li><li>ISO 9660 是一个 CD-ROM 标准</li><li>FAT 文件系统 (msdos, vfat, umsdos)</li><li>HFS+ (hfsplus) - Apple 的文件系统</li></ul><h3 id="_4-2-2-creating-a-filesystem" tabindex="-1"><a class="header-anchor" href="#_4-2-2-creating-a-filesystem"><span>4.2.2 Creating a Filesystem</span></a></h3><p>在用户空间中为设备创建文件系统，因为用户空间可以直接访问 block device。</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">mkfs</span> <span class="token parameter variable">-t</span> ext4 /dev/sdf2</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Superblock 是文件系统数据库的核心组件。<code>mkfs</code> 为 superblock 创建了多个备份，防止原先的那个被破坏。<code>mkfs</code> 只是一系列文件系统创建程序的前端：</p><ul><li><code>mkfs.fs</code> - <code>fs</code> 是文件系统类型</li><li><code>mkfs.ext4</code> ...</li><li><code>mkfs.ext4</code> 是 <code>mke2fs</code> 的符号链接</li></ul><h3 id="_4-2-3-mounting-a-filesystem" tabindex="-1"><a class="header-anchor" href="#_4-2-3-mounting-a-filesystem"><span>4.2.3 Mounting a FIlesystem</span></a></h3><p>在 Unix 中，挂载一个文件系统的过程叫做 mounting。当系统启动时，内核读取一些配置信息，并基于配置信息挂载 root 根目录 (<code>/</code>)。为了挂载一个文件系统 - <em>mount a device on a mount point</em>：</p><ul><li>文件系统的设备 - 比如一个磁盘分区</li><li>文件系统的类型</li><li>挂载点 - 文件系统被关联到目前系统目录中的位置，是一个普通的目录</li></ul><p>运行 <code>mount</code> 命令可以查看目前的文件系统状态：</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ mount</span>
<span class="line">rootfs on / type lxfs (rw,noatime)</span>
<span class="line">none on /dev type tmpfs (rw,noatime,mode=755)</span>
<span class="line">sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,noatime)</span>
<span class="line">proc on /proc type proc (rw,nosuid,nodev,noexec,noatime)</span>
<span class="line">devpts on /dev/pts type devpts (rw,nosuid,noexec,noatime,gid=5,mode=620)</span>
<span class="line">none on /run type tmpfs (rw,nosuid,noexec,noatime,mode=755)</span>
<span class="line">none on /run/lock type tmpfs (rw,nosuid,nodev,noexec,noatime)</span>
<span class="line">none on /run/shm type tmpfs (rw,nosuid,nodev,noatime)</span>
<span class="line">none on /run/user type tmpfs (rw,nosuid,nodev,noexec,noatime,mode=755)</span>
<span class="line">binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,noatime)</span>
<span class="line">C: on /mnt/c type drvfs (rw,noatime,uid=1000,gid=1000,case=off)</span>
<span class="line">D: on /mnt/d type drvfs (rw,noatime,uid=1000,gid=1000,case=off)</span>
<span class="line">F: on /mnt/f type drvfs (rw,noatime,uid=1000,gid=1000,case=off)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每行的参数含义：</p><ul><li>带有文件系统的设备（不一定是一个真实存在的设备）</li><li>&quot;on&quot;</li><li>挂载点（一个目录）</li><li>&quot;type&quot;</li><li>文件系统类型</li><li>挂载选项</li></ul><p>为了挂载一个文件系统：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">mount</span> <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>fs_type<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>device<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>mount_point<span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>取消挂载：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">umount</span> <span class="token operator">&lt;</span>mount_point<span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_4-2-4-filesystem-uuid" tabindex="-1"><a class="header-anchor" href="#_4-2-4-filesystem-uuid"><span>4.2.4 Filesystem UUID</span></a></h3><p>挂载文件系统基于设备名。而设备名会根据内核找到设备的顺序而改变。因此，可以通过文件系统的 UUID (Universally Unique Identifier) 来挂载：</p><ul><li>是一种软件标准，是一种序列号</li><li><code>mke2fs</code> 等文件系统创建程序会在初始化文件系统数据结构时生成 UUID</li></ul><p>可以通过 <code>blkid</code> 命令查看所有的设备、文件系统和 UUID：</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ blkid</span>
<span class="line">/dev/vda1: UUID=&quot;59d9ca7b-4f39-4c0c-9334-c56c182076b5&quot; TYPE=&quot;ext4&quot;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>那么，就可以使用 UUID 来挂载文件系统了：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">mount</span> <span class="token assign-left variable">UUID</span><span class="token operator">=</span><span class="token operator">&lt;</span>UUID<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>mount_point<span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_4-2-5-disk-buffering-caching-and-filesystems" tabindex="-1"><a class="header-anchor" href="#_4-2-5-disk-buffering-caching-and-filesystems"><span>4.2.5 Disk Buffering, Caching, and Filesystems</span></a></h3><p>Linux 和其它 Unix 版本类似，会使用缓冲区写入磁盘</p><ul><li>在处理变化请求时，内核不会立刻向文件系统写入变化</li><li>而是在 RAM 中存储变化，直到内核真正向磁盘写入变化</li><li>这一过程对用户透明</li></ul><p>当 unmount 时，内核自动将缓冲区同步到磁盘。在其它时候，通过 <code>sync</code> 命令也可以使内核强制将修改写入磁盘。此外，内核有一系列机制使用 RAM 自动缓存从磁盘中读取的 disk。这样，如果一个或多个进程重复访问一个文件，内核不需要反复从磁盘中读取，节省时间和资源。</p><h3 id="_4-2-6-filesystem-mount-options" tabindex="-1"><a class="header-anchor" href="#_4-2-6-filesystem-mount-options"><span>4.2.6 Filesystem Mount Options</span></a></h3><h3 id="_4-2-7-remounting-a-filesystem" tabindex="-1"><a class="header-anchor" href="#_4-2-7-remounting-a-filesystem"><span>4.2.7 Remounting a Filesystem</span></a></h3><h3 id="_4-2-8-the-etc-fstab-filesystem-table" tabindex="-1"><a class="header-anchor" href="#_4-2-8-the-etc-fstab-filesystem-table"><span>4.2.8 The /etc/fstab Filesystem Table</span></a></h3><p>为了在系统启动时挂载文件系统，Linux 系统在 <code>/etc/fstab</code> 中维护一个持久性的文件系统及其选项列表。</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ cat /etc/fstab</span>
<span class="line">UUID=59d9ca7b-4f39-4c0c-9334-c56c182076b5 /                       ext4    defaults        1 1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>每一行代表一个文件系统，被分为 6 个部分：</p><ul><li>Device or UUID - 目前大部分 Linux 系统中已经开始使用 UUID</li><li>挂载点</li><li>文件系统类型</li><li>选项</li><li>Backup information for use by the dump command</li><li>文件系统完整性测试顺序 <ul><li><code>1</code> - root 文件系统</li><li><code>2</code> - 其它文件系统</li><li><code>0</code> - 禁止检查 <ul><li>包括 swap、proc 文件系统</li></ul></li></ul></li></ul><h3 id="_4-2-9-alternatives-to-etc-fstab" tabindex="-1"><a class="header-anchor" href="#_4-2-9-alternatives-to-etc-fstab"><span>4.2.9 Alternatives to /etc/fstab</span></a></h3><h3 id="_4-2-10-filesystem-capacity" tabindex="-1"><a class="header-anchor" href="#_4-2-10-filesystem-capacity"><span>4.2.10 Filesystem Capacity</span></a></h3><p>查看目前绑定的文件系统的 size 和利用率：</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ df</span>
<span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span>
<span class="line">/dev/vda1       41151808 4893668  34144708  13% /</span>
<span class="line">devtmpfs          932488       0    932488   0% /dev</span>
<span class="line">tmpfs             941860       0    941860   0% /dev/shm</span>
<span class="line">tmpfs             941860     384    941476   1% /run</span>
<span class="line">tmpfs             941860       0    941860   0% /sys/fs/cgroup</span>
<span class="line">tmpfs             188376       0    188376   0% /run/user/0</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Filesystem - 文件系统设备</li><li>1K-blocks - 以 1KB 的块为单位的文件系统容量</li><li>User - 已被使用的块数量</li><li>Available - 空余的块数量</li><li>Capacity - 正在被使用的块的百分比</li><li>Mounted on - 挂载点</li></ul><p>有一些空间被隐藏，作为 <em>reserved blocks</em>。只有超级用户可以使用所有的文件系统空间，这一特性可以防止系统服务在用尽磁盘空间后出错。</p><p><code>du</code> 命令可以从当前目录开始输出每个目录的磁盘使用量。<code>du -s</code> 只打印 summary。</p><h3 id="_4-2-11-checking-and-repairing-filesystems" tabindex="-1"><a class="header-anchor" href="#_4-2-11-checking-and-repairing-filesystems"><span>4.2.11 Checking and Repairing Filesystems</span></a></h3><p>Unix 的文件系统优化是由专用的数据库机制完成的，内核必须相信已挂载的文件系统中没有任何错误。如果存在错误，那么将会发生数据丢失和系统崩溃。</p><p>文件系统错误通常由用户强制关闭系统导致，在这种情况下，文件系统在内存中的缓存与磁盘不一致。<code>fsck</code> 是用于检查文件系统的工具，对于 <code>fsck</code> 有针对不同文件系统的不同版本。只需要给定设备文件或者挂载点：</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ fsck /dev/sdb1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>fsck</code> 会进行 5 个 passes：</p><ul><li>Pass 1: Checking inodes, blocks, and sizes</li><li>Pass 2: Checking directory structure</li><li>Pass 3: Checking directory connectivity</li><li>Pass 4: Checking reference counts</li><li>Pass 5: Checking group summary information ...</li></ul><p>如果 <code>fsck</code> 发现了错误，会停止并询问是否要修复错误。修复改动的是文件系统的内部结构，仅对于 ext2 文件系统。对于 ext3、ext4 文件系统，不需手动检测 - 因为有机制能够保证文件系统的完整性。</p><h3 id="_4-2-12-special-purpose-filesystems" tabindex="-1"><a class="header-anchor" href="#_4-2-12-special-purpose-filesystems"><span>4.2.12 Special-Purpose Filesystems</span></a></h3><p>不是所有的文件系统都代表了物理存储空间，大部分 Unix 版本包含了作为系统接口的文件系统。一些文件系统可以代表系统信息。Linux 中的专用文件系统包含：</p><ul><li>proc <ul><li>挂载于 <code>/proc</code> (process)</li><li><code>/proc</code> 目录下的每一个数值目录都是系统中目前进程的 PID</li><li><code>/proc/self</code> 代表了当前进程</li><li>Linux proc 文件系统包含了大量额外的内核和硬件信息，如 <code>/proc/cpuinfo</code></li></ul></li><li>sysfs <ul><li>挂载于 <code>/sys</code></li></ul></li><li>tmpfs <ul><li>挂载于 <code>/run</code> 和其它位置</li><li>使用物理内存和交换空间作为暂存区</li></ul></li></ul><hr>`,63)]))}const d=s(a,[["render",t],["__file","Chapter 4.2 - Filesystems.html.vue"]]),p=JSON.parse('{"path":"/how-linux-works-notes/Chapter%204.2%20-%20Filesystems.html","title":"Chapter 4.2 - Filesystems","lang":"en-US","frontmatter":{},"headers":[{"level":3,"title":"4.2.1 Filesystem Types","slug":"_4-2-1-filesystem-types","link":"#_4-2-1-filesystem-types","children":[]},{"level":3,"title":"4.2.2 Creating a Filesystem","slug":"_4-2-2-creating-a-filesystem","link":"#_4-2-2-creating-a-filesystem","children":[]},{"level":3,"title":"4.2.3 Mounting a FIlesystem","slug":"_4-2-3-mounting-a-filesystem","link":"#_4-2-3-mounting-a-filesystem","children":[]},{"level":3,"title":"4.2.4 Filesystem UUID","slug":"_4-2-4-filesystem-uuid","link":"#_4-2-4-filesystem-uuid","children":[]},{"level":3,"title":"4.2.5 Disk Buffering, Caching, and Filesystems","slug":"_4-2-5-disk-buffering-caching-and-filesystems","link":"#_4-2-5-disk-buffering-caching-and-filesystems","children":[]},{"level":3,"title":"4.2.6 Filesystem Mount Options","slug":"_4-2-6-filesystem-mount-options","link":"#_4-2-6-filesystem-mount-options","children":[]},{"level":3,"title":"4.2.7 Remounting a Filesystem","slug":"_4-2-7-remounting-a-filesystem","link":"#_4-2-7-remounting-a-filesystem","children":[]},{"level":3,"title":"4.2.8 The /etc/fstab Filesystem Table","slug":"_4-2-8-the-etc-fstab-filesystem-table","link":"#_4-2-8-the-etc-fstab-filesystem-table","children":[]},{"level":3,"title":"4.2.9 Alternatives to /etc/fstab","slug":"_4-2-9-alternatives-to-etc-fstab","link":"#_4-2-9-alternatives-to-etc-fstab","children":[]},{"level":3,"title":"4.2.10 Filesystem Capacity","slug":"_4-2-10-filesystem-capacity","link":"#_4-2-10-filesystem-capacity","children":[]},{"level":3,"title":"4.2.11 Checking and Repairing Filesystems","slug":"_4-2-11-checking-and-repairing-filesystems","link":"#_4-2-11-checking-and-repairing-filesystems","children":[]},{"level":3,"title":"4.2.12 Special-Purpose Filesystems","slug":"_4-2-12-special-purpose-filesystems","link":"#_4-2-12-special-purpose-filesystems","children":[]}],"git":{},"filePathRelative":"how-linux-works-notes/Chapter 4.2 - Filesystems.md"}');export{d as comp,p as data};
