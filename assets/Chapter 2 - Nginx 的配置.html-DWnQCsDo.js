import{_ as n,c as s,a,o as i}from"./app-7eKjwDat.js";const l={};function o(d,e){return i(),s("div",null,e[0]||(e[0]=[a(`<h1 id="chapter-2-nginx-的配置" tabindex="-1"><a class="header-anchor" href="#chapter-2-nginx-的配置"><span>Chapter 2 - Nginx 的配置</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 07 / 16 23:07</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="_2-1-nginx-进程之间的关系" tabindex="-1"><a class="header-anchor" href="#_2-1-nginx-进程之间的关系"><span>2.1 Nginx 进程之间的关系</span></a></h2><p>Nginx 使用一个 master 进程来管理多个 worker 进程。一般情况下，worker 进程与 CPU 核心数相等。每个 worker 进程用于提供互联网服务，master 进程只负责监控管理 worker 进程。Worker 进程之间通过 <strong>共享内存</strong>、<strong>原子操作</strong> 等进程间通信机制来实现 <strong>负载均衡</strong> 的功能。Master-worker 方式配置的好处：</p><ol><li>Master 进程不服务用户，仅用于管理 worker 进程，因此可以是唯一的，运行在较高的权限上 (通常用 root 启动 master 进程)，且当 worker coredump 时，master 可以立刻启动新的 worker 进程继续服务</li><li>多个 worker 进程可以提高服务的 <strong>健壮性</strong> (一个挂了其它还能工作)，并且充分利用了 SMP 多核架构，实现真正的多核并行</li></ol><p>Nginx 把 worker 进程数设置为与 CPU 核心数相同的原因：Apache 每个进程对应一个连接，并发量提高后，就有了大量的进程，上下文切换代价高；Nginx 的一个 worker 进程同时可以处理的请求数 <strong>理论上仅受限于内存大小</strong>，worker 进程通常不会进入睡眠状态。因此，worker 进程数与 CPU core 数量相等时 (且每个进程绑定一个 core)，上下文切换代价最小。</p><hr><h2 id="_2-2-nginx-配置项语法" tabindex="-1"><a class="header-anchor" href="#_2-2-nginx-配置项语法"><span>2.2 Nginx 配置项语法</span></a></h2><h3 id="_2-2-1-块配置项" tabindex="-1"><a class="header-anchor" href="#_2-2-1-块配置项"><span>2.2.1 块配置项</span></a></h3><div class="language-nginx line-numbers-mode" data-highlighter="prismjs" data-ext="nginx" data-title="nginx"><pre><code><span class="line"><span class="token directive"><span class="token keyword">events</span></span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token directive"><span class="token keyword">http</span></span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token directive"><span class="token keyword">upstream</span> backend</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token directive"><span class="token keyword">server</span> 127.0.0.1:8080</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token directive"><span class="token keyword">gzip</span> <span class="token boolean">on</span></span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span></span>
<span class="line">        ...</span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-2-2-配置项" tabindex="-1"><a class="header-anchor" href="#_2-2-2-配置项"><span>2.2.2 配置项</span></a></h3><div class="language-nginx line-numbers-mode" data-highlighter="prismjs" data-ext="nginx" data-title="nginx"><pre><code><span class="line"><span class="token directive"><span class="token keyword">name</span> var var ...</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_2-2-3-注释" tabindex="-1"><a class="header-anchor" href="#_2-2-3-注释"><span>2.2.3 注释</span></a></h3><div class="language-nginx line-numbers-mode" data-highlighter="prismjs" data-ext="nginx" data-title="nginx"><pre><code><span class="line"><span class="token comment"># pid logs/nginx.pid;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_2-2-4-单位" tabindex="-1"><a class="header-anchor" href="#_2-2-4-单位"><span>2.2.4 单位</span></a></h3><ul><li>当指定空间大小时 - <code>k</code> / <code>K</code> 和 <code>m</code> / <code>M</code> 分别对应 KB 和 MB</li><li>当指定时间大小时 - <code>ms</code> / <code>s</code> / <code>m</code> / <code>h</code> / <code>d</code> / <code>w</code> / <code>M</code> / <code>y</code></li></ul><hr><h2 id="_2-3-nginx-服务的基本配置" tabindex="-1"><a class="header-anchor" href="#_2-3-nginx-服务的基本配置"><span>2.3 Nginx 服务的基本配置</span></a></h2><p>Nginx 运行时必须加载几个核心模块和一个事件类模块。这些模块运行时所使用的配置项称为基本配置项。主要分为四类：</p><ul><li>用于调试、定位问题的配置项</li><li>正常运行的必备配置项</li><li>优化性能的配置项</li><li>事件类配置项</li></ul><h3 id="_2-3-1-调试、问题定位的配置项" tabindex="-1"><a class="header-anchor" href="#_2-3-1-调试、问题定位的配置项"><span>2.3.1 调试、问题定位的配置项</span></a></h3><ul><li><code>daemon on | off;</code> - 默认以守护进程模式运行，进程不会被任何终端产生的信号打断</li><li><code>master_process on | off;</code> - master 进程是否 fork 出 worker 进程来处理请求</li><li><code>error_log /path/file level;</code> - error 日志的位置和输出级别</li><li><code>debug_points [stop | abort]</code> - 是否处理特殊调试点</li><li><code>debug_connection [IP | CIDR]</code> - 仅对指定客户端输出 debug 级别日志</li><li><code>worker_rlimit_core size;</code> - 限制 coredump 核心转储文件大小</li><li><code>working_directory path;</code> - worker 进程的工作目录，也是 coredump 文件生成的位置</li></ul><h3 id="_2-3-2-正常运行的配置项" tabindex="-1"><a class="header-anchor" href="#_2-3-2-正常运行的配置项"><span>2.3.2 正常运行的配置项</span></a></h3><ul><li>定义环境变量</li><li>Import 其它配置文件</li><li>Pid 文件路径 (保存 master 进程 pid 的文件路径)</li><li>Worker 进程运行的用户及用户组</li><li>Worker 进程可以打开的最大句柄描述符个数</li></ul><h3 id="_2-3-3-优化性能的配置项" tabindex="-1"><a class="header-anchor" href="#_2-3-3-优化性能的配置项"><span>2.3.3. 优化性能的配置项</span></a></h3><ul><li>Worker 进程个数</li><li>绑定 worker 进程到 CPU core</li><li>SSL 硬件加速 (如果有)</li><li>Worker 进程优先级 (<code>nice</code> 值)</li></ul><h3 id="_2-3-4-事件类的配置项" tabindex="-1"><a class="header-anchor" href="#_2-3-4-事件类的配置项"><span>2.3.4 事件类的配置项</span></a></h3><ul><li><code>accept_mutex [on | off];</code> - 是否打开负载均衡锁，可以使多个 worker 进程轮流、序列化地与新的客户端建立连接</li><li><code>lock_file path/file;</code> - 在负载均衡锁开启之后，且 OS 不支持原子锁，那么使用该文件实现负载均衡锁</li><li><code>accept_mutex_delay Nms;</code> - 负载均衡锁的获取是非阻塞的，如果取不到则立刻返回，至少等一段时间以后才能再次获得锁</li><li><code>multi_accept [on | off];</code> - 批量建立新连接</li><li><code>use [kqueue | rtsig | epoll | /dev/poll | select | poll | eventport];</code> - 默认选择性能最高的事件模型</li><li><code>worker_connections number;</code> - 每个 worker 进程可以同时处理的最大连接数</li></ul><h2 id="_2-4-用-http-核心模块配置一个静态-web-服务器" tabindex="-1"><a class="header-anchor" href="#_2-4-用-http-核心模块配置一个静态-web-服务器"><span>2.4 用 HTTP 核心模块配置一个静态 Web 服务器</span></a></h2><p>静态 Web 服务器由 <code>ngx_http_core_module</code> 模块实现。</p><h3 id="_2-4-1-虚拟主机与请求的分发" tabindex="-1"><a class="header-anchor" href="#_2-4-1-虚拟主机与请求的分发"><span>2.4.1 虚拟主机与请求的分发</span></a></h3><p>IP 地址数量有限，多个 hostname 可能会映射到同一个 IP 地址。那么可以使用 <code>server</code> 块来定义 <strong>虚拟主机</strong>，每个虚拟主机只处理与之相对应的 hostname 请求。这样 Nginx 可以以不同的方式处理访问不同 hostname 的 HTTP 请求了。</p><ul><li><code>listen address:port [...];</code> - 监听端口</li><li><code>server_name name [...];</code> - Nginx 会从 HTTP header 中取出 host，与配置中的 <code>server_name</code> 进行匹配</li><li><code>server_names_hash_bucket_size</code> - 为快速寻找 <code>server_name</code>，Nginx 用 hash map 存储 <code>server_name</code>，此配置用于配置桶大小</li><li><code>server_names_hash_max_size</code> - 影响 hash map 的冲突率与内存占用 (此消彼长)</li><li><code>server_name_in_redirect on | off;</code> - 配合 <code>server_name</code> 使用，重定向请求使用其中的第一个 hostname 代替原请求中的 Host header</li><li><code>location [] /uri {...}</code> - 根据用户请求中的 URI 来匹配 (多种匹配方式)，并使用 <code>{}</code> 中的逻辑处理请求</li></ul><h3 id="_2-4-2-文件路径的定义" tabindex="-1"><a class="header-anchor" href="#_2-4-2-文件路径的定义"><span>2.4.2 文件路径的定义</span></a></h3><ul><li><code>root path;</code> - 定义资源文件相对于 HTTP 请求的根目录</li><li><code>alias path;</code> - 同上，但不包含 <code>location</code> 中已配置的路径</li><li><code>index file ...;</code> - 访问首页，按文件依次查看可用性</li><li><code>error_page code [] uri | @named_location;</code> - 根据 HTTP 响应码重定向页面</li><li><code>recursive_error_pages [on | off];</code> - 是否允许递归使用 <code>error_page</code></li><li><code>try_files path1 [path2] uri;</code> - 依次访问文件，直到能够读取一个有效的文件</li></ul><h3 id="_2-4-3-内存及磁盘资源的分配" tabindex="-1"><a class="header-anchor" href="#_2-4-3-内存及磁盘资源的分配"><span>2.4.3 内存及磁盘资源的分配</span></a></h3><ul><li><code>client_body_in_file_only on | clean | off;</code> - HTTP 报文是否储存在文件中 (请求结束后是否清除)</li><li><code>client_body_in_single_buffer on | off;</code> - HTTP 报文一律存储到内存 buffer 中</li><li>存储 HTTP header 的内存 buffer 大小</li><li>存储超大 HTTP header 的内存 buffer 大小</li><li>存储 HTTP body 的内存 buffer 大小</li><li>HTTP 报文的临时存放目录</li><li><code>connection_pool_size</code> - Nginx 为每个建立成功的 TCP 连接预先分配的内存池的初始大小 (减少内核对小块内存的分配次数)，TCP 连接关闭后销毁</li><li><code>request_pool_size</code> - Nginx 为每个 HTTP 请求分配的内存池初始大小 (请求结束时销毁)</li></ul><h3 id="_2-4-4-网络连接的设置" tabindex="-1"><a class="header-anchor" href="#_2-4-4-网络连接的设置"><span>2.4.4 网络连接的设置</span></a></h3><ul><li>读取 HTTP header 的超时时间</li><li>读取 HTTP body 的超时时间</li><li>发送响应的超时时间</li><li>连接超时后向客户端发送 <code>RST</code> 来重置连接 (不使用正常的 TCP 四次握手关闭连接)</li><li>Nginx 关闭用户连接的方式</li><li>Keep-alive 相关</li></ul><h3 id="_2-4-5-mime-类型的设置" tabindex="-1"><a class="header-anchor" href="#_2-4-5-mime-类型的设置"><span>2.4.5 MIME 类型的设置</span></a></h3><h3 id="_2-4-6-对客户端请求的限制" tabindex="-1"><a class="header-anchor" href="#_2-4-6-对客户端请求的限制"><span>2.4.6 对客户端请求的限制</span></a></h3><ul><li><code>limit_except method ... {...}</code> - 按 HTTP method 来限制用户请求</li><li>HTTP body 的最大值</li><li>对请求的限速</li></ul><h3 id="_2-4-7-文件操作的优化" tabindex="-1"><a class="header-anchor" href="#_2-4-7-文件操作的优化"><span>2.4.7 文件操作的优化</span></a></h3><ul><li><code>sendfile on | off;</code> - 启用 Linux 上的 <code>sendfile</code> 系统调用发送文件，减少内核态与用户态之间的两次内存复制 (磁盘直接从内核态到达网卡)</li><li><code>aio on | off;</code> - 是否开启异步文件 I/O (与 <code>sendfile</code> 互斥)</li><li>directio (?)</li><li>打开文件缓存，在内存中存储以下信息，减少对磁盘的操作： <ul><li>文件句柄、文件大小、上次修改时间</li><li>已经打开过的目录</li><li>没有找到或没有权限操作的文件信息</li></ul></li><li>是否在文件缓存中缓存打开文件错误的信息</li></ul><h3 id="_2-4-8-对客户端请求的特殊处理" tabindex="-1"><a class="header-anchor" href="#_2-4-8-对客户端请求的特殊处理"><span>2.4.8 对客户端请求的特殊处理</span></a></h3><ul><li>不合法的 HTTP header</li><li>DNS</li><li>...</li></ul><hr><h2 id="_2-5-用-http-proxy-module-配置一个反向代理服务器" tabindex="-1"><a class="header-anchor" href="#_2-5-用-http-proxy-module-配置一个反向代理服务器"><span>2.5 用 HTTP Proxy Module 配置一个反向代理服务器</span></a></h2><p>反向代理 (Reverse Proxy) 指用 <strong>代理服务器</strong> 来接收 Internet 上的请求，然后转发给 <strong>内部网络</strong> 中的 <strong>上游服务器</strong>，并将上游服务器的结果返回给 Internet 上的客户端。由于 Nginx 能够处理大量并发请求，因此经常被充当为反向代理。</p><p>Nginx 的高并发能力使得其可以作为前端服务器直接向客户端提供 <strong>静态文件服务</strong>。有一些复杂、多变的业务不适合放到 Nginx 上，需要 Apache、Tomcat 等服务器来处理。Nginx 通常会被配置为既是静态服务器又是反向代理服务器。不适合 Nginx 处理的请求会被转发到上游服务器上。</p><p>与其它反向代理服务器 <em>Squid</em> 的区别：</p><ul><li>Nginx 会将客户端的 HTTP 请求完整接收到服务器的内存或磁盘中后，再向上游服务器发起连接</li><li>Squid 一边接收客户端请求，一边转发到上游服务器</li></ul><p>Nginx 显然会延长请求的处理时间，增加了服务器上的内存与磁盘空间的消耗量；但是降低了上游服务器的负载，背负了尽可能多的压力。因为客户端到 Nginx 通常走公网，速度慢；而 Nginx 到上游服务器一般走内网，速度快。如果类似 Squid，一收到请求就立刻开始向上游服务器转发，那么上游服务器需要始终维持这个连接，对上游服务器的并发能力提出了挑战。而对 Nginx 来说，转发过程会占用上游服务器尽可能短的时间，降低了上游服务器的并发压力。</p><h3 id="_2-5-1-负载均衡的基本配置" tabindex="-1"><a class="header-anchor" href="#_2-5-1-负载均衡的基本配置"><span>2.5.1 负载均衡的基本配置</span></a></h3><p>由 <code>upstream</code> 块定义一个上游服务器集群，由 <code>proxy_pass</code> 使用：</p><div class="language-nginx line-numbers-mode" data-highlighter="prismjs" data-ext="nginx" data-title="nginx"><pre><code><span class="line"><span class="token directive"><span class="token keyword">upstream</span> backend</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token directive"><span class="token keyword">ip_hash</span></span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token directive"><span class="token keyword">server</span> backend1.example.com</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token directive"><span class="token keyword">server</span> backend2.example.com</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token directive"><span class="token keyword">server</span> backend3.example.com</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token directive"><span class="token keyword">proxy_pass</span> http://backend</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外，有时想要使一个用户的请求始终落到同一台上游服务器上，防止同一个用户的数据在多台上游服务器上存在，造成资源的浪费。那么可以使用 <code>ip_hash</code> 为用户的 IP 地址进行 hash，然后对上游集群取模，映射到某一台上游服务器上。</p><h3 id="_2-5-2-反向代理的基本配置" tabindex="-1"><a class="header-anchor" href="#_2-5-2-反向代理的基本配置"><span>2.5.2 反向代理的基本配置</span></a></h3><ul><li><code>proxy_pass URL;</code> - 直接指定 Nginx 代理的上游服务器 URL，或一个 <code>upstream</code> 块</li><li><code>proxy_method method;</code> - 根据 HTTP method 来进行转发</li><li><code>proxy_hide_header header;</code> - 指定哪些 HTTP header 不被 Nginx 转发</li><li><code>proxy_pass_header header;</code> - 与上一项相反</li><li><code>proxy_pass_request_body on | off</code> / <code>proxy_pass_request_headers on | off</code> - 是否转发 HTTP body / header</li><li><code>proxy_redirect [default | off | redirect];</code> - 重设上游服务器给出的重定向或刷新请求中 HTTP header 中的 <code>location</code> 或 <code>refresh</code></li><li><code>proxy_next_upstream [error | timeout | ...];</code> - 如果转发到上游服务器的过程中发生指定错误，那么换一台上游服务器处理请求</li></ul>`,62)]))}const r=n(l,[["render",o],["__file","Chapter 2 - Nginx 的配置.html.vue"]]),t=JSON.parse('{"path":"/understanding-nginx-notes/Part%201%20-%20Nginx%20%E8%83%BD%E5%B8%AE%E6%88%91%E4%BB%AC%E5%81%9A%E4%BB%80%E4%B9%88/Chapter%202%20-%20Nginx%20%E7%9A%84%E9%85%8D%E7%BD%AE.html","title":"Chapter 2 - Nginx 的配置","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"2.1 Nginx 进程之间的关系","slug":"_2-1-nginx-进程之间的关系","link":"#_2-1-nginx-进程之间的关系","children":[]},{"level":2,"title":"2.2 Nginx 配置项语法","slug":"_2-2-nginx-配置项语法","link":"#_2-2-nginx-配置项语法","children":[{"level":3,"title":"2.2.1 块配置项","slug":"_2-2-1-块配置项","link":"#_2-2-1-块配置项","children":[]},{"level":3,"title":"2.2.2 配置项","slug":"_2-2-2-配置项","link":"#_2-2-2-配置项","children":[]},{"level":3,"title":"2.2.3 注释","slug":"_2-2-3-注释","link":"#_2-2-3-注释","children":[]},{"level":3,"title":"2.2.4 单位","slug":"_2-2-4-单位","link":"#_2-2-4-单位","children":[]}]},{"level":2,"title":"2.3 Nginx 服务的基本配置","slug":"_2-3-nginx-服务的基本配置","link":"#_2-3-nginx-服务的基本配置","children":[{"level":3,"title":"2.3.1 调试、问题定位的配置项","slug":"_2-3-1-调试、问题定位的配置项","link":"#_2-3-1-调试、问题定位的配置项","children":[]},{"level":3,"title":"2.3.2 正常运行的配置项","slug":"_2-3-2-正常运行的配置项","link":"#_2-3-2-正常运行的配置项","children":[]},{"level":3,"title":"2.3.3. 优化性能的配置项","slug":"_2-3-3-优化性能的配置项","link":"#_2-3-3-优化性能的配置项","children":[]},{"level":3,"title":"2.3.4 事件类的配置项","slug":"_2-3-4-事件类的配置项","link":"#_2-3-4-事件类的配置项","children":[]}]},{"level":2,"title":"2.4 用 HTTP 核心模块配置一个静态 Web 服务器","slug":"_2-4-用-http-核心模块配置一个静态-web-服务器","link":"#_2-4-用-http-核心模块配置一个静态-web-服务器","children":[{"level":3,"title":"2.4.1 虚拟主机与请求的分发","slug":"_2-4-1-虚拟主机与请求的分发","link":"#_2-4-1-虚拟主机与请求的分发","children":[]},{"level":3,"title":"2.4.2 文件路径的定义","slug":"_2-4-2-文件路径的定义","link":"#_2-4-2-文件路径的定义","children":[]},{"level":3,"title":"2.4.3 内存及磁盘资源的分配","slug":"_2-4-3-内存及磁盘资源的分配","link":"#_2-4-3-内存及磁盘资源的分配","children":[]},{"level":3,"title":"2.4.4 网络连接的设置","slug":"_2-4-4-网络连接的设置","link":"#_2-4-4-网络连接的设置","children":[]},{"level":3,"title":"2.4.5 MIME 类型的设置","slug":"_2-4-5-mime-类型的设置","link":"#_2-4-5-mime-类型的设置","children":[]},{"level":3,"title":"2.4.6 对客户端请求的限制","slug":"_2-4-6-对客户端请求的限制","link":"#_2-4-6-对客户端请求的限制","children":[]},{"level":3,"title":"2.4.7 文件操作的优化","slug":"_2-4-7-文件操作的优化","link":"#_2-4-7-文件操作的优化","children":[]},{"level":3,"title":"2.4.8 对客户端请求的特殊处理","slug":"_2-4-8-对客户端请求的特殊处理","link":"#_2-4-8-对客户端请求的特殊处理","children":[]}]},{"level":2,"title":"2.5 用 HTTP Proxy Module 配置一个反向代理服务器","slug":"_2-5-用-http-proxy-module-配置一个反向代理服务器","link":"#_2-5-用-http-proxy-module-配置一个反向代理服务器","children":[{"level":3,"title":"2.5.1 负载均衡的基本配置","slug":"_2-5-1-负载均衡的基本配置","link":"#_2-5-1-负载均衡的基本配置","children":[]},{"level":3,"title":"2.5.2 反向代理的基本配置","slug":"_2-5-2-反向代理的基本配置","link":"#_2-5-2-反向代理的基本配置","children":[]}]}],"git":{},"filePathRelative":"understanding-nginx-notes/Part 1 - Nginx 能帮我们做什么/Chapter 2 - Nginx 的配置.md"}');export{r as comp,t as data};
