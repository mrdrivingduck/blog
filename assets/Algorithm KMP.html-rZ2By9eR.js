import{_ as s,c as a,a as e,o as p}from"./app-7eKjwDat.js";const t={};function l(c,n){return p(),a("div",null,n[0]||(n[0]=[e(`<h1 id="algorithm-kmp" tabindex="-1"><a class="header-anchor" href="#algorithm-kmp"><span>Algorithm - KMP</span></a></h1><p>Created by : Mr Dk.</p><p>2021 / 03 / 13 23:51</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="about" tabindex="-1"><a class="header-anchor" href="#about"><span>About</span></a></h2><p>为了准备面试，逼自己看了之前一直都没看懂的 KMP 算法。现在大致看懂了思想，但是有一个小点还是没有懂。。。我好笨 😭</p><p><em>Knuth-Morris-Pratt (KMP)</em> 字符串查找算法用于在一个主字符串 <code>S</code> 中查找一个模板串 <code>W</code> 出现的位置，由三位大神于 1977 年联合发表，并用三人的名字共同命名。其特性是能够在匹配期间确定下一个匹配可能开始的位置，从而避免重新检查之前匹配的字符。</p><h2 id="brute-force" tabindex="-1"><a class="header-anchor" href="#brute-force"><span>Brute-Force</span></a></h2><p>暴力匹配字符串法其实很简单。从主字符串开头开始，与模板串的开头比较。一旦遇到不匹配的字符，则从主字符串开始匹配位置的下一个位置起，与模板串开头重新比较。示意如下：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">      i</span>
<span class="line">      |</span>
<span class="line">ABCDABCABCDABD</span>
<span class="line">ABCDABD</span>
<span class="line">      |</span>
<span class="line">      j</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两个字符串从开头开始匹配，匹配到第 7 个字符时失配。于是，下一轮匹配从如下位置开始：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line"> i</span>
<span class="line"> |</span>
<span class="line">ABCDABCABCDABD</span>
<span class="line"> ABCDABD</span>
<span class="line"> |</span>
<span class="line"> j</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，<code>i</code> 和 <code>j</code> 指针都做了一次回溯。</p><h2 id="kmp" tabindex="-1"><a class="header-anchor" href="#kmp"><span>KMP</span></a></h2><p><em>KMP</em> 算法的核心是，让 <code>i</code> 不回溯。在上面的例子中可以看到，<code>ABCDAB</code> 匹配成功，意味着前面的 <code>AB</code> 和后面的 <code>AB</code> 已经匹配成功了。那么下一次开始匹配时，可以直接从模板串的 <code>AB</code> 前缀之后一个位置开始匹配，如下图所示：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">      i</span>
<span class="line">      |</span>
<span class="line">ABCDABCABCDABD</span>
<span class="line">ABCDABD</span>
<span class="line">      |</span>
<span class="line">      j</span>
<span class="line"></span>
<span class="line">      i</span>
<span class="line">      |</span>
<span class="line">ABCDABCABCDABD</span>
<span class="line">    ABCDABD</span>
<span class="line">      |</span>
<span class="line">      j</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的例子可以看到，<code>i</code> 指针没有动，而 <code>j</code> 指针往回滑了几个位置，但也没有滑动到 <code>0</code>。这里根本的原因是，之前匹配成功部分的模板串后缀，与模板串的前缀，有着长度为 <code>2</code> 的相同部分。所以，<em>KMP</em> 算法的核心是，找到模板串每个位置上的 <strong>最长公共前后缀长度</strong>。该长度如果确定，那么每次只需要将 <code>j</code> 指针向左滑动即可。滑动的具体距离为：之前匹配成功的子模板串长度，减去该串的最长公共前后缀长度。在上面的例子中，之前匹配成功的部分为 <code>ABCDAB</code>，最长公共前后缀为 <code>AB</code>，因此滑动距离为 <code>6 - 2 = 4</code>。</p><p>所以，想要进行模式匹配，就需要得到这个通常被称之为是 <code>next[]</code> 的数组。对模板串进行单独处理，得到了这个数组，那么就可以执行如下的算法：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">int</span> <span class="token function">kmp_match</span><span class="token punctuation">(</span>string haystack<span class="token punctuation">,</span> string needle<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> haystack<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> needle<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            i<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line">            j<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">            j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> needle<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> i <span class="token operator">-</span> needle<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，<code>next[0]</code> 的值一定为 <code>-1</code>，其含义为正好可以用如下的例子描述：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">         i</span>
<span class="line">         |</span>
<span class="line">ABCDABCABBCDABDCDA</span>
<span class="line">         ABCDABD</span>
<span class="line">         |</span>
<span class="line">         j</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当主字符串的字符与模板串的第一个字符也无法匹配时，<code>j</code> 指针将会被赋值为 <code>-1</code> (<code>next[0]</code>)，使得在下轮循环中 <code>i</code> 和 <code>j</code> 两个指针分别前进一步，<code>i</code> 指向了主字符串的下一个字符；<code>j</code> 正好也就重新指向了模板串的第一个字符。其含义为，当主字符串和模板串的第一个字符都无法匹配时，不得不强制去匹配主字符串的下一个字符。然而由于代码中 <code>i</code> 指针和 <code>j</code> 指针是同时前进的，所以先提前把 <code>j</code> 指针设置到 <code>0</code> 的前一个位置上去，这样指针前进后就恰好指向了模板串的第一个字符。</p><h2 id="next-array" tabindex="-1"><a class="header-anchor" href="#next-array"><span>Next Array</span></a></h2><p>这个数组的求法真的很让我痛苦。实际上，手写我是写得出的，放到代码里我就是想不通了。</p><p>简单的求法是，先写出模板串每个位置上的最长公共前后缀长度，然后将形成的数组右移一个位置，将最左边空出来的位置填上 <code>-1</code> 就是 <em>KMP</em> 使用的 <code>next</code> 数组了。<code>next</code> 数组的含义为，(当前位置的字符不算)，之前的子串中的最大公共前后缀长度；另外也可以理解为，如果在这个位置发生了失配，<code>j</code> 指针应该移动到的位置的下标，也就是模板串从头开始除去最长公共前缀后的第一个位置。</p><p>至于实现，并没有采用先得到最长公共前后缀长度再移位的做法，而是一步到位得到 <code>next[]</code>。但我暂时还是理解不了代码。</p><blockquote><p>有一种解释是，可以将构造这个数组的过程也看成是匹配：模板串和它的每一个前缀子串的匹配。</p></blockquote><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">get_next_array</span><span class="token punctuation">(</span>string needle<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">next</span><span class="token punctuation">(</span>needle<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> needle<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> needle<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            i<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line">            j<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line">            next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">            j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">return</span> next<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="references" tabindex="-1"><a class="header-anchor" href="#references"><span>References</span></a></h2><p><a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener noreferrer">CSDN - 从头到尾彻底理解 KMP (2014 年 8 月 22 日版)</a></p><p><a href="https://www.zhihu.com/question/21474082/answer/58767627" target="_blank" rel="noopener noreferrer">知乎 - 怎么理解 KMP 算法中的 next 数组？</a></p>`,33)]))}const o=s(t,[["render",l],["__file","Algorithm KMP.html.vue"]]),r=JSON.parse('{"path":"/notes/Algorithm/Algorithm%20KMP.html","title":"Algorithm - KMP","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"About","slug":"about","link":"#about","children":[]},{"level":2,"title":"Brute-Force","slug":"brute-force","link":"#brute-force","children":[]},{"level":2,"title":"KMP","slug":"kmp","link":"#kmp","children":[]},{"level":2,"title":"Next Array","slug":"next-array","link":"#next-array","children":[]},{"level":2,"title":"References","slug":"references","link":"#references","children":[]}],"git":{},"filePathRelative":"notes/Algorithm/Algorithm KMP.md"}');export{o as comp,r as data};
