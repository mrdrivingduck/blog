import{_ as n}from"./5-20-XR9q3PuR.js";import{_ as a,c as e,a as l,o as i}from"./app-7eKjwDat.js";const p="/blog/assets/5-25-CsN4Lvgr.png",t="/blog/assets/5-26-DLzs3JzN.png",c={};function o(d,s){return i(),e("div",null,s[0]||(s[0]=[l(`<h1 id="chapter-5-7-5-9-linux-进程控制-堆栈使用-文件系统" tabindex="-1"><a class="header-anchor" href="#chapter-5-7-5-9-linux-进程控制-堆栈使用-文件系统"><span>Chapter 5.7-5.9 - Linux 进程控制 &amp; 堆栈使用 &amp; 文件系统</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 08 / 06 16:09</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="_5-7-linux-进程控制" tabindex="-1"><a class="header-anchor" href="#_5-7-linux-进程控制"><span>5.7 Linux 进程控制</span></a></h2><p><strong>进程</strong> 是一个执行中的程序实例。利用分时技术，在 Linux 上可以同时运行多个进程，将 CPU 的运行时间划分成一个个规定长度的时间片。对于单 CPU 的机器来说，每个时刻只有一个进程在运行，但由于每个时间片很短，表面上看，好像所有进程在同时运行。在 Linux 0.12 中，系统最多可有 64 个进程同时存在，除第一个进程是人工建立，其余进程都是现有进程调用 <code>fork()</code> 后创建的新进程。</p><p>内核使用 pid 来标识每个进程，每个进程包含：</p><ul><li>可执行的指令代码、数据和堆栈区</li><li>每个进程只能执行自己的代码和访问自己的数据和堆栈区</li></ul><p>Linux 系统中的进程可以在 <strong>内核态</strong> 或 <strong>用户态</strong> 下执行，各自使用独立的内核态堆栈和用户态堆栈。在 Linux 内核中，进程被称作任务，运行在用户空间的程序称作进程。</p><h3 id="_5-7-1-任务数据结构" tabindex="-1"><a class="header-anchor" href="#_5-7-1-任务数据结构"><span>5.7.1 任务数据结构</span></a></h3><p>内核通过进程表对进程进行管理。每个进程在进程表中占有一项，每项是一个 <code>task_struct</code> 任务结构体指针。任务数据结构被称为 <strong>进程控制块 PCB (Process Control Block)</strong> 或 <strong>进程描述符 PD (Processor Descriptor)</strong>，保存用于控制和管理进程的所有信息：进程当前运行状态、信号、进程号、父进程号；运行累计时间、正在使用的文件、局部描述符、TSS 信息等。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">long</span> state<span class="token punctuation">;</span> <span class="token comment">// 任务运行状态</span></span>
<span class="line">    <span class="token keyword">long</span> counter<span class="token punctuation">;</span> <span class="token comment">// 运行时间片计数 (递减)</span></span>
<span class="line">    <span class="token keyword">long</span> priority<span class="token punctuation">;</span> <span class="token comment">// 优先级 (优先级越高，时间片越长)</span></span>
<span class="line">    <span class="token keyword">long</span> signal<span class="token punctuation">;</span> <span class="token comment">// 信号 bitmap</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> sigaction<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 信号执行属性结构</span></span>
<span class="line">    <span class="token keyword">long</span> blocked<span class="token punctuation">;</span> <span class="token comment">// 进程信号屏蔽码</span></span>
<span class="line">    <span class="token keyword">int</span> exit_code<span class="token punctuation">;</span> <span class="token comment">// 任务停止执行后的退出码 (父进程会来取)</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_code<span class="token punctuation">;</span> <span class="token comment">// 代码段地址</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> end_code<span class="token punctuation">;</span> <span class="token comment">// 代码字节长度</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> end_data<span class="token punctuation">;</span> <span class="token comment">// 代码 + 数据字节长度</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> brk<span class="token punctuation">;</span> <span class="token comment">// 总字节长度</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_stack<span class="token punctuation">;</span> <span class="token comment">// 堆栈段地址</span></span>
<span class="line">    <span class="token keyword">long</span> pid<span class="token punctuation">;</span> <span class="token comment">// 进程标识</span></span>
<span class="line">    <span class="token keyword">long</span> pgrp<span class="token punctuation">;</span> <span class="token comment">// 进程组号</span></span>
<span class="line">    <span class="token keyword">long</span> session<span class="token punctuation">;</span> <span class="token comment">// 会话号</span></span>
<span class="line">    <span class="token keyword">long</span> leader<span class="token punctuation">;</span> <span class="token comment">// 会话首领</span></span>
<span class="line">    <span class="token keyword">int</span> groups<span class="token punctuation">[</span>NGROUPS<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 进程所属组号</span></span>
<span class="line">    task_struct <span class="token operator">*</span>p_pptr<span class="token punctuation">;</span> <span class="token comment">// 指向父进程的指针</span></span>
<span class="line">    task_struct <span class="token operator">*</span>p_cptr<span class="token punctuation">;</span> <span class="token comment">// 指向最新子进程的指针</span></span>
<span class="line">    task_struct <span class="token operator">*</span>p_ysptr<span class="token punctuation">;</span> <span class="token comment">// 指向比自己后创建的相邻进程的指针</span></span>
<span class="line">    task_struct <span class="token operator">*</span>p_osptr<span class="token punctuation">;</span> <span class="token comment">// 指向比自己早创建的相邻进程的指针</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> uid<span class="token punctuation">;</span> <span class="token comment">// 用户标识</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> euid<span class="token punctuation">;</span> <span class="token comment">// 有效用户标识</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> suid<span class="token punctuation">;</span> <span class="token comment">// 保存的用户标识</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> gid<span class="token punctuation">;</span> <span class="token comment">// 组id</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> egid<span class="token punctuation">;</span> <span class="token comment">// 有效组id</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> sgid<span class="token punctuation">;</span> <span class="token comment">// 保存的组id</span></span>
<span class="line">    <span class="token keyword">long</span> timeout<span class="token punctuation">;</span> <span class="token comment">// 内核定时器超时值</span></span>
<span class="line">    <span class="token keyword">long</span> alarm<span class="token punctuation">;</span> <span class="token comment">// 报警定时值</span></span>
<span class="line">    <span class="token keyword">long</span> utime<span class="token punctuation">;</span> <span class="token comment">// 用户态运行时间</span></span>
<span class="line">    <span class="token keyword">long</span> stime<span class="token punctuation">;</span> <span class="token comment">// 系统态运行时间</span></span>
<span class="line">    <span class="token keyword">long</span> cutime<span class="token punctuation">;</span> <span class="token comment">// 子进程用户态运行时间</span></span>
<span class="line">    <span class="token keyword">long</span> cstime<span class="token punctuation">;</span> <span class="token comment">// 子进程系统态运行时间</span></span>
<span class="line">    <span class="token keyword">long</span> start_time<span class="token punctuation">;</span> <span class="token comment">// 进程开始运行时刻</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">rlimit</span> rlim<span class="token punctuation">[</span>RLIM_NLIMITS<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 进程资源使用统计数组</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">;</span> <span class="token comment">// 进程标志</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> used_math<span class="token punctuation">;</span> <span class="token comment">// 是否使用了协处理器</span></span>
<span class="line">    <span class="token keyword">int</span> tty<span class="token punctuation">;</span> <span class="token comment">// 进程使用 tty 终端的子设备号</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> umask<span class="token punctuation">;</span> <span class="token comment">// 文件创建属性屏蔽位</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">m_inode</span> <span class="token operator">*</span>pwd<span class="token punctuation">;</span> <span class="token comment">// 当前工作目录的 inode 指针</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">m_inode</span> <span class="token operator">*</span>root<span class="token punctuation">;</span> <span class="token comment">// 根目录 inode 指针</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">m_inode</span> <span class="token operator">*</span>executable<span class="token punctuation">;</span> <span class="token comment">// 执行文件的 inode 指针</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">m_inode</span> <span class="token operator">*</span>library<span class="token punctuation">;</span> <span class="token comment">// 被加载库文件的 inode 指针</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> close_on_exec<span class="token punctuation">;</span> <span class="token comment">// 执行时关闭文件句柄 bitmap 标志</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>filp<span class="token punctuation">[</span>NR_OPEN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 文件结构指针 - 最多 32 项</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">desc_struct</span> ldt<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 局部描述符表</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">tss_struct</span> tss<span class="token punctuation">;</span> <span class="token comment">// 进程的任务状态段信息结构</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>long state：进程的当前状态号，一个进程可处于五种状态之一： <ul><li><code>TASK_RUNNING</code></li><li><code>TASK_INTERRUPTIBLE</code></li><li><code>TASK_UNINTERRUPTIBLE</code></li><li><code>TASK_ZOMBIE</code></li><li><code>TASK_STOPPED</code></li></ul></li><li>long counter：进程被切换之前还能执行的系统滴答数 (系统周期数)，会动态变化，被调度程序使用，用于选择下一个执行的进程；进程被创建时，初始值 == priority</li><li>long priority：counter 的初值 - 15 个系统时钟周期</li><li>long signal：进程当前收到信号的 bitmap，共 32-bit，每位代表一种信号</li><li>struct sigaction sigaction[32]：保存各信号使用的操作和属性</li><li>long blocked：进程当前不想处理的信号 bitmap</li><li>int exit_code：保存程序终止时的退出码，子进程结束后，父进程可以查询子进程的退出码</li><li>unsigned long start_code：进程代码在线性地址空间中的开始地址 (n × 64MB)</li><li>unsigned long end_code：进程代码的字节长度</li><li>unsigned long end_data：进程的代码长度 + 数据长度的总字节长度</li><li>unsigned long brk：也是进程代码长度 + 数据长度的总字节长度，还包含未初始化的数据区 bss；修改该指针，内核可以为进程动态添加和释放内存</li><li>unsigned long start_stack：指向进程逻辑地址空间中堆栈的起始处</li><li>long pid：唯一标识进程</li><li>long pgrp：进程所属进程组号</li><li>long session：进程会话号</li><li>long leader：会话首进程号</li><li>int groups[NGROUPS]：进程所属各个组的组号数组</li><li>task_struct *p_pptr：指向父进程任务结构的指针</li><li>task_struct *p_cptr：指向最新子进程任务结构的指针</li><li>task_struct *p_ysptr：指向比自己后创建的相邻进程的指针</li><li>task_struct *p_osptr：指向比自己早创建的相邻进程的指针</li></ul><p><img src="`+n+`" alt="5-20"></p><ul><li>unsigned short uid：拥有该进程的用户 id</li><li>unsigned short euid：有效用户 id</li><li>unsigned short suid：保存的用户 id</li><li>unsigned short gid：用户所属组 id</li><li>unsigned short egit：有效组 id</li><li>unsigned short sgid：保存的组 id</li><li>long timeout：内核定时超时值</li><li>long alarm：进程的报警定时值，使用系统调用 <code>alarm()</code> 设置该字段，当系统时间滴答值超过该字段，内核向进程发送 <code>SIGALRM</code> 信号，默认该信号终止程序执行</li><li>long utime：累计进程在用户态下运行的滴答数</li><li>long stime：累计进程在内核态下运行的滴答数</li><li>long cutime：累计进程的子进程在用户态下运行的滴答数</li><li>long cstime：累计进程的子进程在内核态下运行的滴答数</li><li>long start_time：进程开始运行的时刻</li><li>struct rlimit rlim[RLIM_NLIMITS]：进程资源使用统计数组</li><li>unsigned int flags：进程标志</li><li>unsigned short used_math：进程是否使用协处理器的标志</li><li>int tty：进程使用的 tty 终端的子设备号，<code>-1</code> 表示没有使用</li><li>unsigned short umask：创建新文件时使用的 16-bit 属性屏蔽字</li><li>struct m_inode *pwd：进程当前工作目录的 inode；每个进程都有一个当前工作目录，用于解析 <strong>相对路径</strong>，使用系统调用 <code>chdir()</code> 来改变</li><li>struct m_inode *root：进程的根目录 inode，用于解析绝对路径，只有 super user 可以通过系统调用 <code>chroot</code> 来修改根目录</li><li>struct m_inode *executable：进程运行的执行文件在内存中的 inode，判断系统中是否还有另一个进程在运行该文件，如果有，则 inode 的引用计数会 &gt; 1</li><li>struct m_inode *library：被加载的库文件的 inode</li><li>unsigned long close_on_exec：进程文件描述符的 bitmap，用于在执行 <code>exec</code> 类系统调用时，关闭已经打开的文件描述符</li><li>struct file *filp[NR_OPEN]：打开的文件结构指针表，最多 32 项</li><li>struct desc_struct ldt[3]：局部描述符表 <ul><li>[0]：空</li><li>[1]：代码段描述符</li><li>[2]：数据段和堆栈段描述符</li></ul></li><li>struct tss_struct tss：进程 TSS 信息结构，切换任务时，保存了 CPU 所有的寄存器</li></ul><p>在 Linux 中，当前进程的上下文均保存在任务数据结构中。</p><h3 id="_5-7-2-进程运行状态" tabindex="-1"><a class="header-anchor" href="#_5-7-2-进程运行状态"><span>5.7.2 进程运行状态</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_RUNNING</span>            <span class="token expression"><span class="token number">0</span> </span><span class="token comment">// 正在运行或准备就绪</span></span></span>
<span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_INTERRUPTIBLE</span>      <span class="token expression"><span class="token number">1</span> </span><span class="token comment">// 可中断等待 </span></span></span>
<span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_UNINTERRUPTIBLE</span>    <span class="token expression"><span class="token number">2</span> </span><span class="token comment">// 不可中断等待</span></span></span>
<span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_ZOMBIE</span>             <span class="token expression"><span class="token number">3</span> </span><span class="token comment">// 僵死，已经停止运行，但父进程还没发信号</span></span></span>
<span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_STOPPED</span>            <span class="token expression"><span class="token number">4</span> </span><span class="token comment">// 停止</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>状态 0：正被 CPU 执行，或随时可由调度程序执行 (就绪状态)，进程在内核代码中运行，称为内核态；进程执行自己的用户态代码，称为用户态；一个新进程刚被创建时处于本状态</li><li>状态 1：可中断睡眠，系统不会调度该进程执行；系统产生一个中断，或释放了进程正在等待的资源，或进程收到信号，都可以唤醒进程</li><li>状态 2：不可中断睡眠，不被任何信号唤醒，只有被 <code>wake_up()</code> 函数明确唤醒时才转换到就绪状态</li><li>状态 3：进程已经停止运行，父进程还没有调用 <code>wait()</code> 询问其状态，为了使父进程能够获取子进程停止运行时的信息，子进程的任务数据结构还需要保留；父进程调用 <code>wait()</code> 取得了子进程的信息，则处于该状态的进程的任务数据结构会被释放</li><li>状态 4：进程收到相关信号时，进入暂停状态，发送 <code>SIGCONT</code> 信号可让进程转换到可执行状态</li></ul><p>如果进程在内核态执行时需要等待系统的某个资源，调用 <code>sleep_on()</code> 或 <code>interruptible_sleep_on()</code> 自愿放弃 CPU 使用权，并进入睡眠状态。只有进程从 <strong>内核运行态</strong> 转移到 <strong>睡眠状态</strong> 时，内核才会进行进程切换操作。在内核态下运行的进程不能被其它进程抢占。为避免进程切换时的内核数据错误，内核在执行临界区代码时会禁止一切中断。</p><h3 id="_5-7-3-进程初始化" tabindex="-1"><a class="header-anchor" href="#_5-7-3-进程初始化"><span>5.7.3 进程初始化</span></a></h3><p>OS 初始化后，程序手工将自身移动到任务 0 中执行，由宏 <code>move_to_user_mode</code> 完成：任务 0 内核态 → 任务 0 用户态。</p><p>使用 <code>fork()</code> 创建进程 1，进程 1 将进行应用环境的初始化。进程 0 在系统空闲时被调度执行，仅执行 <code>pause()</code> 系统调用，并再次执行调度函数。</p><h3 id="_5-7-4-创建新进程" tabindex="-1"><a class="header-anchor" href="#_5-7-4-创建新进程"><span>5.7.4 创建新进程</span></a></h3><p>系统首先在任务数组中找出一个没有被任何进程使用的空项，如果数组中已有 64 个进程在运行，则出错返回。OS 为新建进程在主存区申请一页内存，存放任务数据结构，并复制父进程任务数据结构中的所有内容。为防止未完成处理的新进程被调度，此时状态被设置为 <code>TASK_UNINTERRUPTIBLE</code>。对复制后的任务数据结构进行修改：</p><ul><li>复位各统计值</li><li>清除信号位图</li><li>设置初始运行时间片</li><li>设置 TSS 中各寄存器的值</li><li>...</li></ul><p>OS 设置新任务的代码和数据段基址、限长，并复制当前进程内存分页管理的页表。此时，系统并不为新进程分配实际的物理页面，而是共享父进程的物理页面。当父进程或新进程中有写内存的操作时，OS 才会为执行写操作的进程分配独立使用的内存页面：Copy On Write 技术。若父进程有文件是打开的，则对应文件的打开次数 + 1。在 GDT 中设置新任务的 TSS 和 LDT 描述符，指向新进程 PCB 中的 tss 和 ldt，最后将任务状态设置为 <code>TASK_RUNNING</code>，并返回新进程号。</p><p>以上仅为 <code>fork()</code> 的功能，<code>exec()</code> 会使子进程原来的代码和数据区被释放，并运行新程序。此时内核还没有加载该程序的代码，CPU 会立刻产生缺页异常。此时内存管理程序从块设备上加载相应代码，CPU 重新执行引起异常的指令，才开始执行真正的新程序。</p><h3 id="_5-7-5-进程调度" tabindex="-1"><a class="header-anchor" href="#_5-7-5-进程调度"><span>5.7.5 进程调度</span></a></h3><p>内核的调度程序用于选择系统下一个要运行的进程。Linux 进程是抢占式的：进程的抢占发生在进程处于用户态执行的阶段，进程在内核态执行时是不能被抢占的。Linux 0.12 使用基于优先级排队的调度策略。</p><h4 id="调度程序" tabindex="-1"><a class="header-anchor" href="#调度程序"><span>调度程序</span></a></h4><p><code>schedule()</code> 函数扫描任务数组，比较每个就绪态任务的 counter 值，确定哪个进程运行的时间最少。哪一个值大，说明该进程运行时间还不长。选中该进程，使用任务切换宏函数切换到该进程运行。如果所有处于 <code>TASK_RUNNING</code> 状态进程的时间片都已用完，那么根据 priority 对所有进程重新计算 counter (包括正在睡眠的进程)：<code>counter = counter / 2 + priority</code>。对于正在睡眠的进程，被唤醒时具有较高的 counter 值</p><p><code>schedule()</code> 函数重新扫描任务数组，重复上述过程，如果没有进程可运行，系统会选择进程 0。进程 0 会调用 <code>pause()</code> 把自己置为可中断睡眠状态，并再次调用 <code>schedule()</code>。</p><h4 id="进程切换" tabindex="-1"><a class="header-anchor" href="#进程切换"><span>进程切换</span></a></h4><p>每当选出一个进程，<code>schedule()</code> 函数调用 <code>switch_to()</code> 宏执行进程切换操作。<code>switch_to()</code> 首先检查要切换到的进程是否是当前进程，如果是，则无需操作。否则就把内核全局变量 current 指向新任务，然后长跳转到新任务的 TSS，造成 CPU 执行任务切换：</p><ul><li>CPU 将当前寄存器现场保存到当前 TR 中 TSS 段选择符指向的当前进程 PCB 的 tss 结构中</li><li>将新任务 PCB 中 tss 结构信息恢复到 CPU 中</li></ul><h3 id="_5-7-6-终止进程" tabindex="-1"><a class="header-anchor" href="#_5-7-6-终止进程"><span>5.7.6 终止进程</span></a></h3><p>进程结束 / 半途终止运行，内核需要释放该进程占用的系统资源：</p><ul><li>打开的文件</li><li>申请的内存</li><li>...</li></ul><p>用户程序调用 <code>exit()</code> 系统调用时，会执行内核函数 <code>do_exit()</code> ：</p><ul><li>释放进程代码段和数据段占用的内存页面</li><li>关闭进程打开的所有文件</li><li>对所有 inode 进行同步操作</li><li>如果有子进程，则让其所有子进程的父进程指针指向 init 进程</li><li>如果是会话头进程，则需要发送挂断信号</li><li>进程被设置为 <code>TASK_ZOMBIE</code></li><li>向父进程发送 <code>SIGCHLD</code> 信号，表示子进程已经终止</li><li>调用调度函数去执行其它进程</li></ul><p>此时，PCB 仍然保留，因此父进程还需要使用其中的信息。父进程使用 <code>wait()</code> 或 <code>waitpid()</code> 函数等待子进程终止。子进程被终止并处于 <code>TASK_ZOMBIE</code> 状态时，父进程把子进程的累计时间加到自己的 PCB 中。最终释放子进程 PCB 占用的内存页面，并置空子进程在任务数组中占用的指针。</p><hr><h2 id="_5-8-linux-系统中堆栈的使用方法" tabindex="-1"><a class="header-anchor" href="#_5-8-linux-系统中堆栈的使用方法"><span>5.8 Linux 系统中堆栈的使用方法</span></a></h2><p>Linux 0.12 系统中共使用了四种堆栈</p><ul><li>系统引导初始化时临时使用的堆栈</li><li>进入保护模式之后，供内核程序初始化使用的堆栈</li><li>每个任务通过系统调用执行内核程序时的内核堆栈</li><li>每个任务在用户态执行时使用的堆栈</li></ul><p>使用不同堆栈的原因：</p><ol><li>从实模式进入保护模式后，CPU 寻址方式发生了变化</li><li>解决 CPU 不同特权级共享使用堆栈时带来的保护问题 <ul><li>任务进入内核态时，用户堆栈指针被保存在内核堆栈中</li><li>从内核态返回时，恢复使用用户态堆栈</li></ul></li></ol><h3 id="_5-8-1-初始化阶段" tabindex="-1"><a class="header-anchor" href="#_5-8-1-初始化阶段"><span>5.8.1 初始化阶段</span></a></h3><h4 id="开机初始化时-bootsect-s-setup-s" tabindex="-1"><a class="header-anchor" href="#开机初始化时-bootsect-s-setup-s"><span>开机初始化时 (bootsect.s, setup.s)</span></a></h4><p>用于系统初始化时临时使用。</p><h4 id="进入保护模式时-head-s" tabindex="-1"><a class="header-anchor" href="#进入保护模式时-head-s"><span>进入保护模式时 (head.s)</span></a></h4><p>系统进入保护模式，堆栈段被设置为内核数据段，保留了 1 页内存 (4K) 作为堆栈使用。</p><h4 id="初始化时-main-c" tabindex="-1"><a class="header-anchor" href="#初始化时-main-c"><span>初始化时 (main.c)</span></a></h4><p>在把控制权交给任务 0 之前，系统一直使用上述堆栈。当 main.c 中的代码切换为任务 0 执行后，通过执行 <code>fork()</code>，<code>init()</code> 将在任务 1 中执行。<code>main()</code> 本身继续使用内核程序中自己的堆栈，作为任务 0 的用户态堆栈。</p><h3 id="_5-8-2-任务的堆栈" tabindex="-1"><a class="header-anchor" href="#_5-8-2-任务的堆栈"><span>5.8.2 任务的堆栈</span></a></h3><p>每个任务都有两个堆栈，分别用于用户态和内核态程序的执行：</p><ul><li>内核态堆栈很小，保存的数据最多不能超过 PCB 的大小</li><li>用户态堆栈可以在 64MB 空间内延伸</li></ul><h4 id="在用户态运行时" tabindex="-1"><a class="header-anchor" href="#在用户态运行时"><span>在用户态运行时</span></a></h4><p>进程被创建时，用户态指针被设置为地址空间靠近末端处 (接近 64MB 顶端)：</p><p><img src="`+p+'" alt="5-25"></p><p>由于 Linux 实现了 Copy On Right，进程被创建后，若进程和父进程都没有使用堆栈，则共享同一堆栈对应的物理内存页面。只有一个进程进程堆栈写操作时，内核内存管理程序才会为执行写操作的进程分配新的内存页面。</p><h4 id="在内核态运行时" tabindex="-1"><a class="header-anchor" href="#在内核态运行时"><span>在内核态运行时</span></a></h4><p>内核态堆栈的线性地址由任务 TSS 中 ss0 和 esp0 两个字段指定。当任务从用户代码转移进入内核代码时，内核态堆栈总是空的。内核态堆栈被设置位于 PCB 所在页面的末端，即和 PCB 放在同一页面内：</p><p><img src="'+t+`" alt="5-26"></p><h4 id="任务-0-和任务-1-的堆栈" tabindex="-1"><a class="header-anchor" href="#任务-0-和任务-1-的堆栈"><span>任务 0 和任务 1 的堆栈</span></a></h4><p>任务 0 和任务 1 的内核态堆栈分别位于各自 PCB 所在页面的末端。任务 0 的用户态堆栈就是进入保护模式后所使用的堆栈；任务 1 在创建时复制了任务 0 的用户态堆栈，在刚开始时与任务 0 共享同一个堆栈。只有在发生堆栈写操作时，Copy On Right 机制才会为任务 1 的堆栈分配新的页面。因此，任务 0 的堆栈需要在任务 1 实际开始使用之前保持干净，即任务 0 在任务 1 开始使用之前，不能使用堆栈，确保任务 1 复制的堆栈页面不含有 任务 0 的数据。</p><h3 id="_5-8-3-任务内核态堆栈与用户态堆栈之间的切换" tabindex="-1"><a class="header-anchor" href="#_5-8-3-任务内核态堆栈与用户态堆栈之间的切换"><span>5.8.3 任务内核态堆栈与用户态堆栈之间的切换</span></a></h3><p>所有中断服务程序都属于内核代码。如果中断产生时，任务处于用户态中：</p><ul><li>中断就会引起 CPU 特权级的变化，引发 CPU 进行用户态堆栈 / 内核态堆栈的切换操作</li><li>CPU 从当前任务的 TSS 中取得内核堆栈的位置</li><li>并将用户态堆栈指针压入内核态堆栈</li><li>随后把 EFLAGS 中的内容和用户程序返回地址压入内核态堆栈</li><li>执行中断服务过程</li></ul><p>如果任务正在内核态中运行：</p><ul><li>CPU 响应中断时，不再需要进行堆栈切换操作</li><li>CPU 仅把 EFLAGS 和内核代码返回地址压入内核态堆栈中</li><li>执行中断服务过程</li></ul><hr><h2 id="_5-9-linux-0-12-采用的文件系统" tabindex="-1"><a class="header-anchor" href="#_5-9-linux-0-12-采用的文件系统"><span>5.9 Linux 0.12 采用的文件系统</span></a></h2><p>Linux 系统引导启动时，默认使用的文件系统是根文件系统，包括 OS 最起码的一些配置文件和命令执行程序：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">/etc        系统配置文件</span>
<span class="line">/dev        设备文件</span>
<span class="line">/bin        系统执行程序</span>
<span class="line">/usr        库函数、手册、其它文件</span>
<span class="line">/usr/bin    用户常用的普通命令</span>
<span class="line">/var        系统运行时可变的数据或者是日志等信息</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Linux 启动盘加载根文件系统时，根据启动盘引导扇区的第 509、510 字节处的 <code>ROOT_DEV</code> 中指定的 <strong>根文件系统设备号</strong>，从指定的设备中加载根文件系统。</p><ul><li>如果设备号为 <code>0</code>，就从引导盘所在驱动器中加载根文件系统</li><li>如果是硬盘分区设备号，就从对应的硬盘分区加载根文件系统</li></ul>`,79)]))}const k=a(c,[["render",o],["__file","Chapter 5.7-5.9 - Linux 进程控制 _ 堆栈使用 _ 文件系统.html.vue"]]),m=JSON.parse('{"path":"/linux-kernel-comments-notes/Chapter%205%20-%20Linux%20%E5%86%85%E6%A0%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Chapter%205.7-5.9%20-%20Linux%20%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%20_%20%E5%A0%86%E6%A0%88%E4%BD%BF%E7%94%A8%20_%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.html","title":"Chapter 5.7-5.9 - Linux 进程控制 & 堆栈使用 & 文件系统","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"5.7 Linux 进程控制","slug":"_5-7-linux-进程控制","link":"#_5-7-linux-进程控制","children":[{"level":3,"title":"5.7.1 任务数据结构","slug":"_5-7-1-任务数据结构","link":"#_5-7-1-任务数据结构","children":[]},{"level":3,"title":"5.7.2 进程运行状态","slug":"_5-7-2-进程运行状态","link":"#_5-7-2-进程运行状态","children":[]},{"level":3,"title":"5.7.3 进程初始化","slug":"_5-7-3-进程初始化","link":"#_5-7-3-进程初始化","children":[]},{"level":3,"title":"5.7.4 创建新进程","slug":"_5-7-4-创建新进程","link":"#_5-7-4-创建新进程","children":[]},{"level":3,"title":"5.7.5 进程调度","slug":"_5-7-5-进程调度","link":"#_5-7-5-进程调度","children":[]},{"level":3,"title":"5.7.6 终止进程","slug":"_5-7-6-终止进程","link":"#_5-7-6-终止进程","children":[]}]},{"level":2,"title":"5.8 Linux 系统中堆栈的使用方法","slug":"_5-8-linux-系统中堆栈的使用方法","link":"#_5-8-linux-系统中堆栈的使用方法","children":[{"level":3,"title":"5.8.1 初始化阶段","slug":"_5-8-1-初始化阶段","link":"#_5-8-1-初始化阶段","children":[]},{"level":3,"title":"5.8.2 任务的堆栈","slug":"_5-8-2-任务的堆栈","link":"#_5-8-2-任务的堆栈","children":[]},{"level":3,"title":"5.8.3 任务内核态堆栈与用户态堆栈之间的切换","slug":"_5-8-3-任务内核态堆栈与用户态堆栈之间的切换","link":"#_5-8-3-任务内核态堆栈与用户态堆栈之间的切换","children":[]}]},{"level":2,"title":"5.9 Linux 0.12 采用的文件系统","slug":"_5-9-linux-0-12-采用的文件系统","link":"#_5-9-linux-0-12-采用的文件系统","children":[]}],"git":{},"filePathRelative":"linux-kernel-comments-notes/Chapter 5 - Linux 内核体系结构/Chapter 5.7-5.9 - Linux 进程控制 & 堆栈使用 & 文件系统.md"}');export{k as comp,m as data};
