import{_ as e,c as t,a as r,o as c}from"./app-7eKjwDat.js";const d={};function a(n,o){return c(),t("div",null,o[0]||(o[0]=[r('<h1 id="algorithm-fast-power" tabindex="-1"><a class="header-anchor" href="#algorithm-fast-power"><span>Algorithm - Fast Power</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 10 / 24 👨‍💻 16:11</p><p>Nanjing, Jiangsu, China</p><hr><p>能够快速算底数的幂，时间复杂度由朴素算法的 O(n) 降低到 O(log(n))。</p><p>首先需要明确一个事实：计算机和人脑的运算方式不一样。人脑计算比较小的数字可以直接口算，而算大的数字比较慢；而计算机 CPU 中已经是设计好的电路，对于相同的运算符来说，不管操作数的大小，运算时间应当都是一致的。对于人脑来说，计算 <code>7 * 7</code> 的时间远快于 <code>77777 * 77777</code>；而对于 CPU 来说，时间基本上是一样的。因此，幂运算在计算机上的快慢，本质上取决于做乘法的 <strong>次数</strong>，而不是 <strong>底数大小</strong>。</p><p>对于 <code>7 ^ 10</code> 来说，从人脑的思路出发，应当是不断计算 <code>7 * 7^(n-1)</code>，最终需要通过 9 次乘法完成。而在计算机上，基于分治的思路，很容易想到：如果先算 <code>7^5</code> (假设通过人脑计算法需要 4 次乘法)，然后再多用一次乘法计算 <code>7^5 * 7^5</code>，最终岂不是只需要 5 次乘法 (姑且这么认为) 就能完成了？这里为什么能省乘法次数呢？因为 <code>7^5</code> 已经被计算过了，完全可以被重复使用。</p><p>同样，对于 <code>7^5</code> 来说，人脑算法需要 4 次乘法，而如果使用 <code>7^2 * 7^2 * 7</code> 的算法，只需要 (1 (<code>7^2</code>) + 2 (合并结果)) 共 3 次乘法即可。</p><p>以上就是 <strong>快速幂</strong> 算法的基础思想：</p><ul><li>对于奇数次幂，<code>x^y = x^(y/2) * x^(y/2) * x</code></li><li>对于偶数次幂，<code>x^y = x^(y/2) * x^(y/2)</code></li></ul><p>依次类推，递归的终点为 <code>x^2</code> / <code>x^1</code> / <code>x^0</code>。</p>',12)]))}const l=e(d,[["render",a],["__file","Algorithm Fast Power.html.vue"]]),i=JSON.parse('{"path":"/notes/Algorithm/Algorithm%20Fast%20Power.html","title":"Algorithm - Fast Power","lang":"en-US","frontmatter":{},"headers":[],"git":{},"filePathRelative":"notes/Algorithm/Algorithm Fast Power.md"}');export{l as comp,i as data};
