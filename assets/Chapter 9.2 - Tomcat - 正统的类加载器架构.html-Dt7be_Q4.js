import{_ as e,c as l,a as t,o}from"./app-7eKjwDat.js";const i={};function r(c,a){return o(),l("div",null,a[0]||(a[0]=[t('<h1 id="chapter-9-2-tomcat-正统的类加载器架构" tabindex="-1"><a class="header-anchor" href="#chapter-9-2-tomcat-正统的类加载器架构"><span>Chapter 9.2 - Tomcat: 正统的类加载器架构</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 01 / 31 16:32 🧨🧧</p><p>Ningbo, Zhejiang, China</p><hr><h2 id="_9-2-案例分析" tabindex="-1"><a class="header-anchor" href="#_9-2-案例分析"><span>9.2 案例分析</span></a></h2><h3 id="_9-2-1-tomcat-正统的类加载器架构" tabindex="-1"><a class="header-anchor" href="#_9-2-1-tomcat-正统的类加载器架构"><span>9.2.1 Tomcat: 正统的类加载器架构</span></a></h3><p>主流的 Java Web 服务器都实现了自己定义的类加载器，且一般不止一个。要解决的问题：</p><ul><li>部署在同一服务器上的两个 Web 应用使用的 Java 类库可以互相隔离，因为两个不同的应用程序可能会依赖同一个第三方类库的不同版本</li><li>部署在同一服务器上的两个 Web 应用使用的 Java 类库可以互相共享，否则 JVM 的方法区容易出现过度膨胀的风险</li><li>服务器需要保证自身安全不受部署的 Web 应用程序影响，服务器使用的类库应该与应用程序类库互相独立</li><li>HotSwap</li></ul><p>Tomcat 的类库目录结构：</p><ul><li><code>/common</code> - 类库可被 Tomcat 和所有的 Web 应用程序共同使用</li><li><code>/server</code> - 类库可被 Tomcat 使用，对所有的 Web 应用程序都不可见</li><li><code>/shared</code> - 类库可被所有的 Web 应用程序共同使用，但对 Tomcat 不可见</li><li><code>/WebApp/WEB-INF</code> - 类库仅仅可以被该 Web 应用程序使用</li></ul><p>为了支持这套目录结构，并对目录中的类库进行加载和隔离。Tomcat 自定义了多个类加载器，并按照经典的双亲委派模型实现：</p><ul><li>CommonClassLoader 继承 Java 自带的应用程序类加载器 <ul><li>负责加载 Tomcat 和应用程序共用的类库</li></ul></li><li>CatalinaClassLoader 和 SharedClassLoader 继承 CommonClassLoader <ul><li>CatalinaClassLoader 加载仅被 Tomcat 使用的类库</li><li>SharedClassLoader 加载应用程序共用的类库</li></ul></li><li>WebAppClassLoader 继承 SharedClassLoader <ul><li>每个 Web 应用程序对应一个 WebApp 类加载器，因此有多个实例</li><li>每个 WebApp 类加载器之间隔离</li></ul></li><li>JasperLoader 继承 WebAppClassLoader <ul><li>每个 JSP 文件对应一个 JasperLoader 类加载器</li><li>仅用于加载某个 JSP 文件编译出的 Class 文件</li><li>当服务器检测到 JSP 文件被修改时，会替换当前的 JasperLoader 实例，再建立一个新的 JSP 类加载器实现 JSP 的 HotSwap</li></ul></li></ul><p>在 Tomcat 6 中，为了易用性，默认将所有目录整合为一个 <code>/lib</code> 目录，默认只启用 CommonClassLoader。</p><ul><li>简化大多数部署场景</li><li>可以通过配置文件指定 <code>server.loader</code> 和 <code>share.loader</code> 重新启用原来完整的加载器架构</li></ul>',15)]))}const d=e(i,[["render",r],["__file","Chapter 9.2 - Tomcat - 正统的类加载器架构.html.vue"]]),p=JSON.parse('{"path":"/understanding-the-jvm-notes/Part%203%20-%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/Chapter%209.2%20-%20Tomcat%20-%20%E6%AD%A3%E7%BB%9F%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9E%B6%E6%9E%84.html","title":"Chapter 9.2 - Tomcat: 正统的类加载器架构","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"9.2 案例分析","slug":"_9-2-案例分析","link":"#_9-2-案例分析","children":[{"level":3,"title":"9.2.1 Tomcat: 正统的类加载器架构","slug":"_9-2-1-tomcat-正统的类加载器架构","link":"#_9-2-1-tomcat-正统的类加载器架构","children":[]}]}],"git":{},"filePathRelative":"understanding-the-jvm-notes/Part 3 - 虚拟机执行子系统/Chapter 9.2 - Tomcat - 正统的类加载器架构.md"}');export{d as comp,p as data};
