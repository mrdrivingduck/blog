import{_ as s,c as a,a as e,o as p}from"./app-BeHGwf2X.js";const l={};function c(o,n){return p(),a("div",null,n[0]||(n[0]=[e(`<h1 id="chapter-8-7-nginx-内存池" tabindex="-1"><a class="header-anchor" href="#chapter-8-7-nginx-内存池"><span>Chapter 8.7 - Nginx 内存池</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 07 / 20 20:19</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="_8-7-ngx-pool-t-内存池" tabindex="-1"><a class="header-anchor" href="#_8-7-ngx-pool-t-内存池"><span>8.7 <code>ngx_pool_t</code> 内存池</span></a></h2><p>Nginx 已经对 <code>malloc()</code> 和 <code>free()</code> 进行了封装。另外提供了内存池的原因是降低程序员犯错的概率：只需要关心内存的分配，释放交由内存池来负责。通常来说，只有在内存池被销毁时，内存才会被释放回操作系统。在一个内存池上，可以任意次地申请内存不用释放，只需要最后销毁即可。</p><blockquote><p>如果内存池生命周期很长，而其中每块内存的生命周期很短，会造成内存浪费吗？这与 Nginx 的应用场景有关。每个 TCP 连接都有明确的生命周期，每个 HTTP 请求有非常短暂的生命周期。如果每个请求、连接都有各自的内存池，那么请求结束时内存就会被回收了。</p></blockquote><p>另外，内存池还对 <strong>小块内存</strong> 的频繁分配做了优化。小块内存的标准：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NGX_MAX_ALLOC_FROM_POOL</span> <span class="token expression"><span class="token punctuation">(</span>ngx_pagesize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Nginx 处理大块内存和小块内存的方式是不一样的。内存池的定义如下：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ngx_pool_s</span> <span class="token class-name">ngx_pool_t</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">ngx_pool_s</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">ngx_pool_data_t</span> d<span class="token punctuation">;</span> <span class="token comment">// 小块内存池单链表</span></span>
<span class="line">    <span class="token class-name">size_t</span> max<span class="token punctuation">;</span> <span class="token comment">// 小块内存与大块内存的阈值</span></span>
<span class="line">    <span class="token class-name">ngx_pool_t</span> <span class="token operator">*</span>current<span class="token punctuation">;</span> <span class="token comment">// 指向分配内存池时遍历的第一个小块内存池</span></span>
<span class="line">    <span class="token class-name">ngx_pool_large_t</span> <span class="token operator">*</span>large<span class="token punctuation">;</span> <span class="token comment">// 大块内存链表</span></span>
<span class="line">    <span class="token class-name">ngx_pool_cleanup_t</span> <span class="token operator">*</span>cleanup<span class="token punctuation">;</span> <span class="token comment">// 所有待清理资源构成的单链表</span></span>
<span class="line">    <span class="token class-name">ngx_log_t</span> <span class="token operator">*</span>log<span class="token punctuation">;</span> <span class="token comment">// 日志</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当分配大块内存时，直接调用 <code>ngx_alloc()</code> 从进程堆上分配，同时还会分配一个 <code>ngx_pool_large_t</code> 结构体，挂到 <code>large</code> 链表中：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ngx_pool_large_s</span> <span class="token class-name">ngx_pool_large_t</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">ngx_pool_large_s</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">ngx_pool_large_t</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 连接下一个大块内存结构体</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token operator">*</span>alloc<span class="token punctuation">;</span> <span class="token comment">// 指向大块内存</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果大块内存的生命周期远小于内存池，那么提前释放是很有必要的。<code>ngx_pfree()</code> 实现了这个功能，它会遍历 <code>large</code> 链表，找到待释放的 <code>alloc</code> 并释放内存，但会保留 <code>ngx_pool_large_t</code> 结构体以便复用。</p><p>对于小块内存，内存池从进程堆中预分配更多的内存，然后直接使用这块内存的一小部分返回给申请者，减少了内存碎片与调用 <code>malloc()</code> 的次数。预分配的内存通过维护如下结构体来进行记录：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span></span>
<span class="line">    u_char <span class="token operator">*</span>last<span class="token punctuation">;</span> <span class="token comment">// 未分配的空闲内存首地址</span></span>
<span class="line">    u_char <span class="token operator">*</span>end<span class="token punctuation">;</span> <span class="token comment">// 当前小块内存的尾部</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">ngx_pool_t</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 下一个小块内存结构体</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">ngx_uint_t</span> failed<span class="token punctuation">;</span> <span class="token comment">// 在这个小块内存中分配失败的次数</span></span>
<span class="line"><span class="token punctuation">}</span> <span class="token class-name">ngx_pool_data_t</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当这一小块预分配内存的空闲空间不足使用时，会再分配一块相同大小的内存池，通过 <code>next</code> 指针相连，并将 <code>failed</code> + 1。如果 <code>failed</code> 已经大于 4，那么内存池结构体中的 <code>current</code> 指针指向下一个小块内存池。下次开始分配内存时，就不会再从第一个内存池开始分配了。</p><p>另外，内存池还希望能够代替程序员释放 (文件) 资源。<code>ngx_pool_cleanup_t</code> 结构体实现了这个功能：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>ngx_pool_cleanup_pt<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ngx_pool_cleanup_s</span> <span class="token class-name">ngx_pool_cleanup_t</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">ngx_pool_cleanup_s</span> <span class="token punctuation">{</span></span>
<span class="line">    ngx_pool_cleanup_pt handler<span class="token punctuation">;</span> <span class="token comment">// 清理函数指针</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">;</span> <span class="token comment">// 函数参数</span></span>
<span class="line">    <span class="token class-name">ngx_pool_cleanup_t</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 链接下一个结构体</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从内存池中分配内存的步骤：</p><ol><li>将申请的内存大小与 <code>max</code> 成员比较，决定申请大块内存还是小块内存</li><li>如果申请小块内存，则首先取得 <code>current</code> 指针指向的内存池，并试图在其中分配内存；如果 <code>failed</code> 已经超过 4，则剩余空间多半已经无法满足申请内存</li><li>找到 <code>last</code> 指针之后最近的对齐地址</li><li>比较对齐地址与 <code>end</code> 指针之间是否可以容纳申请内存的大小，如果不行，则检查 <code>next</code> 指针是否为空，如果为空，则申请新的小块内存池；如果不为空，则向下一个小块内存池申请内存</li><li>将 <code>last</code> 指针置为下一个空闲内存首地址，返回分配内存的起始地址，结束</li><li>否则分配一个相同大小的小块内存池</li><li>将新内存的空闲地址对齐，返回给申请内存的进程，再设置 <code>last</code> 指针到空闲内存首地址</li><li>从 <code>current</code> 指向的小块内存池开始遍历到当前的新内存池，依次将 <code>failed</code> 成员 + 1，并使 <code>current</code> 指向首个 <code>failed &lt;= 4</code> 的小块内存池</li><li>否则开始分配大块内存</li><li>调用 <code>ngx_alloc()</code> 从进程的堆内存中分配</li><li>遍历 <code>large</code> 链表，找到一个 <code>alloc</code> 成员为 <code>NULL</code> 的项 (最多找 4 个)</li><li>将 <code>alloc</code> 成员设置为分配的内存地址并返回，结束</li><li>如果没有空闲的 <code>ngx_pool_large_t</code> 项，那么从内存池中分配出新的结构体，并添加到 <code>large</code> 链表的头部，返回地址，结束</li></ol>`,22)]))}const i=s(l,[["render",c],["__file","Chapter 8.7 - Nginx 内存池.html.vue"]]),d=JSON.parse('{"path":"/understanding-nginx-notes/Part%203%20-%20%E6%B7%B1%E5%85%A5%20Nginx/Chapter%208.7%20-%20Nginx%20%E5%86%85%E5%AD%98%E6%B1%A0.html","title":"Chapter 8.7 - Nginx 内存池","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"8.7 ngx_pool_t 内存池","slug":"_8-7-ngx-pool-t-内存池","link":"#_8-7-ngx-pool-t-内存池","children":[]}],"git":{},"filePathRelative":"understanding-nginx-notes/Part 3 - 深入 Nginx/Chapter 8.7 - Nginx 内存池.md"}');export{i as comp,d as data};
