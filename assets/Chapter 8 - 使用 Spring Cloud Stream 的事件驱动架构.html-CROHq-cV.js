import{_ as s,c as a,a as e,o as p}from"./app-7eKjwDat.js";const l={};function t(i,n){return p(),a("div",null,n[0]||(n[0]=[e(`<h1 id="chapter-8-使用-spring-cloud-stream-的事件驱动架构" tabindex="-1"><a class="header-anchor" href="#chapter-8-使用-spring-cloud-stream-的事件驱动架构"><span>Chapter 8 - 使用 Spring Cloud Stream 的事件驱动架构</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 08 / 21 20:59</p><p>@Nanjing, Jiangsu, China</p><hr><h2 id="_8-1-为什么使用消息传递、eda-和微服务" tabindex="-1"><a class="header-anchor" href="#_8-1-为什么使用消息传递、eda-和微服务"><span>8.1 为什么使用消息传递、EDA 和微服务</span></a></h2><p>事件驱动架构 (Event Driven Architecture, EDA) / 消息驱动架构 (Message Driven Architecture, MDA)。</p><p>假设有一个场景，服务 A 中需要用到服务 B 的数据，因此使用缓存 (比如 <em>Redis</em>) 维护了一份服务 B 的数据。如果服务 B 被其它服务调用后，数据发生了变化，那么就需要使服务 A 缓存中的旧数据变为无效。有很多种方法可以实现这样的功能。</p><h3 id="_8-1-1-使用同步请求-响应方式来传达状态变化" tabindex="-1"><a class="header-anchor" href="#_8-1-1-使用同步请求-响应方式来传达状态变化"><span>8.1.1 使用同步请求 - 响应方式来传达状态变化</span></a></h3><p>服务 A 在接收到客户端请求后，才是查找 Redis。如果 Redis 中没有缓存，则调用服务 B 的 REST end point 查询数据，并将数据放到 Redis 中后，将客户端要查询的数据返回。现在，如果有人直接使用了服务 B 的 REST end point 对服务 B 的数据进行了修改，那么服务 B 需要调用服务 A 暴露出的 end point，通知服务 A 缓存数据失效。</p><p>这种设计具有几个问题。</p><ol><li>服务之间紧耦合 - 服务 A 为了服务 B 专门暴露了 end point；服务 B 直接与 Redis 通信在微服务环境中是个禁忌</li><li>服务之间的脆弱性 - 两个服务之间出现了依赖关系，如果服务 A 运行缓慢，那么服务 B 可能也会被拖垮</li><li>如果其它服务对服务 B 的数据变化感兴趣，那么需要在服务 B 的代码中加入更多的逻辑，形成服务间的网状依赖</li></ol><h3 id="_8-1-2-使用消息传递在服务之间传达状态更改" tabindex="-1"><a class="header-anchor" href="#_8-1-2-使用消息传递在服务之间传达状态更改"><span>8.1.2 使用消息传递在服务之间传达状态更改</span></a></h3><p>服务 B 的数据发生变化时，服务 B 发送一条消息到队列中。服务 A 监视消息队列，当检测到想要的消息时，将 Redis 中的缓存清除。这种方法的好处有以下四点：</p><ol><li>松耦合 - 涉及传达状态更改时，两个服务都不知道彼此，只知道消息队列</li><li>耐久性 - 队列能够保证即使服务 A 已经关闭，服务 B 依然可以发送消息；消息保存在队列中直到服务 A 重新可用</li><li>可伸缩性 - 消息发送者不必等待消息消费者的响应，可以直接继续工作；如果消息消费者没有足够能力处理，那么启动更多的消费者实例即可</li><li>灵活性 - 开发人员可以轻松添加新的消息消费者，而不影响原始发送服务</li></ol><p>当然，消息传递架构也有缺点：</p><ol><li>消息处理语义 - 不仅仅需要直到如何发布和消费消息，还需要知道消息没有按序处理时会发生什么问题</li><li>消息可见性 - 消息的发送与消费是异步的，可能不会立刻被接收或处理</li><li>消息编排 - 难以按照应用程序执行顺序进行业务逻辑推理，因为不再是请求-响应模型的线性处理方式</li></ol><p>综上，消息能够使开发人员将服务 <strong>挂钩</strong> 在一起，而不是 <strong>硬编码</strong> 在一起。</p><h2 id="_8-2-spring-cloud-stream-简介" tabindex="-1"><a class="header-anchor" href="#_8-2-spring-cloud-stream-简介"><span>8.2 Spring Cloud Stream 简介</span></a></h2><p>Spring Cloud Stream 是一个由注解驱动的框架，允许开发人员在 Spring 应用程序中轻松构建发布者和消费者。另外，Spring Cloud Stream 还允许开发人员抽象出正在使用的消息传递平台的具体实现 - <em>Apache Kafka</em> 或 <em>RabbitMQ</em>。平台的具体实现代码被排除在应用程序代码以外，消息发布和消费是通过平台无关的 Spring 接口实现的。</p><p>在架构上，有四个组件涉及消息的发布与接收：</p><ul><li>发射器 (source) - 接收 Java POJO，将其序列化并发送到通道</li><li>通道 (channel) - 对队列的抽象，通道名称始终与目标队列名称相关联，可以通过配置文件修改要读取或写入的队列</li><li>绑定器 (binder) - 与特定消息平台对话的 Spring 代码，允许开发人员使用通用接口处理消息</li><li>接收器 (sink) - 监听传入消息的通道，将消息反序列化为 Java POJO</li></ul><h2 id="_8-3-编写简单的消息生产者和消费者" tabindex="-1"><a class="header-anchor" href="#_8-3-编写简单的消息生产者和消费者"><span>8.3 编写简单的消息生产者和消费者</span></a></h2><h3 id="_8-3-1-在组织服务中编写消息生产者" tabindex="-1"><a class="header-anchor" href="#_8-3-1-在组织服务中编写消息生产者"><span>8.3.1 在组织服务中编写消息生产者</span></a></h3><p>使服务 B 能够在数据发生变化时，向 <em>Kafka</em> 的特定主题发布一条信息。</p><p>首先需要添加 Maven 依赖项，然后在服务的引导类上添加 <code>@EnableBinding(Source.class)</code> 注解。<code>Source</code> 类定义了通道与消息代理进行通信的方式，开发人员可以自行实现。向消息代理发布消息的逻辑实现如下：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Component</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleSourceBean</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">Source</span> source<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">SimpleSourceBean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 该接口将被自动注入</span></span>
<span class="line">    <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">SimpleSourceBean</span><span class="token punctuation">(</span><span class="token class-name">Source</span> source<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>source <span class="token operator">=</span> source<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">publishOrgChange</span><span class="token punctuation">(</span><span class="token class-name">String</span> action<span class="token punctuation">,</span> <span class="token class-name">String</span> orgId<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">OrganizationChangeModel</span> change <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrganizationChangeModel</span><span class="token punctuation">(</span></span>
<span class="line">            <span class="token class-name">OrganizationChangeModel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getTYpeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">            action<span class="token punctuation">,</span></span>
<span class="line">            orgId<span class="token punctuation">,</span></span>
<span class="line">            <span class="token class-name">UserContext</span><span class="token punctuation">.</span><span class="token function">getCorrelationId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// 发送</span></span>
<span class="line">        source<span class="token punctuation">.</span><span class="token function">output</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withPayload</span><span class="token punctuation">(</span>change<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Source</code> 时 Spring Cloud 定义的接口，其中公开了 <code>output()</code> 函数，用于将消息发送。</p><p>而如何将当前服务绑定到特定的消息队列呢？通过配置来完成。配置能够将 <code>Source</code> 映射到 Kafka 消息代理中的特定主题上：</p><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre><code><span class="line"><span class="token key atrule">spring</span><span class="token punctuation">:</span></span>
<span class="line">  <span class="token key atrule">application</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">name</span><span class="token punctuation">:</span> organizationservice</span>
<span class="line">    <span class="token key atrule">stream</span><span class="token punctuation">:</span></span>
<span class="line">      <span class="token key atrule">binding</span><span class="token punctuation">:</span></span>
<span class="line">        <span class="token key atrule">output</span><span class="token punctuation">:</span></span>
<span class="line">          <span class="token key atrule">destination</span><span class="token punctuation">:</span> orgChangeTopic</span>
<span class="line">          <span class="token key atrule">content-type</span><span class="token punctuation">:</span> application/json</span>
<span class="line">      <span class="token key atrule">kafka</span><span class="token punctuation">:</span></span>
<span class="line">        <span class="token key atrule">binder</span><span class="token punctuation">:</span></span>
<span class="line">          <span class="token key atrule">zkNodes</span><span class="token punctuation">:</span> localhost</span>
<span class="line">          <span class="token key atrule">brokers</span><span class="token punctuation">:</span> localhost</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述配置体现了将 <code>Source</code> 中的 <code>output</code> 通道映射到 <code>orgChangeTopic</code> 消息队列上，消息类型为 JSON。并告诉 Spring 使用了 <em>Kafka</em> 消息队列，以及 <em>Kafka</em> 和 <em>ZooKeeper</em> 的网络位置。</p><p>在需要发布消息的类中，Spring 将自动装配用于发送消息的上述类。调用该类中实现的函数即可：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Service</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrganizationService</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">    <span class="token class-name">SimpleSourceBean</span> simpleSourceBean<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">saveOrg</span><span class="token punctuation">(</span><span class="token class-name">Organization</span> org<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// ...</span></span>
<span class="line">        <span class="token class-name">SimpleSourceBean</span><span class="token punctuation">.</span><span class="token function">publishOrgChange</span><span class="token punctuation">(</span><span class="token string">&quot;SAVE&quot;</span><span class="token punctuation">,</span> org<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// ...</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_8-3-2-在许可证服务中编写消息消费者" tabindex="-1"><a class="header-anchor" href="#_8-3-2-在许可证服务中编写消息消费者"><span>8.3.2 在许可证服务中编写消息消费者</span></a></h3><p>消息消费者监听消息队列中的消息来对组织服务中的更改做出反应。首先还是需要添加 Maven 依赖项，然后标记引导类。标记的方式与生产者有些不同：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@EnableBinding</span><span class="token punctuation">(</span><span class="token class-name">Sink</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@StreamListener</span><span class="token punctuation">(</span><span class="token class-name">Sink</span><span class="token punctuation">.</span><span class="token constant">INPUT</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">loggerSink</span><span class="token punctuation">(</span><span class="token class-name">OrganizationChangeModel</span> orgChange<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// ...</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里将会默认使用 Spring 的 <code>Sink</code> 接口，<code>Sink</code> 接口中公开了一个默认的 <code>input</code> 通道。每次从 <code>input</code> 通道中接收到消息，都会调用上述函数，并自动将消息反序列化为 <code>OrganizationChangeModel</code> 的 Java POJO。</p><p>同样，消息队列到 <code>input</code> 通道的映射是由配置完成的：</p><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre><code><span class="line"><span class="token key atrule">spring</span><span class="token punctuation">:</span></span>
<span class="line">  <span class="token key atrule">application</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">name</span><span class="token punctuation">:</span> licensingservice</span>
<span class="line">  <span class="token key atrule">cloud</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">stream</span><span class="token punctuation">:</span></span>
<span class="line">      <span class="token key atrule">bindings</span><span class="token punctuation">:</span></span>
<span class="line">        <span class="token key atrule">input</span><span class="token punctuation">:</span></span>
<span class="line">          <span class="token key atrule">destination</span><span class="token punctuation">:</span> orgChangeTopic</span>
<span class="line">          <span class="token key atrule">content-type</span><span class="token punctuation">:</span> application/json</span>
<span class="line">          <span class="token key atrule">group</span><span class="token punctuation">:</span> licensingGroup</span>
<span class="line">        <span class="token key atrule">binder</span><span class="token punctuation">:</span></span>
<span class="line">          <span class="token key atrule">zkNodes</span><span class="token punctuation">:</span> localhost</span>
<span class="line">          <span class="token key atrule">brokers</span><span class="token punctuation">:</span> localhost</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将 <code>input</code> 通道与远程消息队列关联。另外，注意这里的 <code>group</code> 属性，定义了将要消费消息的组名称。每个服务可能会有多个实例正在监听消息队列，这些实例同属一个组。Spring Cloud Stream 和底层消息代理将保证，只有消息的 <strong>一个副本</strong> 会被属于该组的服务实例所使用。换句话说，消费者组可以强制跨多个服务消费的信息 <strong>只被消费一次</strong>。</p><h2 id="_8-4-spring-cloud-stream-用例-分布式缓存" tabindex="-1"><a class="header-anchor" href="#_8-4-spring-cloud-stream-用例-分布式缓存"><span>8.4 Spring Cloud Stream 用例：分布式缓存</span></a></h2><h3 id="_8-4-2-定义自定义通道" tabindex="-1"><a class="header-anchor" href="#_8-4-2-定义自定义通道"><span>8.4.2 定义自定义通道</span></a></h3><p>开发人员可以为应用程序公开任意数量和名称的输入和输出通道。以消息消费者为例，需要定义一个接口，并用 <code>@Input</code> 函数级注解标记一个返回 <code>SubscribableChannel</code> 类对象的函数，通过这个注解指明通道的名称；消息生产者也是类似，只不过注解变为 <code>@OutputChannel</code>，返回的对象类为 <code>MessageChannel</code>：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CustomChannels</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token annotation punctuation">@Input</span><span class="token punctuation">(</span><span class="token string">&quot;inboundOrgChanges&quot;</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token class-name">SubscribableChannel</span> <span class="token function">orgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@OutputChannel</span><span class="token punctuation">(</span><span class="token string">&quot;outboundOrg&quot;</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token class-name">MessageChannel</span> <span class="token function">outboundOrg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还需要在配置中将通道名与消息队列名进行映射：</p><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre><code><span class="line"><span class="token key atrule">spring</span><span class="token punctuation">:</span></span>
<span class="line">  <span class="token key atrule">stream</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">bindings</span><span class="token punctuation">:</span></span>
<span class="line">      <span class="token key atrule">inboundOrgChanges</span><span class="token punctuation">:</span></span>
<span class="line">        <span class="token key atrule">destination</span><span class="token punctuation">:</span> orgChangeTopic</span>
<span class="line">        <span class="token key atrule">content-type</span><span class="token punctuation">:</span> application/json</span>
<span class="line">        <span class="token key atrule">group</span><span class="token punctuation">:</span> licensingGroup</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而使用自定义通道时，在应用程序中传入的就是上面定义的接口类了：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@EnableBinding</span><span class="token punctuation">(</span><span class="token class-name">CustomChannels</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token comment">// 接口类</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrganizationChangeHandler</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@StreamListener</span><span class="token punctuation">(</span><span class="token string">&quot;inboundOrgChanges&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 通道名</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">loggerSink</span><span class="token punctuation">(</span><span class="token class-name">OrganizationChangeModel</span> orgChange<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// ...</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,48)]))}const o=s(l,[["render",t],["__file","Chapter 8 - 使用 Spring Cloud Stream 的事件驱动架构.html.vue"]]),u=JSON.parse('{"path":"/spring-microservices-notes/Chapter%208%20-%20%E4%BD%BF%E7%94%A8%20Spring%20Cloud%20Stream%20%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84.html","title":"Chapter 8 - 使用 Spring Cloud Stream 的事件驱动架构","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"8.1 为什么使用消息传递、EDA 和微服务","slug":"_8-1-为什么使用消息传递、eda-和微服务","link":"#_8-1-为什么使用消息传递、eda-和微服务","children":[{"level":3,"title":"8.1.1 使用同步请求 - 响应方式来传达状态变化","slug":"_8-1-1-使用同步请求-响应方式来传达状态变化","link":"#_8-1-1-使用同步请求-响应方式来传达状态变化","children":[]},{"level":3,"title":"8.1.2 使用消息传递在服务之间传达状态更改","slug":"_8-1-2-使用消息传递在服务之间传达状态更改","link":"#_8-1-2-使用消息传递在服务之间传达状态更改","children":[]}]},{"level":2,"title":"8.2 Spring Cloud Stream 简介","slug":"_8-2-spring-cloud-stream-简介","link":"#_8-2-spring-cloud-stream-简介","children":[]},{"level":2,"title":"8.3 编写简单的消息生产者和消费者","slug":"_8-3-编写简单的消息生产者和消费者","link":"#_8-3-编写简单的消息生产者和消费者","children":[{"level":3,"title":"8.3.1 在组织服务中编写消息生产者","slug":"_8-3-1-在组织服务中编写消息生产者","link":"#_8-3-1-在组织服务中编写消息生产者","children":[]},{"level":3,"title":"8.3.2 在许可证服务中编写消息消费者","slug":"_8-3-2-在许可证服务中编写消息消费者","link":"#_8-3-2-在许可证服务中编写消息消费者","children":[]}]},{"level":2,"title":"8.4 Spring Cloud Stream 用例：分布式缓存","slug":"_8-4-spring-cloud-stream-用例-分布式缓存","link":"#_8-4-spring-cloud-stream-用例-分布式缓存","children":[{"level":3,"title":"8.4.2 定义自定义通道","slug":"_8-4-2-定义自定义通道","link":"#_8-4-2-定义自定义通道","children":[]}]}],"git":{},"filePathRelative":"spring-microservices-notes/Chapter 8 - 使用 Spring Cloud Stream 的事件驱动架构.md"}');export{o as comp,u as data};
