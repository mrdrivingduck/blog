import{_ as e,c as s,a,o as l}from"./app-BeHGwf2X.js";const i={};function t(p,n){return l(),s("div",null,n[0]||(n[0]=[a(`<h1 id="chapter-16-sentinel" tabindex="-1"><a class="header-anchor" href="#chapter-16-sentinel"><span>Chapter 16 - Sentinel</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 06 / 14 10:42</p><p>Nanjing, Jiangsu, China</p><hr><p>Sentinel 是 Redis 的高可用性 (hign availability) 解决方案。由一个或多个 Sentinel 实例组成的系统可以监视任意多个主服务器、从服务器。当被监视的主服务器下线时，自动将该服务器的某个从服务器升级为新的主服务器，代替原有的主服务器继续处理请求。</p><ul><li>Sentinel 首先挑选一个下线服务器的从服务器，升级为新的主服务器</li><li>向原主服务器下属的其它从服务器发送复制指令，复制新的主服务器 (故障转移)</li><li>Sentinel 继续监视已下线的原主服务器，如果其重新上线，则将其设置为新的主服务器的从服务器</li></ul><h2 id="sentinel-的启动与初始化" tabindex="-1"><a class="header-anchor" href="#sentinel-的启动与初始化"><span>Sentinel 的启动与初始化</span></a></h2><p>Sentinel 的本质是一个运行在特殊模式下的 Redis 服务器。启动 Sentinel，首先需要与启动服务器类似，初始化一个服务器。然后再将一部分普通 Redis 服务器的代码替换为 Sentinel 专用代码。比如，Sentinel 有着不同于普通 Redis 服务器的命令表。</p><p>接下来，服务器初始化一个 Sentinel 的状态结构体，保存了所有与 Sentinel 功能有关的状态：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">sentinelState</span> <span class="token punctuation">{</span></span>
<span class="line">    uint_64 current_epoch<span class="token punctuation">;</span> <span class="token comment">// 当前纪元 (用于故障转移)</span></span>
<span class="line">    dict <span class="token operator">*</span>masters<span class="token punctuation">;</span> <span class="token comment">// Sentinel 监视的所有主服务器</span></span>
<span class="line">    <span class="token keyword">int</span> tilt<span class="token punctuation">;</span> <span class="token comment">// TILT 模式</span></span>
<span class="line">    <span class="token keyword">int</span> running_scripts<span class="token punctuation">;</span> <span class="token comment">// 目前正在执行脚本的数量</span></span>
<span class="line">    <span class="token class-name">mstime_t</span> tilt_start_time<span class="token punctuation">;</span> <span class="token comment">// 最后一次执行时间处理器的时间</span></span>
<span class="line">    list <span class="token operator">*</span>scripts_queue<span class="token punctuation">;</span> <span class="token comment">// 需要执行的用户脚本的 FIFO 队列</span></span>
<span class="line"><span class="token punctuation">}</span> sentinel<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，初始化 <code>master</code> 字典中所有被 Sentinel 监视的主服务器信息。字典的 key 是主服务器的名字，value 是描述 Redis 服务器信息的 <code>sentinelRedisInstance</code> 结构体：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">sentinelRedisInstance</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">int</span> flags<span class="token punctuation">;</span> <span class="token comment">// 实例的类型与当前状态</span></span>
<span class="line">    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span> <span class="token comment">// 实例的名字</span></span>
<span class="line">    <span class="token keyword">char</span> <span class="token operator">*</span>runid<span class="token punctuation">;</span> <span class="token comment">// 实例运行 ID</span></span>
<span class="line">    <span class="token class-name">uint64_t</span> config_epoch<span class="token punctuation">;</span> <span class="token comment">// 纪元，用于故障转移</span></span>
<span class="line">    sentinelAddr <span class="token operator">*</span>addr<span class="token punctuation">;</span> <span class="token comment">// 实例地址 (IP + 端口号)</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">mstime_t</span> down_after_period<span class="token punctuation">;</span> <span class="token comment">// 被判断为主观下线的时间阈值</span></span>
<span class="line">    <span class="token keyword">int</span> quorum<span class="token punctuation">;</span> <span class="token comment">// 判断实例客观下线所需的投票数量</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">int</span> parallel_syncs<span class="token punctuation">;</span> <span class="token comment">// 故障转移过程中，可以同时对新的主服务器进行同步的从服务器数量</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">mstime_t</span> failover_timeout<span class="token punctuation">;</span> <span class="token comment">// 刷新故障迁移状态的最大时限</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述结构体的初始化基于载入的 Sentinel 配置文件进行。初始化结束后，Sentinel 作为主服务器的客户端，向被监视的主服务器创建网络连接，从而开始监视主服务器的运行。Sentinel 会与其监视的每一个主服务器建立两个连接：</p><ul><li>命令连接 - 用于向主服务器发送命令，并接收命令回复</li><li>订阅连接 - 专门用于订阅主服务器的 <code>__sentinel__:hello</code> 频道</li></ul><h2 id="获取主服务器信息" tabindex="-1"><a class="header-anchor" href="#获取主服务器信息"><span>获取主服务器信息</span></a></h2><p>Sentinel 默认以十秒一次的频率，通过 <strong>命令连接</strong>，向主服务器发送 <code>INFO</code> 命令。根据命令回复，Sentinel 可以获得两方面信息：</p><ul><li>主服务器本身的信息</li><li>主服务器下属的所有从服务器信息 (因此 Sentinel 可以自动发现从服务器)</li></ul><p>Sentinel 根据获得的信息，对自身维护的主服务器状态进行更新维护，包括维护 <code>slaves</code> 字典中所有从服务器的信息。</p><h2 id="获取从服务器信息" tabindex="-1"><a class="header-anchor" href="#获取从服务器信息"><span>获取从服务器信息</span></a></h2><p>当 Sentinel 发现主服务器中有新的从服务器出现，除了建立相应的状态结构外，Sentinel 也会创建连接到从服务器的 <strong>命令连接</strong> + <strong>订阅连接</strong>。然后 Sentinel 也会默认以十秒一次的频率向从服务器发送 <code>INFO</code> 命令，获取其状态信息，并更新维护自身的结构。</p><h2 id="向主服务器和从服务器发送信息" tabindex="-1"><a class="header-anchor" href="#向主服务器和从服务器发送信息"><span>向主服务器和从服务器发送信息</span></a></h2><p>默认情况下，Sentinel 会以两秒一次的频率，通过命令连接，向所有被监视的主从服务器发送 <code>PUBLISH</code> 命令。该命令会在服务器的 <code>__sentinel__:hello</code> 频道中发送信息，信息中包含：</p><ul><li>Sentinel 自身的信息</li><li>被监视的主服务器信息</li></ul><h2 id="接收来自主从服务器的频道信息" tabindex="-1"><a class="header-anchor" href="#接收来自主从服务器的频道信息"><span>接收来自主从服务器的频道信息</span></a></h2><p>Sentinel 会通过 <strong>订阅连接</strong> 向服务器发送 <code>SUBSCRIBE __sentinel__:hello</code>，对该频道的订阅会持续到 Sentinel 与服务器的连接断开为止。</p><blockquote><p>Sentinel 通过命令连接向服务器的 <code>__sentinel__:hello</code> 频道 <strong>发送</strong> 信息，又通过订阅连接从服务器的这个频道 <strong>接收</strong> 消息。</p></blockquote><p>对于监视同一个服务器的多个 Sentinel，一个 Sentinel 发送的信息将被其它 Sentinel 接收到，用于更新其它 Sentinel 对发送信息的 Sentinel 和服务器的认知。Sentinel 维护的主服务器状态结构中有一个 <code>sentinel</code> 字典，保存了同样监视着该主服务器的其它 Sentinel 的信息，如 IP、端口号、运行 ID、配置纪元等。</p><p>Sentinel 还会对其发现的另一个 Sentinel 创建命令连接，<strong>不创建</strong> 订阅连接。最终，监视同一主服务器的多个 Sentinel 将形成一个互联网络。</p><h2 id="检测主观下线状态" tabindex="-1"><a class="header-anchor" href="#检测主观下线状态"><span>检测主观下线状态</span></a></h2><p>默认情况下，Sentinel 以每秒一次的频率向所有命令连接 (主服务器、从服务器、Sentinel) 发送 <code>PING</code> 命令，根据配置文件中的 <code>down-after-milliseconds</code> 毫秒内连续向 Sentinel 返回无效回复，那么 Sentinel 在其维护的实例结构中标记这个服务器为 <strong>主观下线状态</strong> (&quot;我觉得它已经下线了，你们怎么看？&quot;)。</p><h2 id="检测客观下线状态" tabindex="-1"><a class="header-anchor" href="#检测客观下线状态"><span>检测客观下线状态</span></a></h2><p>Sentinel 将一个主服务器标记为主观下线后，会向同样监视该主服务器的其它 Sentinel 发送询问命令 <code>SENTINEL is-master-down-by-addr</code>，以确认这个主服务器是否真的下线了。被询问的 Sentinel 发送回复后，如果统计其它 Sentinel 同意主服务器已下线的数量超过了判断阈值 (类比半数以上的投票)，那么 Sentinel 会将主服务器实例结构的 <code>SRI_O_DOWN</code> 标识打开，表示主服务器进入 <strong>客观下线状态</strong> (大家都觉得这个服务器挂了)。</p><ul><li>主观下线状态是由每个 Sentinel 自行探测得到的结论</li><li>客观下线状态取决于投票阈值的设定，每个 Sentinel 都可能不一样</li></ul><h2 id="选举领头-sentinel" tabindex="-1"><a class="header-anchor" href="#选举领头-sentinel"><span>选举领头 Sentinel</span></a></h2><p>在主服务器被判断为客观下线后，监视该主服务器的各 Sentinel 会进行协商，选举出一个领头 Sentinel 来进行之后的 <strong>故障转移</strong>。所有的 Sentinel 都有被选举为领头 Sentinel 的资格。</p><ul><li>每一轮选举后，所有 Sentinel 的配置纪元都会 +1</li><li>每轮选举中，每个 Sentinel 都能投一票</li><li>每个认为主服务器客观下线的 Sentinel 都会要求其它 Sentinel 投自己一票 (通过自己的运行 ID)</li><li>进行投票的 Sentinel 的规则是先到先得，谁先找我拉票我就投谁一票，之后的拉票请求被我忽视</li><li>如果某个 Sentinel 被半数以上的 Sentinel 投票，那么就成为了领头 Sentinel</li><li>如果给定时间内没有选出领头，那么一段时间后再进行一轮选举，直到选出领头 Sentinel 为止</li></ul><h2 id="故障转移" tabindex="-1"><a class="header-anchor" href="#故障转移"><span>故障转移</span></a></h2><p>领头 Sentinel 将对已下线的主服务器执行故障转移。</p><p>首先，在已下线的主服务器的所有从服务器中，挑选出一个状态良好、数据完整的从服务器，然后发送 <code>SLAVEOF no one</code>，将这个从服务器转换为主服务器。挑选原则：</p><ul><li>从服务器正常在线</li><li>最近与 Sentinel 成功进行过通信</li><li>与主服务器较晚断开连接 (从服务器保存的数据比较新)</li><li>偏移量较大的从服务器 (最新数据)</li><li>运行 ID 最小 (?)</li></ul><p>选出新的主服务器后，领头 Sentinel 会让所有的从服务器复制新的主服务器。</p><p>最终，将已下线的主服务器设置为新主服务器的从服务器。当这个断线服务器重新上线时，Sentinel 会让其从新的主服务器拷贝副本。</p>`,43)]))}const o=e(i,[["render",t],["__file","Chapter 16 - Sentinel.html.vue"]]),d=JSON.parse('{"path":"/redis-implementation-notes/Part%203%20-%20%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/Chapter%2016%20-%20Sentinel.html","title":"Chapter 16 - Sentinel","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Sentinel 的启动与初始化","slug":"sentinel-的启动与初始化","link":"#sentinel-的启动与初始化","children":[]},{"level":2,"title":"获取主服务器信息","slug":"获取主服务器信息","link":"#获取主服务器信息","children":[]},{"level":2,"title":"获取从服务器信息","slug":"获取从服务器信息","link":"#获取从服务器信息","children":[]},{"level":2,"title":"向主服务器和从服务器发送信息","slug":"向主服务器和从服务器发送信息","link":"#向主服务器和从服务器发送信息","children":[]},{"level":2,"title":"接收来自主从服务器的频道信息","slug":"接收来自主从服务器的频道信息","link":"#接收来自主从服务器的频道信息","children":[]},{"level":2,"title":"检测主观下线状态","slug":"检测主观下线状态","link":"#检测主观下线状态","children":[]},{"level":2,"title":"检测客观下线状态","slug":"检测客观下线状态","link":"#检测客观下线状态","children":[]},{"level":2,"title":"选举领头 Sentinel","slug":"选举领头-sentinel","link":"#选举领头-sentinel","children":[]},{"level":2,"title":"故障转移","slug":"故障转移","link":"#故障转移","children":[]}],"git":{},"filePathRelative":"redis-implementation-notes/Part 3 - 多机数据库的实现/Chapter 16 - Sentinel.md"}');export{o as comp,d as data};
