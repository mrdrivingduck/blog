import{_ as o,c,a as l,o as d}from"./app-BeHGwf2X.js";const i={};function a(r,e){return d(),c("div",null,e[0]||(e[0]=[l('<h1 id="java-thread-pool" tabindex="-1"><a class="header-anchor" href="#java-thread-pool"><span>Java - Thread Pool</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 11 / 02 16:17</p><p>Nanjing, Jiangsu, China</p><hr><p>线程池技术预先创建了若干数量的线程，用户不能直接对线程的创建进行控制。在这一前提下，重复使用固定或较为固定数目的线程来完成任务的执行。合理使用线程池能够带来的好处如下：</p><ol><li>重复利用已创建的线程，降低了线程 <strong>创建</strong> 和 <strong>销毁</strong> 造成的开销</li><li>任务到达时，无需等到线程创建就能立刻执行，提高了响应速度</li><li>对线程统一分配、调优、监控，提高了线程的客观理性</li></ol><h2 id="theory" tabindex="-1"><a class="header-anchor" href="#theory"><span>Theory</span></a></h2><p>线程池的工作原理如下：</p><ol><li>线程池中的线程数还没有达到设定值，则创建新线程处理任务 (预热)</li><li>线程池中的线程数达到设定值，则将要处理的任务添加到工作队列中</li><li>线程执行完一个任务后，从工作队列中取出下一个任务继续运行</li><li>如果工作队列已满，则由 <strong>饱和策略</strong> 来处理任务</li></ol><p>也可以通过选项一次性创建线程池中的所有线程。</p><h2 id="parameters" tabindex="-1"><a class="header-anchor" href="#parameters"><span>Parameters</span></a></h2><ul><li><code>corePoolSize</code> - 线程池基本大小，当需要执行的任务数超过线程池基本大小时，不再创建新的线程</li><li><code>runnableTaskQueue</code> - 阻塞队列，用于保存等待被执行的任务 <ul><li><code>ArrayBlockingQueue</code> - 基于数组的有界阻塞队列</li><li><code>LinkedBlockingQueue</code> - 基于链表的阻塞队列</li><li><code>SynchronousQueue</code> - 阻塞队列，插入操作与移除操作必须一一匹配</li><li><code>PriorityBlockingQueue</code> - 具有优先级的无界阻塞队列</li></ul></li><li><code>maximumPoolSize</code> - 线程池允许创建的最大线程数，在阻塞队列已满时继续创建线程的阈值 (如果阻塞队列无界，那么该参数就没有什么效果)</li><li><code>RejectExecutionHandler</code> - 饱和策略，当队列和线程池都满时，对新任务的策略 <ul><li><code>AbortPolicy</code> - 直接抛出异常</li><li><code>CallerRunsPolicy</code> - 由调用者所在线程运行任务</li><li><code>DiscardOldestPolicy</code> - 丢掉队列里最老的任务，并试图添加新的任务</li><li><code>DiscardPolicy</code> - 不处理新任务</li><li>实现 <code>RejectedExecutionHandler</code> 接口自行定义策略</li></ul></li><li>时间参数 <ul><li><code>keepAliveTime</code> - 超出线程池 <code>corePoolSize</code> 的工作线程空闲后保持存活的时间</li><li><code>TimeUnit</code> - 线程活动保持时间的单位</li></ul></li></ul><h2 id="submission" tabindex="-1"><a class="header-anchor" href="#submission"><span>Submission</span></a></h2><p><code>execute()</code> 函数用于提交不需要返回值的任务，输入参数是一个 <code>Runnable</code> 类的实例。因此无法判断任务是否被线程池执行成功。<code>submit()</code> 函数用于提交需要返回值的任务，线程池会返回一个 <code>Future</code> 类型的对象，通过该对象判断任务是否被执行成功，并获取返回值。</p><h2 id="shut-down" tabindex="-1"><a class="header-anchor" href="#shut-down"><span>Shut Down</span></a></h2><p>关闭线程池的原理是通过遍历线程池中的每个线程，逐个调用线程的 <code>interrupt()</code> 函数来中断线程 - 因此无法响应中断的任务可能永远无法终止。<code>shutdownNow()</code> 将线程池的状态设置为 <code>STOP</code>，并尝试停止所有线程；<code>shutdown()</code> 则只是将线程池的状态设置为 <code>SHUTDOWN</code>，并中断所有空闲线程。</p><p>调用以上两个函数中的任意一个，<code>isShutdown</code> 就会返回 <code>true</code>；当所有任务都关闭后，<code>isTerminated</code> 返回 <code>true</code>，线程池才算关闭成功。</p><h2 id="configuration" tabindex="-1"><a class="header-anchor" href="#configuration"><span>Configuration</span></a></h2><p>合理配置先线程池所需要考虑的要素：</p><ul><li>任务性质 - CPU 密集 / I/O 密集 / 混合型</li><li>任务优先级 - 高 / 中 / 低</li><li>任务的执行时间 - 长 / 中 / 短</li><li>任务的依赖性 - 是否依赖其它系统资源</li></ul><p>CPU 密集型任务应当配置尽可能少的线程 (接近处理器个数)，以便减少上下文切换开销；I/O 密集型任务应配置尽可能多的线程。</p><p>有界的阻塞队列能够增强系统的稳定性和预警能力。无界队列可能会使线程池队列越来越长，撑满内存，导致整个系统不可用。</p><h2 id="executor-framework" tabindex="-1"><a class="header-anchor" href="#executor-framework"><span>Executor Framework</span></a></h2><p>HotSpot 虚拟机将 Java 线程一对一映射为本地 OS 的线程。在上层，Java 多线程程序使用用户空间的调度器 Executor 框架将任务映射到固定数量的线程。</p><h3 id="tasks" tabindex="-1"><a class="header-anchor" href="#tasks"><span>Tasks</span></a></h3><p>Executor 框架中的任务需要实现 <code>Runnable</code> 接口或 <code>Callable</code> 接口。</p><h3 id="executors" tabindex="-1"><a class="header-anchor" href="#executors"><span>Executors</span></a></h3><p><code>ThreadPoolExecutor</code> 是线程池的核心实现类，用于执行被提交的任务。根据使用场景分别实现了：</p><ul><li><code>FixedThreadPool</code> - 固定线程数的线程池，以 <code>LinkedBlockingQueue</code> 作为工作队列，可以无限延长，因此线程池也永远不会拒绝新任务，并且线程池中的线程数不会超出 <code>corePoolSize</code>，另外 <code>maximumPoolSize</code> 和 <code>keepAliveTime</code> 参数无效</li><li><code>SingleThreadExecutor</code> - 单工作线程的线程池，也使用 <code>LinkedBlockingQueue</code> 作为工作队列，<code>corePoolSize</code> 参数被设置为 <code>1</code>，只有一个工作线程不断从工作队列中获取任务执行</li><li><code>CachedThreadPool</code> - 根据需要创建新线程的线程池，<code>corePoolSize</code> 被设置为 <code>0</code>，<code>maximumPoolSize</code> 被设置为 <code>Integer.MAX_VALUE</code>，即线程池无界；<code>keepAliveTime</code> 被设置为 <code>60L</code>，表示一个线程在空闲 60s 后将会被终止；内部使用 <code>SynchronousQueue</code> 作为线程池的工作队列</li></ul><p><code>ScheduledThreadPoolExecutor</code> 继承自 <code>ThreadPoolExecutor</code>，用于在给定的延迟之后运行任务，或者定期执行任务。其内部维护了一个 <code>DelayQueue</code>，内部实际上是一个以时间为优先级的优先队列，而 JDK 优先队列的实现是自增长的，所以 <code>maximumPoolSize</code> 参数并没有实际意义。任务在被封装为 <code>ScheduledThreadPoolExecutor</code> 后加入延时队列，包含参数：</p><ul><li><code>time</code> - 任务要被执行的具体时间</li><li><code>ssequenceNumber</code> - 任务被添加到调度器中的序号</li><li><code>period</code> - 任务被执行的间隔周期</li></ul><p>线程会从延时队列中取出最早到期的 <code>ScheduledFutureTask</code>，执行并修改 <code>time</code> 为下次要被执行的时间后，再放回延时队列中。</p><hr>',34)]))}const t=o(i,[["render",a],["__file","Java Thread Pool.html.vue"]]),s=JSON.parse('{"path":"/notes/Java/Java%20Thread%20Pool.html","title":"Java - Thread Pool","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Theory","slug":"theory","link":"#theory","children":[]},{"level":2,"title":"Parameters","slug":"parameters","link":"#parameters","children":[]},{"level":2,"title":"Submission","slug":"submission","link":"#submission","children":[]},{"level":2,"title":"Shut Down","slug":"shut-down","link":"#shut-down","children":[]},{"level":2,"title":"Configuration","slug":"configuration","link":"#configuration","children":[]},{"level":2,"title":"Executor Framework","slug":"executor-framework","link":"#executor-framework","children":[{"level":3,"title":"Tasks","slug":"tasks","link":"#tasks","children":[]},{"level":3,"title":"Executors","slug":"executors","link":"#executors","children":[]}]}],"git":{},"filePathRelative":"notes/Java/Java Thread Pool.md"}');export{t as comp,s as data};
