import{_ as a,c as i,a as e,o as s}from"./app-7eKjwDat.js";const n={};function t(o,l){return s(),i("div",null,l[0]||(l[0]=[e('<h1 id="chapter-7-虚拟机类加载机制" tabindex="-1"><a class="header-anchor" href="#chapter-7-虚拟机类加载机制"><span>Chapter 7 - 虚拟机类加载机制</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 01 / 29 22:12 🧨🧧</p><p>Ningbo, Zhejiang, China</p><hr><h2 id="_7-1-概述" tabindex="-1"><a class="header-anchor" href="#_7-1-概述"><span>7.1 概述</span></a></h2><p>Class 文件中描述的各类信息，最终都需要加载到 JVM 中才能被运行和使用。<strong>类加载</strong>：JVM 把 Class 文件加载到内存中，并对数据进行校验、转换、解析和初始化，最终形成可以被 JVM 使用的 Java 类型。类型的加载、链接、初始化都在程序 <strong>运行时</strong> 完成，因此会有一定的性能开销。</p><hr><h2 id="_7-2-类加载的时机" tabindex="-1"><a class="header-anchor" href="#_7-2-类加载的时机"><span>7.2 类加载的时机</span></a></h2><p>一个类型从被加载到 JVM 内存中开始，到卸载出内存，包含七个阶段：</p><ul><li>加载 (Loading)</li><li>验证 (Verification)</li><li>准备 (Preparation)</li><li>解析 (Resolution)</li><li>初始化 (Initialization)</li><li>使用 (Using)</li><li>卸载 (Unloading)</li></ul><p>其中，验证、准备、解析三个阶段统称为链接 (Linking)。JVM 的规范并没有规定在什么情况下需要开始第一阶段的加载，由 JVM 的具体实现自由把握。而对于 <strong>初始化</strong> 阶段，则有且只有六种情况才会触发：</p><ol><li>遇到 <code>new</code> <code>getstatic</code> <code>putstatic</code> <code>invokestatic</code> 四条字节码指令时，且类型没有初始化；能生成这些字节码的场景： <ul><li>用 <code>new</code> 关键字实例化对象</li><li>读取或设置一个静态字段</li><li>调用一个类型的静态方法</li></ul></li><li>对类型进行反射调用时，且类型没有进行过初始化</li><li>当初始化类时，发现其父类还没有进行过初始化时</li><li>当 JVM 启动时，用户指定一个要执行的主类</li><li>动态语言支持</li><li>当接口定义了默认方法，且该接口的实现类发生了初始化</li></ol><p>以上六种场景称为对类型进行 <strong>主动引用</strong>。</p><hr><h2 id="_7-3-类加载的过程" tabindex="-1"><a class="header-anchor" href="#_7-3-类加载的过程"><span>7.3 类加载的过程</span></a></h2><h3 id="_7-3-1-加载" tabindex="-1"><a class="header-anchor" href="#_7-3-1-加载"><span>7.3.1 加载</span></a></h3><p>JVM 需要完成以下三件事情：</p><ol><li>通过一个类的 <strong>全限定名</strong> 来获取定义该类的二进制字节流</li><li>将字节流代表的 <strong>静态存储结构</strong> 转化为方法区的 <strong>运行时数据结构</strong></li><li>在内存中生成代表该类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据的访问入口</li></ol><p>并没有指明字节流的来源一定是 Class 文件，因此还可以从压缩包、网络等途径获取。该阶段既可以使用 JVM 内置的 <strong>引导类加载器</strong> 完成，也可以由用户自定义的类加载器完成：开发人员定义类加载器中字节流的获取方式。</p><p>对于数组而言，数组类本身不通过类加载器创建，由 JVM 直接在内存中动态构造，但数组类的元素类型还是要靠类加载器加载。加载阶段结束后，JVM 外部的二进制字节流就按照 JVM 设定的格式存储在方法区中。方法区中的具体存放格式由 JVM 的实现自行定义。</p><p>当类型数据妥善放置在方法区中后，JVM 会在 Java Heap 上实例化一个 <code>java.lang.Class</code> 类对象。该对象是程序访问方法区中类型数据的外部接口。</p><p><strong>加载</strong> 和 <strong>链接</strong> 阶段的部分动作是交叉进行的，但两个阶段的开始时间依然保持着固定的先后顺序。</p><h3 id="_7-3-2-验证" tabindex="-1"><a class="header-anchor" href="#_7-3-2-验证"><span>7.3.2 验证</span></a></h3><p>确保 Class 文件的字节流中包含的信息符合 JVM 规范中的约束，保证这些信息运行后不会危害虚拟机的安全。Java 语言本身是相对安全的编程语言，对于以下错误：</p><ul><li>访问数组边界以外的数据</li><li>将对象转换为未实现的类型</li><li>跳转到不存在的代码行</li></ul><p>编译器将会抛出异常、拒绝编译。但这些功能在字节码的层面上都是可以实现的。验证阶段大致完成四个阶段的检验：</p><ol><li>文件格式验证 <ul><li>验证字节流是否符合 Class 文件格式的规范</li><li>是否能被当前版本的 JVM 处理</li><li>经过验证后，字节流才可以进入 JVM 的方法区中进行存储</li></ul></li><li>元数据验证 <ul><li>对字节码描述的信息进行语义分析</li><li>对类的 metadata 进行语义校验 (继承关系等)</li></ul></li><li>字节码验证 <ul><li>通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的</li><li>需要对类的方法体进行校验分析，保证运行时不会危害 JVM 的安全</li></ul></li><li>符号引用验证 <ul><li>发生在 JVM 的 <strong>符号引用</strong> 转化为 <strong>直接引用</strong> 时</li><li>检验该类是否缺少或禁止访问它依赖的外部资源</li><li>确保解析行为能正常执行</li></ul></li></ol><h3 id="_7-3-3-准备" tabindex="-1"><a class="header-anchor" href="#_7-3-3-准备"><span>7.3.3 准备</span></a></h3><p>正式为 <strong>类中定义的变量</strong> (静态变量) 分配内存并设置初始值</p><ul><li>仅包括类变量，不包括实例变量</li><li>初始值通常为 0，哪怕代码中定义了初始值，也会在初始化阶段才进行赋值</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>而如果类字段属性表中存在 ConstantValue 属性</p><p>那么在该阶段变量值就会被初始化为指定的值，比如：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_7-3-4-解析" tabindex="-1"><a class="header-anchor" href="#_7-3-4-解析"><span>7.3.4 解析</span></a></h3><p>是 JVM 将常量池内的符号引用替换为直接引用的过程</p><ul><li>符号引用 (Symbolic References) <ul><li>与 JVM 实现的内存布局无关</li><li>引用的目标不一定是已经加载到 JVM 中的内容</li><li>明确定义在 Class 文件格式中</li></ul></li><li>直接引用 (Direct References) <ul><li>是直接可以指向目标的指针、偏移量或能间接定位到目标的句柄</li><li>与 JVM 实现的内存布局直接相关</li><li>引用目标必定已经在 JVM 的内存中</li></ul></li></ul><p>JVM 实现可以根据需要自行判断开始该阶段的时机。对同一个符号引用进行多次解析很常见：</p><ul><li>JVM 实现可以将第一次解析的结果进行缓存</li><li>JVM 需要保证在同一个实体中，如果一个符号引用之前已经被成功解析，那么后续的解析就应当一直能够成功</li></ul><h3 id="_7-3-5-初始化" tabindex="-1"><a class="header-anchor" href="#_7-3-5-初始化"><span>7.3.5 初始化</span></a></h3><p>类初始化是类加载过程的最后一个步骤。直到该阶段，JVM 才真正开始执行类中编写的 Java 代码。该阶段就是执行类构造器 <code>&lt;clinit&gt;()</code> 函数的过程。这不是在 Java 代码中编写的函数，是 Javac 编译器的自动生成物。</p><ul><li>编译器自动收集类中的所有类变量的赋值动作和静态语句块，合并产生</li><li>不需要显式调用父类构造器，保证在子类 <code>&lt;clinit&gt;()</code> 执行前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕</li><li>不是必须的 - (没有静态语句块，没有类变量赋值)</li><li>JVM 需要保证 <code>&lt;clinit&gt;()</code> 在多线程环境中被正确同步，只能由一个线程执行</li></ul><hr><h2 id="_7-4-类加载器" tabindex="-1"><a class="header-anchor" href="#_7-4-类加载器"><span>7.4 类加载器</span></a></h2><p>JVM 设计团队特意把 <strong>通过一个类的全限定名来获取描述该类的二进制流</strong> 的动作放到 JVM 的外部实现。应用程序可以自己决定如何获取所需的类，实现这个动作的代码就是 <strong>类加载器</strong> (Class Loader)。</p><h3 id="_7-4-1-类与类加载器" tabindex="-1"><a class="header-anchor" href="#_7-4-1-类与类加载器"><span>7.4.1 类与类加载器</span></a></h3><p>对于任意一个类，由 <strong>加载它的类加载器</strong> 和 <strong>类本身</strong> 一起确定其在 JVM 中的唯一性。每个类加载器都有独立的类名称空间。比较两个类是否相等，只有在两个类是由同一个类加载器载入 JVM 的前提下才有意义，哪怕它们来自同一个 Class 文件。</p><h3 id="_7-4-2-双亲委派模型" tabindex="-1"><a class="header-anchor" href="#_7-4-2-双亲委派模型"><span>7.4.2 双亲委派模型</span></a></h3><p>从 JVM 的角度来看，只有两种不同的类加载器：</p><ul><li>启动类加载器 (Bootstrap ClassLoader) <ul><li>由 C++ 实现，是 JVM 自身的一部分</li></ul></li><li>其它的所有类加载器 <ul><li>由 Java 实现，独立存在于 JVM 外部</li><li>全部继承自 <code>java.lang.ClassLoader</code></li></ul></li></ul><p>Java 自 JDK 1.2 以来，一直保持 <strong>三层类加载器、双亲委派</strong> 的类加载架构。</p><p>三个系统提供的类加载器：</p><ol><li>启动类加载器 (Bootstrap Class Loader) <ul><li>负责加载 <code>${JAVA_HOME}/lib</code> 目录下的类</li><li>只会加载 JVM 能够识别的类</li><li>这个加载器不能被 Java 程序直接引用，如果需要委托该加载器处理类加载，直接使用 <code>null</code> 作为参数</li></ul></li><li>扩展类加载器 (Extension Class Loader) <ul><li>以 Java 代码的形式实现</li><li>负责加载 <code>${JAVA_HOME}/lib/ext</code> 目录</li><li>允许用户将具有通用性的类库放置在该目录下，扩展 Java SE 的功能</li><li>开发者可以直接在程序中使用扩展类加载器来加载 Class 文件</li></ul></li><li>应用程序类加载器 (Application Class Loader) <ul><li>也称 <em>系统类加载器</em></li><li>负责加载用户类路径 (ClassPath) 下的所有类库</li><li>开发者也可以在程序中使用该类加载器</li></ul></li></ol><p>除了顶层的启动类加载器，所有的类加载器都有其父类加载器。父子关系不使用继承的关系来实现，使用组合关系来复用父类加载器的代码。</p><p>双亲委派模型的工作过程：一个类加载器收到了类加载请求，首先委派自己的父类加载器完成，每个层次的类加载器都是如此；只有父类加载器无法完成加载请求 (搜索范围内没有找到所需的类) 时，子类加载器才会尝试自己完成加载。Java 中的类随着其类加载器一起具备了带有优先级的层次关系：越基础的类，由越高层的类加载器加载，保证了 Java 程序的稳定运作。</p><p>双亲委派模型的实现：</p><ol><li>检查请求加载的类是否已被加载</li><li>若没有加载，则调用父加载器的 <code>loadClass()</code> 方法；若父加载器为空，则使用启动类加载器作为父类加载器</li><li>加入父类加载器加载失败，才调用自己的 <code>findClass()</code> 方法尝试加载</li></ol><hr><h2 id="_7-5-java-模块化系统-java-platform-module-system-jpms" tabindex="-1"><a class="header-anchor" href="#_7-5-java-模块化系统-java-platform-module-system-jpms"><span>7.5 Java 模块化系统 (Java Platform Module System, JPMS)</span></a></h2><p>这是 JDK 9 中引入的特性，不仅像 JAR 包那样只是简单充当代码的容器，还包括：</p><ul><li>依赖其它模块的列表</li><li>导出的包列表 (其它模块可以使用的列表)</li><li>开放的包列表 (其它模块可反射访问模块的列表)</li><li>使用的服务列表</li><li>提供服务的实现列表</li></ul><p>模块声明了对其它模块的显式依赖。一些异常就不会在运行到类加载时才抛出，而是直接从依赖中得出。可配置的 <strong>封装隔离机制</strong> 还解决了跨 JAR 文件的 <code>public</code> 类型的可访问性问题：JDK 9 中的 <code>public</code> 关键字不再意味着程序的所有代码都可以随意访问它。</p><p>模块提供了更精细的访问控制，必须明确声明哪一些 <code>public</code> 类型可以被其它哪一些模块访问。</p>',64)]))}const p=a(n,[["render",t],["__file","Chapter 7 - 虚拟机类加载机制.html.vue"]]),d=JSON.parse('{"path":"/understanding-the-jvm-notes/Part%203%20-%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/Chapter%207%20-%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html","title":"Chapter 7 - 虚拟机类加载机制","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"7.1 概述","slug":"_7-1-概述","link":"#_7-1-概述","children":[]},{"level":2,"title":"7.2 类加载的时机","slug":"_7-2-类加载的时机","link":"#_7-2-类加载的时机","children":[]},{"level":2,"title":"7.3 类加载的过程","slug":"_7-3-类加载的过程","link":"#_7-3-类加载的过程","children":[{"level":3,"title":"7.3.1 加载","slug":"_7-3-1-加载","link":"#_7-3-1-加载","children":[]},{"level":3,"title":"7.3.2 验证","slug":"_7-3-2-验证","link":"#_7-3-2-验证","children":[]},{"level":3,"title":"7.3.3 准备","slug":"_7-3-3-准备","link":"#_7-3-3-准备","children":[]},{"level":3,"title":"7.3.4 解析","slug":"_7-3-4-解析","link":"#_7-3-4-解析","children":[]},{"level":3,"title":"7.3.5 初始化","slug":"_7-3-5-初始化","link":"#_7-3-5-初始化","children":[]}]},{"level":2,"title":"7.4 类加载器","slug":"_7-4-类加载器","link":"#_7-4-类加载器","children":[{"level":3,"title":"7.4.1 类与类加载器","slug":"_7-4-1-类与类加载器","link":"#_7-4-1-类与类加载器","children":[]},{"level":3,"title":"7.4.2 双亲委派模型","slug":"_7-4-2-双亲委派模型","link":"#_7-4-2-双亲委派模型","children":[]}]},{"level":2,"title":"7.5 Java 模块化系统 (Java Platform Module System, JPMS)","slug":"_7-5-java-模块化系统-java-platform-module-system-jpms","link":"#_7-5-java-模块化系统-java-platform-module-system-jpms","children":[]}],"git":{},"filePathRelative":"understanding-the-jvm-notes/Part 3 - 虚拟机执行子系统/Chapter 7 - 虚拟机类加载机制.md"}');export{p as comp,d as data};
