import{_ as a,c as s,a as n,o as t}from"./app-BeHGwf2X.js";const c={};function o(l,e){return t(),s("div",null,e[0]||(e[0]=[n(`<h1 id="solidity-types" tabindex="-1"><a class="header-anchor" href="#solidity-types"><span>Solidity - Types</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 02 / 25 22:20</p><p>Ningbo, Zhejiang, China</p><hr><h2 id="value-types" tabindex="-1"><a class="header-anchor" href="#value-types"><span>Value Types</span></a></h2><h3 id="booleans" tabindex="-1"><a class="header-anchor" href="#booleans"><span>Booleans</span></a></h3><p><code>bool</code> - <code>true</code> / <code>false</code>，运算符同 C 语言。</p><h3 id="integers" tabindex="-1"><a class="header-anchor" href="#integers"><span>Integers</span></a></h3><ul><li><code>uint8</code> / <code>int8</code></li><li>...</li><li><code>uint256</code> (<code>uint</code>) / <code>int156</code> (<code>int</code>)</li></ul><p>数据宽度以 8 位为单位增长。比较运算符、位运算符、移位运算符、数学运算符同 C 语言。</p><p>幂运算符 <code>**</code> - <code>2**32</code></p><h3 id="fixed-point-numbers" tabindex="-1"><a class="header-anchor" href="#fixed-point-numbers"><span>Fixed Point Numbers</span></a></h3><p>暂未被 Solidity 完全支持，略了。</p><h3 id="address" tabindex="-1"><a class="header-anchor" href="#address"><span>Address</span></a></h3><p>有两种类型的地址，基本上是相同的：</p><ul><li><code>address</code> - 20 Bytes 的 Ethereum 地址，无法向这类地址发送 Ether</li><li><code>address payable</code> - 是一个可以发送 Ether 的地址，具有两个额外的成员 <code>transfer</code> 和 <code>send</code></li></ul><p><code>address payable</code> 是在 Solidity 0.5.0 后才加入的。</p><h3 id="members-of-addresses" tabindex="-1"><a class="header-anchor" href="#members-of-addresses"><span>Members of Addresses</span></a></h3><p>快速查询某个地址的余额 / 以 wei 为单位发送 Ether：</p><ul><li><code>balance</code></li><li><code>transfer</code></li></ul><div class="language-solidity line-numbers-mode" data-highlighter="prismjs" data-ext="solidity" data-title="solidity"><pre><code><span class="line"><span class="token builtin">address</span> <span class="token keyword">payable</span> x <span class="token operator">=</span> <span class="token builtin">address</span><span class="token punctuation">(</span><span class="token number">0x123</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token builtin">address</span> myAddress <span class="token operator">=</span> <span class="token builtin">address</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>balance <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> myAddress<span class="token punctuation">.</span>balance <span class="token operator">&gt;=</span> <span class="token number">10</span><span class="token punctuation">)</span> x<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果余额不足，或 Ether 转账被对方拒绝，<code>transfer</code> 将会回滚。</p><p>在调用 <code>transfer</code> 时，对应 contract 的 fallback function 将会一起执行。如果在 fallback function 执行过程中 out-of-gas 或发生了其它错误，本次交易中已经被转账的 Ether 将会被回滚，当前 contract 将会抛出异常停止执行。</p><ul><li><code>send</code></li></ul><p>是 <code>transfer</code> 的一种低级表示。如果执行失败，<code>transfer</code> 将会使当前 contract 抛出异常停止执行，而 <code>send</code> 将会返回 <code>false</code>。为了安全起见，要么使用 <code>transfer</code>，要么就对 <code>send</code> 的返回值进行 check。</p><ul><li><code>call</code></li><li><code>delegatecall</code></li><li><code>staticcall</code></li></ul><p>低层调用，接收的参数为一些编码后的字节。需要小心使用，因为可能会将当前 contract 的控制权交给任意位置的恶意 contract，这些 contract 会通过调用返回当前 contract，并对状态变量作出修改。</p><p>通常，与其它合约的交互使用的是 contract 对象 - <code>x.f()</code></p><div class="language-solidity line-numbers-mode" data-highlighter="prismjs" data-ext="solidity" data-title="solidity"><pre><code><span class="line"><span class="token builtin">address</span><span class="token punctuation">(</span>nameReg<span class="token punctuation">)</span><span class="token punctuation">.</span>call<span class="token punctuation">{</span>gas<span class="token punctuation">:</span> <span class="token number">1000000</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token number">1</span> ether<span class="token punctuation">}</span><span class="token punctuation">(</span>abi<span class="token punctuation">.</span><span class="token function">encodeWithSignature</span><span class="token punctuation">(</span><span class="token string">&quot;register(string)&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;MyName&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>而 <code>delegatecall</code> 的区别在于，除了使用给定地址上的代码，其它 (balance、storage) 都使用的是当前 contract。主要是用于调用存储在其它 contract 中的库代码。</p><p><code>staticcall</code> 基本上与 <code>call</code> 相同，但是会在函数修改状态时发生回滚。</p><p>这三种低级函数破坏了 Solidity 的类型安全性，因此只能在万不得已的情况下使用。<code>gas</code> 选项对于这三种函数都可用，<code>value</code> 选项对于 <code>delegatecall</code> 不能使用。</p><h3 id="contract-types" tabindex="-1"><a class="header-anchor" href="#contract-types"><span>Contract Types</span></a></h3><p>每一个 contract 定义其自己的类型 (和 Class 类似，每个类都是一个类型)。可以与地址类型进行显式转换。对于 <code>address payable</code> 的转换，只有当 contract 有接收转账的函数或可支付的 fallback 函数才能完成。如果没有这两种函数，就只能通过 <code>payable(address(x))</code> 来完成转换。</p><p>如果定义了某个 contract 的局部变量，就可以通过该变量直接调用 contract 中的被声明为 <code>external</code> 的函数和被声明为 <code>public</code> 的状态变量。</p><h3 id="fixed-size-byte-arrays" tabindex="-1"><a class="header-anchor" href="#fixed-size-byte-arrays"><span>Fixed-size Byte Arrays</span></a></h3><p><code>byte1</code> (<code>byte</code>), <code>byte2</code>, <code>byte3</code>, ..., <code>byte32</code> 用于存放字节。</p><p>成员：<code>.length</code> (只读)</p><h3 id="dynamically-sized-byte-array" tabindex="-1"><a class="header-anchor" href="#dynamically-sized-byte-array"><span>Dynamically-sized Byte Array</span></a></h3><ul><li><code>bytes</code></li><li><code>string</code></li></ul><h3 id="function-types" tabindex="-1"><a class="header-anchor" href="#function-types"><span>Function Types</span></a></h3><div class="language-solidity line-numbers-mode" data-highlighter="prismjs" data-ext="solidity" data-title="solidity"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>parameter types<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">internal</span><span class="token operator">|</span><span class="token keyword">external</span><span class="token punctuation">}</span> <span class="token punctuation">[</span><span class="token keyword">pure</span><span class="token operator">|</span><span class="token keyword">view</span><span class="token operator">|</span><span class="token keyword">payable</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">returns</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token keyword">return</span> types<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Internal 函数只能在当前 contract 内被调用，不能在当前 contract 的上下文以外被执行 - 调用这种类型的函数是由跳转到某个 label 实现的。默认情况下，函数类型都是 internal 的。</p><p>External 函数包含了地址和函数签名，可以在 contract 外部被使用。</p><p>其中，<code>external</code> 函数有如下成员：</p><ul><li><code>.address</code> - 返回函数所在的 contract 地址</li><li><code>.selector</code> - 返回 ABI function selector</li><li><code>.gas(uint)</code> - 已过时，使用 <code>{gas: ...}</code> 指定向目标函数发送的 gas</li><li><code>.value(uint)</code> - 已过时，使用 <code>{value: ...}</code> 指定向目标函数发送的 wei</li></ul><hr><h2 id="reference-types" tabindex="-1"><a class="header-anchor" href="#reference-types"><span>Reference Types</span></a></h2><p>引用类型在处理时需要比值类型更加小心。在使用引用类型时，需要显式指定数据被存储的位置：</p><ul><li><code>memory</code> - 生命周期为一次 external 函数调用</li><li><code>storage</code> - 存储状态变量的位置，生命周期为整个 contract 的生命周期</li><li><code>calldata</code> - 存放函数参数，类似 <code>memory</code>，但不可修改</li></ul><p>这三种类型在互相赋值时，可能是复制引用，可能是复制值。</p><hr><h2 id="mapping-types" tabindex="-1"><a class="header-anchor" href="#mapping-types"><span>Mapping Types</span></a></h2><p>声明方式 - <code>mapping(_KeyType =&gt; _ValueType) _VariableName</code></p><ul><li>Key 的类型可以是任意内置类型、contract 类型、枚举等</li><li>Value 可以是任意类型 (包括 mapping、array、struct)</li></ul><p>数据位置只能为 <code>storage</code>，因此只能作为状态变量。</p><hr>`,58)]))}const i=a(c,[["render",o],["__file","Solidity Types.html.vue"]]),d=JSON.parse('{"path":"/notes/Solidity/Solidity%20Types.html","title":"Solidity - Types","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Value Types","slug":"value-types","link":"#value-types","children":[{"level":3,"title":"Booleans","slug":"booleans","link":"#booleans","children":[]},{"level":3,"title":"Integers","slug":"integers","link":"#integers","children":[]},{"level":3,"title":"Fixed Point Numbers","slug":"fixed-point-numbers","link":"#fixed-point-numbers","children":[]},{"level":3,"title":"Address","slug":"address","link":"#address","children":[]},{"level":3,"title":"Members of Addresses","slug":"members-of-addresses","link":"#members-of-addresses","children":[]},{"level":3,"title":"Contract Types","slug":"contract-types","link":"#contract-types","children":[]},{"level":3,"title":"Fixed-size Byte Arrays","slug":"fixed-size-byte-arrays","link":"#fixed-size-byte-arrays","children":[]},{"level":3,"title":"Dynamically-sized Byte Array","slug":"dynamically-sized-byte-array","link":"#dynamically-sized-byte-array","children":[]},{"level":3,"title":"Function Types","slug":"function-types","link":"#function-types","children":[]}]},{"level":2,"title":"Reference Types","slug":"reference-types","link":"#reference-types","children":[]},{"level":2,"title":"Mapping Types","slug":"mapping-types","link":"#mapping-types","children":[]}],"git":{},"filePathRelative":"notes/Solidity/Solidity Types.md"}');export{i as comp,d as data};
