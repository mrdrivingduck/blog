import{_ as s}from"./12-6-CfR6fAIf.js";import{_ as e,c as a,a as i,o as l}from"./app-7eKjwDat.js";const o="/blog/assets/12-1-z_K4etI1.png",p="/blog/assets/12-2-DX33tREb.png",c={};function t(d,n){return l(),a("div",null,n[0]||(n[0]=[i('<h1 id="chapter-12-1-文件系统-总体功能" tabindex="-1"><a class="header-anchor" href="#chapter-12-1-文件系统-总体功能"><span>Chapter 12.1 - 文件系统 总体功能</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 08 / 31 19:52</p><p>Ningbo, Zhejiang, China</p><hr><h2 id="_12-1-总体功能" tabindex="-1"><a class="header-anchor" href="#_12-1-总体功能"><span>12.1 总体功能</span></a></h2><p>文件系统 (File System, FS) 是 OS 的重要组成部分，是 OS 长期存储大量程序和数据的地方。</p><ul><li>系统加载执行程序时，需要快速从文件系统中读取到内存中运行</li><li>系统运行产生的临时文件也需要动态地保存在文件系统中</li></ul><p>文件系统需要使用高速设备来存储程序和数据 - 块设备。另外，UNIX 类 OS 通常通过设备文件来访问设备。</p><h3 id="_12-1-1-minix-文件系统" tabindex="-1"><a class="header-anchor" href="#_12-1-1-minix-文件系统"><span>12.1.1 MINIX 文件系统</span></a></h3><p>MINIX 文件系统与标准 UNIX 的文件系统基本相同：</p><ol><li>引导块</li><li>超级块</li><li>inode bitmap</li><li>逻辑块 bitmap</li><li>inode</li><li>数据区 (盘块)</li></ol><p>整个块设备被划分为以 <strong>1KB</strong> 为单位的 <strong>磁盘块</strong>。在 MINIX 1.0 文件系统中，<strong>磁盘块</strong> 与 <strong>逻辑块</strong> 的大小正好相同。</p><p><img src="'+o+'" alt="12-1"></p><h4 id="引导块" tabindex="-1"><a class="header-anchor" href="#引导块"><span>引导块</span></a></h4><p><strong>引导块</strong> 是计算机上电时，由 ROM BIOS 自动读入的执行代码和数据盘块</p><ul><li>并非系统中的所有设备都用于作引导设备，所以这一盘块可以没有代码</li><li>但每个盘块设备必须含有引导块的空间，保证文件系统格式的统一</li></ul><p>对于容量巨大的设备，通常会划分出几个分区，每个分区中可以存放一个不同的完整文件系统。</p><p>硬盘的 <strong>第一个</strong> 扇区是 <strong>主引导扇区</strong>，存放</p><ul><li>硬盘引导程序</li><li>分区表 <ul><li>每个分区的类型</li><li>在硬盘中起始位置的参数和结束位置的参数</li><li>占用的扇区总数</li></ul></li></ul><p><img src="'+p+'" alt="12-2"></p><h4 id="超级块" tabindex="-1"><a class="header-anchor" href="#超级块"><span>超级块</span></a></h4><p><strong>超级块</strong> 用于存放设备上文件系统的结构信息，并说明各部分的大小：</p><ul><li>s_ninodes - inode 总数</li><li>s_nzones - 逻辑块总数</li><li>s_imap_blocks - inode bitmap 占用的磁盘块数</li><li>s_firstdatazone - 数据区开始处占用的第一个逻辑块号</li><li>s_log_zone_size - 2 为底的对数表示的每个逻辑块包含的磁盘块数，<code>0</code> 代表每个逻辑块包含 1 个磁盘块，即逻辑块大小 == 磁盘块大小</li><li>s_max_size - 最大文件长度 (字节)</li><li>s_magic - 指明文件系统的类型 - MINIX 1.0：<code>0x137f</code></li></ul><p>在 Linux 0.12 中，被加载的超级块存在数组 <code>super_block[]</code> 中。该表共有 8 项 - Linux 0.12 最多同时加载八个文件系统。</p><h4 id="逻辑块-bitmap" tabindex="-1"><a class="header-anchor" href="#逻辑块-bitmap"><span>逻辑块 bitmap</span></a></h4><p>描述盘上每个数据盘块的使用情况</p><p>除了 bit 0 以外，其余每个 bit 代表数据区中的一个 <strong>逻辑块</strong>。若逻辑块被占用，则 bitmap 中的相应的 bit 被置位。当所有数据盘块被占用时，查找盘块的函数会返回 0 值 - 闲置不用的 bit 0 被初始化为 1。逻辑块位图最多使用 8 个缓冲块 - 每个缓冲块 1024B，总共可用于表示 1024B × 8bit × 8 = 65536 个盘块。因此文件系统的最大块设备容量为 65536 × 1KB = 64MB。</p><h4 id="inode-bitmap" tabindex="-1"><a class="header-anchor" href="#inode-bitmap"><span>inode bitmap</span></a></h4><p>inode 用于存放盘设备上每个文件和目录名的索引信息。inode bitmap 用于说明 inode 是否被使用，每个 bit 代表一个 inode - 一个盘块可表示 8K 个 inode 的使用状态。inode bitmap 中的 bit 0 和 inode 0 都闲置不用。</p><h4 id="inode" tabindex="-1"><a class="header-anchor" href="#inode"><span>inode</span></a></h4><p>inode 结构使用 32 个字节，每个文件或目录都有一个 inode，存放文件或目录的相关信息：</p><ul><li>文件的宿主 id</li><li>文件所属组的 gid</li><li>文件长度</li><li>访问修改时间</li><li>文件数据块在盘上的位置</li><li>文件被链接数</li><li>...</li></ul><p><code>i_mode</code> 字段保存文件的 <strong>类型</strong> 和 <strong>访问权限属性</strong>。</p><p>文件中的数据存放在数据区中，数据区盘块的号码存放在 <code>i_zone[]</code> 数组中。</p><ul><li><code>i_zone[0]</code> - <code>i_zone[6]</code> 用于存放文件开始的 7 个磁盘块号：<strong>直接块</strong></li><li><code>i_zone[7]</code> 用于寻找 ＞ 7K 的文件内容：<strong>一次间接盘块</strong><ul><li>在这个盘块中，存放着附加的盘块号</li><li>盘块大小为 1K，盘块号为 <code>short</code> 类型，占 2B - 最多寻址 512 个盘块</li></ul></li><li><code>i_zone[8]</code> 用于寻找更大文件的其它盘块：<strong>二次间接盘块</strong><ul><li>用于寻址 512 个 <strong>一次间接盘块</strong></li><li>共能寻址 512 × 512 个盘块</li></ul></li></ul><p>因此，MINIX 1.0 中文件的最大长度 = (7 + 512 + 512 × 512) × 1KB = 262663KB。</p><p><img src="'+s+`" alt="12-6"></p><p>另外，对于 <code>/dev</code> 目录下的设备文件来说：</p><ul><li>不占用数据区的逻辑块 - 文件长度为 0</li><li>inode 仅保存设备属性和设备号</li><li>设备号存放在 inode 的 <code>i_zone[0]</code> 中</li></ul><h3 id="_12-1-2-文件类型、属性和目录项" tabindex="-1"><a class="header-anchor" href="#_12-1-2-文件类型、属性和目录项"><span>12.1.2 文件类型、属性和目录项</span></a></h3><h4 id="_12-1-2-1-文件的类型和属性" tabindex="-1"><a class="header-anchor" href="#_12-1-2-1-文件的类型和属性"><span>12.1.2.1 文件的类型和属性</span></a></h4><p>UNIX 类 OS 中的文件通常可分为 6 类：</p><ol><li>正规文件</li><li>目录名</li><li>符号链接文件</li><li>命令管道文件</li><li>字符设备文件</li><li>块设备文件</li></ol><p>在 Linux 内核中，文件的类型信息保存在对应 inode 的 <code>i_mode</code> 字段中。</p><h4 id="_12-1-2-2-文件系统目录项结构" tabindex="-1"><a class="header-anchor" href="#_12-1-2-2-文件系统目录项结构"><span>12.1.2.2 文件系统目录项结构</span></a></h4><p>在文件系统的目录中，所有下属文件的目录项存储在该目录文件的 <strong>数据块</strong> 中。目录项结构体的格式：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NAME_LEN</span> <span class="token expression"><span class="token number">14</span> </span><span class="token comment">// 文件名长度</span></span></span>
<span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ROOT_INO</span> <span class="token expression"><span class="token number">1</span>  </span><span class="token comment">// root inode number</span></span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> inode<span class="token punctuation">;</span> <span class="token comment">// inode number</span></span>
<span class="line">    <span class="token keyword">char</span> name<span class="token punctuation">[</span>NAME_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 文件名</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此一个逻辑块中可以存放 1024 ÷ 16 = 64 个目录项。打开文件时，文件系统根据给定的文件名找到 inode 号，再根据其 inode 找到文件对应的磁盘块。每个 inode 中都有链接计数字段 <code>i_nlinks</code>，记录了指向该 inode 的目录项数，即 <strong>硬链接</strong> 数。删除文件时，只有该值为 0 时，内核才会真正删除磁盘上该文件的数据。由于 inode 仅适用于当前文件系统中，因此 <strong>硬链接不能跨越文件系统</strong>。</p><p>而符号链接类型的文件名并不直接指向对应的 inode：</p><ul><li>符号链接会在对应文件的数据块中存放某一个文件的 <strong>路径名字符串</strong></li><li>当访问符号链接时，内核读取该文件中的内容，根据其中的字符串访问指定文件</li><li>因此符号链接可以不局限在一个文件系统中</li></ul><p>在每个目录中还包含两个特殊的文件目录项：</p><ul><li><code>.</code> - 指向当前目录的 inode</li><li><code>..</code> - 指向当前目录父目录的 inode</li></ul><p>对于每个目录文件，链接计数值起码为 2</p><ul><li>当前目录对自身 inode 的引用</li><li>当前目录的父目录对当前目录 inode 的引用</li></ul><h3 id="_12-1-3-高速缓冲区" tabindex="-1"><a class="header-anchor" href="#_12-1-3-高速缓冲区"><span>12.1.3 高速缓冲区</span></a></h3><p>高速缓冲区是文件系统访问块设备数据的必经要道。为提高每次 I/O 操作的性能，内核在内存的内核代码区与主内存区之间开辟了高速缓冲区。高速缓冲区被划分为与磁盘数据块大小相等的缓冲块：</p><ul><li>存放着最近被使用过的块设备数据块</li><li>需要从块设备读取数据时，缓冲区管理程序首先在高速缓冲中寻找</li><li>若已在缓冲区，就不需要再从设备上读</li><li>若不在缓冲区，则申请空闲缓冲块，并读取数据</li></ul><p>把数据真正写到设备中 - 由设备数据同步实现。</p><h3 id="_12-1-4-文件系统底层函数" tabindex="-1"><a class="header-anchor" href="#_12-1-4-文件系统底层函数"><span>12.1.4 文件系统底层函数</span></a></h3><ul><li><code>bitmap.c</code> - 对 inode bitmap 和逻辑块 bitmap 进行释放和占用</li><li><code>truncate.c</code> - 将文件长度截断为 0，并释放文件占用的设备逻辑块</li><li><code>inode.c</code> - 分配和释放内存中的 inode</li><li><code>namei.c</code> - 将给定的文件路径名映射到其 inode</li><li><code>super.c</code> - 处理文件系统超级块</li></ul><h3 id="_12-1-5-文件中数据的访问操作" tabindex="-1"><a class="header-anchor" href="#_12-1-5-文件中数据的访问操作"><span>12.1.5 文件中数据的访问操作</span></a></h3><ul><li>块设备 - <code>block_read()</code> / <code>block_write()</code></li><li>字符设备 - <code>rw_char()</code></li><li>管道设备 - <code>read_pipe()</code> / <code>write_pipe()</code></li><li>普通文件 - <code>file_read()</code> / <code>file_write()</code></li></ul><p>这些函数共同实现了 <code>read()</code> 和 <code>write()</code> 系统调用。内核通过文件结构 file、文件表 file_talbe[] 和内存中的 inode 表 inode_table[] 管理对文件的操作。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> f_mode<span class="token punctuation">;</span>    <span class="token comment">// 文件操作模式</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> f_flags<span class="token punctuation">;</span>   <span class="token comment">// 文件打开和控制标志</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> f_count<span class="token punctuation">;</span>   <span class="token comment">// 文件句柄引用次数</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">m_inode</span> <span class="token operator">*</span> f_inode<span class="token punctuation">;</span> <span class="token comment">// 指向内存中对应的 inode</span></span>
<span class="line">    <span class="token class-name">off_t</span> f_pos<span class="token punctuation">;</span> <span class="token comment">// 文件当前读写指针的位置</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">file</span> file_table<span class="token punctuation">[</span>NR_FILE<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>文件表是内核中文件结构体组成的数组，在 Linux 0.12 内核中，最多可有 64 项，因此整个系统最多同时打开 64 个文件。在进程的 PCB 中有一个 filp[NR_OPEN]</p><ul><li>表示本进程打开的文件</li><li>数组下标对应文件描述符的值</li><li>数组中的项对应指向文件表中打开的文件项</li></ul><p>比如，filp[0] 就是进程的 0 号文件描述符，指向文件表中对应的文件结构体。内核中的 inode_table[NR_INODE] 是由内存 inode 结构体组成的数组。内核中同时只能保存最多 32 个 inode 的信息。</p><h3 id="_12-1-6-文件和目录管理系统调用" tabindex="-1"><a class="header-anchor" href="#_12-1-6-文件和目录管理系统调用"><span>12.1.6 文件和目录管理系统调用</span></a></h3><p>用户操作和访问文件系统中的文件均通过内核提供的系统调用实现：</p><ul><li><code>open.c</code> - 实现文件操作相关的系统调用：创建、打开、关闭等</li><li><code>exec.c</code> - 实现对二进制可执行文件和 shell 脚本的加载与执行</li><li><code>fcntl.c</code> - 实现了文件控制操作的系统调用 <code>fcntl()</code> 和两个文件描述符复制的系统调用 <code>dup()</code> 和 <code>dup2()</code></li><li><code>ioctl.c</code> - 实现了 I/O 控制系统调用 <code>ioctl()</code></li><li><code>stat.c</code> - 用于实现取得文件状态信息的系统调用 <code>stat()</code> 和 <code>fstat()</code></li></ul>`,71)]))}const h=e(c,[["render",t],["__file","Chapter 12.1 - 文件系统 总体功能.html.vue"]]),_=JSON.parse('{"path":"/linux-kernel-comments-notes/Chapter%2012%20-%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Chapter%2012.1%20-%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%20%E6%80%BB%E4%BD%93%E5%8A%9F%E8%83%BD.html","title":"Chapter 12.1 - 文件系统 总体功能","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"12.1 总体功能","slug":"_12-1-总体功能","link":"#_12-1-总体功能","children":[{"level":3,"title":"12.1.1 MINIX 文件系统","slug":"_12-1-1-minix-文件系统","link":"#_12-1-1-minix-文件系统","children":[]},{"level":3,"title":"12.1.2 文件类型、属性和目录项","slug":"_12-1-2-文件类型、属性和目录项","link":"#_12-1-2-文件类型、属性和目录项","children":[]},{"level":3,"title":"12.1.3 高速缓冲区","slug":"_12-1-3-高速缓冲区","link":"#_12-1-3-高速缓冲区","children":[]},{"level":3,"title":"12.1.4 文件系统底层函数","slug":"_12-1-4-文件系统底层函数","link":"#_12-1-4-文件系统底层函数","children":[]},{"level":3,"title":"12.1.5 文件中数据的访问操作","slug":"_12-1-5-文件中数据的访问操作","link":"#_12-1-5-文件中数据的访问操作","children":[]},{"level":3,"title":"12.1.6 文件和目录管理系统调用","slug":"_12-1-6-文件和目录管理系统调用","link":"#_12-1-6-文件和目录管理系统调用","children":[]}]}],"git":{},"filePathRelative":"linux-kernel-comments-notes/Chapter 12 - 文件系统/Chapter 12.1 - 文件系统 总体功能.md"}');export{h as comp,_ as data};
