import{_ as e,c as a,a as i,o as t}from"./app-7eKjwDat.js";const r={};function n(o,l){return t(),a("div",null,l[0]||(l[0]=[i('<h1 id="chapter-8-1-8-2-运行时栈帧结构" tabindex="-1"><a class="header-anchor" href="#chapter-8-1-8-2-运行时栈帧结构"><span>Chapter 8.1-8.2 - 运行时栈帧结构</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 01 / 30 21:32 🧨🧧</p><p>Ningbo, Zhejiang, China</p><hr><h2 id="_8-1-概述" tabindex="-1"><a class="header-anchor" href="#_8-1-概述"><span>8.1 概述</span></a></h2><p>关于 Java 虚拟机与物理机</p><ul><li>物理机的执行引擎直接建立在 CPU、缓存、指令集和 OS 层面上</li><li>虚拟机的执行引擎由软件自行实现，不受体系结构限制</li></ul><p>JVM 在执行字节码时，分为：</p><ul><li>解释执行 (由解释器执行)</li><li>编译执行 (通过即时编译器产生本地代码)</li></ul><hr><h2 id="_8-2-运行时栈帧结构" tabindex="-1"><a class="header-anchor" href="#_8-2-运行时栈帧结构"><span>8.2 运行时栈帧结构</span></a></h2><p>JVM 以函数 (方法) 作为最基本的执行单元。<strong>栈帧</strong> (Stack Frame) 是支持虚拟机进行函数调用和函数执行背后的数据结构，位于运行时数据区的 <strong>虚拟机栈</strong> 中，包含函数的：</p><ul><li>局部变量表</li><li>操作数栈</li><li>动态链接</li><li>函数返回地址</li></ul><p>栈帧需要分配的内存在编译时就已经确定了，不会受到程序运行时变量数据的影响。在活动线程中，只有位于栈顶的函数是正在运行的，只有位于栈顶的栈帧才是生效的，被称为 <strong>当前函数</strong> 和 <strong>当前栈帧</strong>。执行引擎运行的字节码指令只对当前栈帧进行操作。</p><h3 id="_8-2-1-局部变量表-local-variables-table" tabindex="-1"><a class="header-anchor" href="#_8-2-1-局部变量表-local-variables-table"><span>8.2.1 局部变量表 (Local Variables Table)</span></a></h3><p>存放 <strong>函数参数</strong> 和 <strong>函数内部定义的局部变量</strong>。在编译出 Class 文件时，函数的 Code 属性中就已经确定了局部变量表的最大容量。局部变量表的容量以 <strong>变量槽</strong> (Variable Slot) 为最小单位。每个变量槽可以存放：</p><ul><li><code>boolean</code></li><li><code>byte</code></li><li><code>char</code></li><li><code>short</code></li><li><code>int</code></li><li><code>float</code></li><li><code>reference</code><ul><li>对象引用</li><li>JVM 能根据引用找到对象在 Java Heap 中数据的起始地址</li><li>JVM 能根据引用找到对象所属的类在方法区中存储的类信息</li></ul></li><li><code>returnAddress</code></li></ul><p>JVM 明确规定 <code>long</code> 和 <code>double</code> 需要占用两个连续的变量槽。局部变量表建立在线程堆栈中，属于线程私有数据，没有线程安全问题。JVM 通过索引定位的方式使用局部变量表，当一个函数被调用时，JVM 使用局部变量表来完成参数传递。如果执行的是实例方法，局部变量表第 <code>0</code> 位默认用于传递函数所属对象实例的引用，即隐含参数 <code>this</code>；其余参数按照参数表顺序排列，占用 <code>1</code> 开始的局部变量槽。参数表分配完毕后，再按函数体内部变量定义的顺序和作用于分配其余变量槽。</p><p>为节省栈帧使用的内存空间，局部变量表中的变量槽是可以重用的。若当前字节码 PC 的值已经超出了变量作用域，那么这个变量槽就可以给其它变量使用。</p><blockquote><p>关于手动将对象设置为 <code>null</code> 值是否有利于 GC，这种操作在极特殊情形下有用：</p><ul><li>对象占用内存大</li><li>栈帧长时间无法被回收</li><li>函数调用次数达不到 JIT 的编译条件</li></ul><p>在实际情况中，即时编译是 JVM 执行代码的主要方式，赋 <code>null</code> 的操作在经过即时编译优化之后会被消除，因而没有意义。</p></blockquote><p>与类变量在准备阶段和初始化阶段的二度赋值不同，局部变量没有赋初始值是绝对不能使用的。编译器会检查到这一点。</p><h3 id="_8-2-2-操作数栈-operand-stack" tabindex="-1"><a class="header-anchor" href="#_8-2-2-操作数栈-operand-stack"><span>8.2.2 操作数栈 (Operand Stack)</span></a></h3><p>与局部变量表一样，操作数栈的最大深度在编译时被写入 Code 属性中。32-bit 数据类型的栈容量为 1；64-bit 数据类型的栈容量为 2。Javac 编译器的数据流分析保证了函数执行的任何时候，操作数栈的深度都不会超过最大深度。编译器保证操作数栈中的元素与字节码指令序列严格匹配，在类的校验阶段还会再次验证这一点。</p><p>两个栈帧在概念上是独立的，但在实现上，JVM 会使两个栈帧重叠。下面栈帧的操作数栈与上面栈帧的局部变量表重叠：</p><ul><li>节省空间</li><li>函数调用时直接共用数据，无须进行额外的参数复制传递</li></ul><h3 id="_8-2-3-动态链接" tabindex="-1"><a class="header-anchor" href="#_8-2-3-动态链接"><span>8.2.3 动态链接</span></a></h3><p>每个栈帧都包含一个指向常量池中该栈帧所属函数的引用。字节码中的 <strong>函数调用指令</strong> 以常量池中指向函数的符号引用作为参数</p><ul><li>符号引用在类加载阶段或第一次使用时转化为直接引用 - 静态解析</li><li>符号引用在每一次运行期间都转化为直接引用 - 动态链接</li></ul><h3 id="_8-2-4-方法返回地址" tabindex="-1"><a class="header-anchor" href="#_8-2-4-方法返回地址"><span>8.2.4 方法返回地址</span></a></h3><ul><li>正常调用完成 <ul><li>可能会有返回值传递给上层的函数调用者</li></ul></li><li>异常调用完成 <ul><li>函数执行过程中遇到了异常</li><li>本函数的异常表中没有搜索到匹配的异常处理器，方法退出</li><li>不会给调用者提供任何返回值</li></ul></li></ul><p>函数退出后，必须返回最初方法被调用时的位置，继续执行。函数退出的过程实际上等同于把当前栈帧出栈。</p>',32)]))}const s=e(r,[["render",n],["__file","Chapter 8.1-8.2 - 运行时栈帧结构.html.vue"]]),d=JSON.parse('{"path":"/understanding-the-jvm-notes/Part%203%20-%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/Chapter%208.1-8.2%20-%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84.html","title":"Chapter 8.1-8.2 - 运行时栈帧结构","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"8.1 概述","slug":"_8-1-概述","link":"#_8-1-概述","children":[]},{"level":2,"title":"8.2 运行时栈帧结构","slug":"_8-2-运行时栈帧结构","link":"#_8-2-运行时栈帧结构","children":[{"level":3,"title":"8.2.1 局部变量表 (Local Variables Table)","slug":"_8-2-1-局部变量表-local-variables-table","link":"#_8-2-1-局部变量表-local-variables-table","children":[]},{"level":3,"title":"8.2.2 操作数栈 (Operand Stack)","slug":"_8-2-2-操作数栈-operand-stack","link":"#_8-2-2-操作数栈-operand-stack","children":[]},{"level":3,"title":"8.2.3 动态链接","slug":"_8-2-3-动态链接","link":"#_8-2-3-动态链接","children":[]},{"level":3,"title":"8.2.4 方法返回地址","slug":"_8-2-4-方法返回地址","link":"#_8-2-4-方法返回地址","children":[]}]}],"git":{},"filePathRelative":"understanding-the-jvm-notes/Part 3 - 虚拟机执行子系统/Chapter 8.1-8.2 - 运行时栈帧结构.md"}');export{s as comp,d as data};
