import{_ as s,c as e,a,o as l}from"./app-BeHGwf2X.js";const i={};function t(p,n){return l(),e("div",null,n[0]||(n[0]=[a(`<h1 id="chapter-19-事务" tabindex="-1"><a class="header-anchor" href="#chapter-19-事务"><span>Chapter 19 - 事务</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 06 / 10 17:04</p><p>Nanjing, Jiangsu, China</p><hr><p>Redis 通过几条特殊的命令来实现事务。事务能够将多条命令请求打包，然后一次性、按顺序地执行。在事务执行期间，服务器不会中断事务执行其它客户端的命令请求。当事务中的请求执行完毕后，才回去处理其它客户端的请求。</p><h2 id="implementation" tabindex="-1"><a class="header-anchor" href="#implementation"><span>Implementation</span></a></h2><p>事务由一个 <code>MULTI</code> 命令为开始，接着将多个命令放入事务中，最终由 <code>EXEC</code> 命令将这个事务提交给服务器执行，对应了三个阶段：</p><ol><li><code>MULTI</code> 命令对应了事务的 <strong>开始</strong> - 打开了客户端状态中 flag 属性的 <code>REDIS_MULTI</code> 标识</li><li>客户端处于事务状态，服务器将普通命令存入 <strong>事务队列</strong>，然后向客户端返回 <code>QUEUED</code></li><li><code>EXEC</code> 命令对应了事务的 <strong>执行</strong>，服务器遍历客户端的事务队列，依次执行其中保存的命令</li></ol><p>在服务器上维护的客户端状态中，有一个事务状态结构体：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line">    multiState mstate<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span> redisClient<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>事务状态结构体中维护了 <strong>事务队列</strong> 及其长度：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">multiState</span> <span class="token punctuation">{</span></span>
<span class="line">    multiCmd <span class="token operator">*</span>commands<span class="token punctuation">;</span> <span class="token comment">// 事务队列</span></span>
<span class="line">    <span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment">// 已入队命令数</span></span>
<span class="line"><span class="token punctuation">}</span> multiState<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>事务队列中的每个元素对应了事务中的一条命令及其参数，其定义如下：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">multiCmd</span> <span class="token punctuation">{</span></span>
<span class="line">    robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">;</span> <span class="token comment">// 参数</span></span>
<span class="line">    <span class="token keyword">int</span> argc<span class="token punctuation">;</span> <span class="token comment">// 参数数量</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">;</span> <span class="token comment">// 指向命令结构</span></span>
<span class="line"><span class="token punctuation">}</span> multiCmd<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="implementation-of-watch" tabindex="-1"><a class="header-anchor" href="#implementation-of-watch"><span>Implementation of WATCH</span></a></h2><p><code>WATCH</code> 命令用于维护事务的安全性。它可以在 <code>EXEC</code> 命令执行前 (即事务实际执行前) 对任意多个 key 进行监视，如果被监视的 key 至少有一个被修改，那么服务器将拒绝执行事务。从而保证事务的执行是安全的。</p><p>Redis 数据库中维护了一个 <code>watched_keys</code> 字典：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line">    dict <span class="token operator">*</span>watched_keys<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span> redisDb<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个字典的 key 就是数据库中被监视的 key；value 是一个链表，维护了监视这个 key 的全部客户端。所有对数据库进行修改的命令，如：</p><ul><li><code>SET</code></li><li><code>LPUSH</code></li><li><code>SADD</code></li><li><code>ZREM</code></li><li><code>DEL</code></li><li><code>FLUSHDB</code></li><li>...</li></ul><p>这些命令执行后，Redis 都会调用 <code>touchWatchKey()</code> 函数 对 <code>watched_keys</code> 字典进行检查。如果修改的 key 位于字典中，那么就将监视这个 key 的所有客户端的 <code>REDIS_DIRTY_CAS</code> 标志位打开，表示客户端的事务安全性已经被破坏。</p><p>当服务器接收到来自客户端的 <code>EXEC</code> 命令时，根据客户端状态中的 <code>REDIS_DIRTY_CAS</code> 来决定是否执行当前事务。如果这个标志位已被打开，那么事务的执行不再安全，服务器拒绝为这个客户端执行事务。</p><hr><h2 id="acid" tabindex="-1"><a class="header-anchor" href="#acid"><span>ACID</span></a></h2><p>传统的数据库中讲究事务的 ACID 四个特性。Redis 中的事务能满足这四个特性吗？</p><h3 id="原子性" tabindex="-1"><a class="header-anchor" href="#原子性"><span>原子性</span></a></h3><p>事务中的操作要么不执行，要么全部执行。因此 Redis 的事务功能是具有原子性的。</p><p>与传统关系型数据库的区别在于，Redis 不支持 <strong>回滚</strong>。事务队列中的某个命令在执行时发生了错误，那么整个事务也会继续执行下去，直到所有的命令都执行完毕。</p><blockquote><p>Redis 不支持事务回滚是因为与 Redis 追求简单高效的设计主旨不符。Redis 的作者认为事务的执行错误通常都是编程错误产生的。</p></blockquote><h3 id="一致性" tabindex="-1"><a class="header-anchor" href="#一致性"><span>一致性</span></a></h3><p>事务执行前，数据库是一致的；事务执行后，无论成功失败，数据库也应该是一致的。一致指的是数据库符合本身的定义和要求，不包含非法或无效的数据。Redis 事务可能出错的地方包含：</p><ol><li>入队错误 - 加入事务队列的命令不存在，或命令格式不正确，Redis 拒绝执行这个事务</li><li>执行错误 - 特指在入队时无法被发现的错误，只能在命令实际运行时被触发；出错命令不会引发对数据库的修改</li><li>服务器停机 - 如果没有持久化，那么重启后的数据库将是空白的；如果有持久化，服务器从 RDB 或 AOF 文件中恢复数据库状态</li></ol><p>由于 Redis 对上述三种错误都进行了妥善的处理，因此一致性能够得到满足。</p><h3 id="隔离性" tabindex="-1"><a class="header-anchor" href="#隔离性"><span>隔离性</span></a></h3><p>多个并发事务执行，事务之间不会相互影响，并发状态下执行的事务与串行状态下执行的事务结果相同。</p><p>由于 Redis 以单线程的方式执行各个事务 (以及事务中的各条命令)，并且服务器不会在事务执行期间中断事务。因此 Redis 中的事务总是串行执行且隔离的。</p><h3 id="持久性" tabindex="-1"><a class="header-anchor" href="#持久性"><span>持久性</span></a></h3><p>当事务执行完毕时，结果应当已经保存到永久性存储介质中了。由于 Redis 基于内存，且没有为事务提供额外的持久化功能，因此 Redis 的事务持久性由 Redis 本身使用的持久化模式决定。</p><p>其中，只有 AOF 模式下的 <code>appendfsync</code> 选项为 <code>always</code> 时，命令的执行结果才能立刻写入磁盘中；其它模式下，Redis 都要等一定的条件满足才会进行持久化。因此，只有这一种配置下的事务具有持久性。</p><p>配置选项 <code>no-appendfsync-on-rewrite</code> 会停止对 AOF 文件进行同步，即使 <code>appendfsync</code> 的选项为 <code>always</code>。这样一来，即使是这种配置下，事务也不在具有持久性。</p>`,42)]))}const o=s(i,[["render",t],["__file","Chapter 19 - 事务.html.vue"]]),d=JSON.parse('{"path":"/redis-implementation-notes/Part%204%20-%20%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/Chapter%2019%20-%20%E4%BA%8B%E5%8A%A1.html","title":"Chapter 19 - 事务","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Implementation","slug":"implementation","link":"#implementation","children":[]},{"level":2,"title":"Implementation of WATCH","slug":"implementation-of-watch","link":"#implementation-of-watch","children":[]},{"level":2,"title":"ACID","slug":"acid","link":"#acid","children":[{"level":3,"title":"原子性","slug":"原子性","link":"#原子性","children":[]},{"level":3,"title":"一致性","slug":"一致性","link":"#一致性","children":[]},{"level":3,"title":"隔离性","slug":"隔离性","link":"#隔离性","children":[]},{"level":3,"title":"持久性","slug":"持久性","link":"#持久性","children":[]}]}],"git":{},"filePathRelative":"redis-implementation-notes/Part 4 - 独立功能的实现/Chapter 19 - 事务.md"}');export{o as comp,d as data};
