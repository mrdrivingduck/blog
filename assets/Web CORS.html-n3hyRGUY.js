import{_ as r,c as s,a as i,o as l}from"./app-7eKjwDat.js";const a={};function n(o,e){return l(),s("div",null,e[0]||(e[0]=[i(`<h1 id="web-cors" tabindex="-1"><a class="header-anchor" href="#web-cors"><span>Web - CORS</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 02 / 04 18:29</p><p>Ningbo, Zhejiang, China</p><hr><h2 id="同源策略" tabindex="-1"><a class="header-anchor" href="#同源策略"><span>同源策略</span></a></h2><p>由 <em>Netscape</em> 提出的著名安全策略，是浏览器最基本、最核心的安全功能。一个 <strong>域</strong> 包含三个要素：</p><ul><li>协议 - HTTP/HTTPS</li><li>域名</li><li>端口</li></ul><p>这三个要素相同，就是同一个域。不同域的客户端脚本在没有明确授权的情况下，不能读写对方资源。比如，从前端 <code>localhost:8080</code> 的网页上向后端 <code>localhost:8081</code> 发送 HTTP 请求，浏览器控制台报错：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">Access to XMLHttpRequest at &#39;localhost:8081/test/normal&#39; from origin &#39;http://localhost:8080&#39; has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https.</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>因为从前端到后端的请求是一个跨域请求，出于安全原因，浏览器限制发起这样的请求。比如，从某个恶意网页中，发起了对某个电商网站的请求，如果电脑上存有该电商网站的 Cookies，那么不用账号密码就能登录。这样恶意网页就获得了用户在电商网站的个人信息。</p><p>同源策略的限制：</p><ol><li>无法通过 JavaScript 读取非同源的 Cookie、LocalStorage、IndexDB</li><li>无法通过 JavaScript 获取非同源的 DOM</li><li>无法通过 JavaScript 发送非同源的 AJAX 请求</li></ol><h2 id="cors-cross-origin-resource-sharing" tabindex="-1"><a class="header-anchor" href="#cors-cross-origin-resource-sharing"><span>CORS (Cross-Origin Resource Sharing)</span></a></h2><p>是一种 W3C 标准和机制，所有的现代浏览器都支持这个功能，让网页的受限资源能够被其他域名的页面访问。允许浏览器向跨域服务器发出 <code>XMLHttpRequest</code> 请求。如果浏览器发现资源访问跨域，会自动向 HTTP 添加 <code>Origin</code> 头部，说明本次请求来自哪个域（协议 + 域名 + 端口）。服务器根据这个头部，决定是否同意请求：</p><ul><li>如果 <code>Origin</code> 在许可范围中，服务器返回的响应中会增加如下的响应头</li><li>如果 <code>Origin</code> 不在许可范围中，服务器会返回正常回应，但不会增加响应头，因此浏览器会因为没有找到特定的响应头而抛出错误</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">Access-Control-Allow-Origin: ...</span>
<span class="line">Access-Control-Allow-Credentials: ...</span>
<span class="line">Access-Control-Expose-Headers: ...</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，在自行实现的后端代码中，对于合法的跨域访问请求，需要在响应头中加入上述的头部。<em>Spring Boot</em> 等 Web 框架也提供了对应的注解 <code>@CrossOrigin</code>。</p><h2 id="pre-flight" tabindex="-1"><a class="header-anchor" href="#pre-flight"><span>Pre-flight</span></a></h2><p>记录开发后端时踩过的坑。</p><p>为什么用 Postman 测试 API 是通过的，而使用浏览器测试 API 就无法通过呢？CORS 是一个浏览器安全策略，Postman 自然没有。</p><p>浏览器发出的 HTTP 请求被分为两类：</p><ul><li>简单请求</li><li>非简单请求</li></ul><p>对于简单请求，浏览器直接发出带有 <code>Origin</code> header 的 HTTP 请求。后端除了返回正常的响应以外，还需要在响应头中添加上述几个 <code>Access-Control-*</code> header。如果浏览器没有检测到这几个 header 就会报错。简单请求需要满足的条件：</p><ul><li>GET 请求</li><li>HEAD 请求</li><li>POST 请求，且 <code>Content-Type</code> 设置为下列中的一个： <ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>aplication/x-www-form-urlencoded</code></li></ul></li></ul><p>对于非简单请求，在正式开始通信之前，浏览器会自动做一次 HTTP OPTIONS 请求，被称为 <strong>预检（pre-flight）</strong> 请求。浏览器在预检请求中询问后端网页所在域名是否允许访问后端，以及允许发送 HTTP 请求的方式和 header。只有得到正确的响应（<code>Access-Control-*</code> headers），浏览器才会继续发送带有 <code>Origin</code> header 的 CORS 请求。</p><p>因此，在实现后端时，需要为一个可能会被发送 pre-flight 的路由设置一个 OPTIONS 的处理函数，在处理函数中需要将相应的 header 返回给浏览器。这样浏览器才会把真正的请求顺利发送到后端。</p><h2 id="references" tabindex="-1"><a class="header-anchor" href="#references"><span>References</span></a></h2><p><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener noreferrer">阮一峰的网络日志 - 跨域资源共享 CORS 详解</a></p><p><a href="https://www.jianshu.com/p/b55086cbd9af" target="_blank" rel="noopener noreferrer">简书 - 前端 | 浅谈 preflight request</a></p><p><a href="https://juejin.cn/post/6844904053328052232" target="_blank" rel="noopener noreferrer">稀土掘金 - 浅谈浏览器中的 preflight 请求</a></p>`,31)]))}const c=r(a,[["render",n],["__file","Web CORS.html.vue"]]),d=JSON.parse('{"path":"/notes/Web/Web%20CORS.html","title":"Web - CORS","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"同源策略","slug":"同源策略","link":"#同源策略","children":[]},{"level":2,"title":"CORS (Cross-Origin Resource Sharing)","slug":"cors-cross-origin-resource-sharing","link":"#cors-cross-origin-resource-sharing","children":[]},{"level":2,"title":"Pre-flight","slug":"pre-flight","link":"#pre-flight","children":[]},{"level":2,"title":"References","slug":"references","link":"#references","children":[]}],"git":{},"filePathRelative":"notes/Web/Web CORS.md"}');export{c as comp,d as data};
