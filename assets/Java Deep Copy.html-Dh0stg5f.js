import{_ as a,c as s,a as e,o as t}from"./app-BeHGwf2X.js";const o={};function p(c,n){return t(),s("div",null,n[0]||(n[0]=[e(`<h1 id="java-deep-copy" tabindex="-1"><a class="header-anchor" href="#java-deep-copy"><span>Java - Deep Copy</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 10 / 07 20:12</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="about" tabindex="-1"><a class="header-anchor" href="#about"><span>About</span></a></h2><p>最近在用 Java 实现一个 Fuzzer 时，其中的一些算法需要对对象进行拷贝。之前写 JavaScript 的时候，都是直接 <code>JSON.parse()</code> + <code>JSON.stringfy()</code> 完事了，对于 Java 应该怎么处理不是太了解。于是搜索了一波 🙄 名堂还真不少，但至少可以明确的一点是：JSON 不是 Java 的原生支持。所以方法显然不是转成 JSON 字符串再转回来。</p><h2 id="clone-function" tabindex="-1"><a class="header-anchor" href="#clone-function"><span>Clone Function</span></a></h2><p>Java 中的所有对象全部继承自 <code>java.lang.Object</code>。在这个 root superclass 中，定义了一个 <code>clone()</code> 函数，因此任何派生类都可以 override 这一个 <code>clone()</code> 函数。该函数的默认行为是 - 返回一个对象的 <strong>浅拷贝</strong>：</p><ul><li>复制该对象中的每一个 field</li><li>对于 <strong>原始数据类型</strong> (<code>int</code>, <code>float</code>) 或 <strong>不可改变的类型</strong> (<code>String</code>) 来说，复制的是值</li><li>对于对象来说，复制的是引用 (我宁愿把它理解为，复制的是指针) - 只是复制了指针，指针变成了两个，但指向的区域还是同一个</li></ul><p>浅拷贝的问题显而易见，如果通过复制后的对象中的对象引用 <strong>修改</strong> (只读应该不会有问题) 了对象数据，那么被复制对象中的引用的对象数据也会发生变化。因为他们引用同一个对象。例子：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">Vector</span> original <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">StringBuffer</span> text <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">&quot;A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">original<span class="token punctuation">.</span><span class="token function">addElement</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token class-name">Vector</span> clone <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Vector</span><span class="token punctuation">)</span> original<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实例化一个 <code>Vector</code> 对象，并将一个 <code>StringBuffer</code> 对象作为元素加入到该对象中 (引用传递)。然后浅拷贝一个 <code>Vector</code> 对象，显然，通过两个对象都可以访问到 <code>StringBuffer</code> 对象，克隆看起来是成功的。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line">clone<span class="token punctuation">.</span><span class="token function">addElement</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>此时，访问这两个对象， <code>clone</code> 可以访问到 <code>Integer</code>，而 <code>original</code> 不行。因为这两个 <code>Vector</code> 现在确实是两个独立的对象了。<code>clone</code> 对象持有对 <code>Integer</code> 对象的引用，而 <code>original</code> 对象没有。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line">text<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;EMMM&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>此时，通过两个 <code>Vector</code> 对象访问 <code>text</code>，发现两个对象中的 <code>text</code> 对象都变了。因为这两个 <code>Vector</code> 对象持有对同一个 <code>StringBuffer</code> 对象的引用。</p><blockquote><p>也就是说，浅拷贝只是复制了 <strong>指针</strong>，而指针指向的对象没有被复制。因此，通过 <code>origin</code> 对象修改了 <code>StringBuffer</code> 对象后，通过 <code>clone</code> 对象访问 <code>StringBuffer</code> 对象时，能够看到修改。</p></blockquote><p>so. 如果业务逻辑需要的是把 <code>StringBuffer</code> 对象也复制两份，即需要进行所谓的 <strong>deep copy</strong>，how to do it?</p><hr><h2 id="issues" tabindex="-1"><a class="header-anchor" href="#issues"><span>Issues</span></a></h2><p>或许可以自己实现一个 <code>deepCopy()</code> 函数，以完成复杂的深拷贝功能？</p><ol><li>必须有这个类的源代码才行 - 如果想复制一个第三方的类，或许可能被声明为 <code>final</code> - Well...GG 😥</li><li>必须能够访问这个类的基类的所有 field - 如果基类的 field 被声明为 <code>private</code> - Well...GG again 😥</li><li>必须能够拷贝该类引用的所有类型的对象才行 - 但有些类型只有在运行时才能被明确</li><li>很容易出错，难于维护 - 一旦这个类的结构被改动了，都要检查一遍这个函数</li></ol><p>此外，重写 <code>clone()</code> 函数在 <em>StackOverFlow</em> 上也不被推荐，因为深度复制应当是一个递归的过程。至少在实现 <code>clone()</code> 函数时，该对象引用的所有类型的对象也应当都覆盖 <code>clone()</code>，不然总会有被该类引用的对象是浅拷贝。</p><blockquote><p>emm... 🤔 有道理啊...</p></blockquote><hr><h2 id="solution" tabindex="-1"><a class="header-anchor" href="#solution"><span>Solution</span></a></h2><p>所以常用的解决方案是使用 <em>Java Object Serialization (JOS)</em>，即序列化和反序列化。从字节层面，把整个对象复制一份。更重要的是，JOS 负责其中的所有细节：</p><ul><li>父类中的 field</li><li>跟随 object graphs 并能够递归地复制引用的所有对象</li></ul><blockquote><p>意思是只管序列化 / 反序列化就行，不用管嵌套对象的问题。</p></blockquote><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">Object</span> orig<span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token class-name">ByteArrayOutputStream</span> bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">ObjectOutputStream</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>bos<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>orig<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token class-name">ObjectInputStream</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span></span>
<span class="line">    <span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">obj <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但也存在问题：</p><ul><li><p>被拷贝的对象 (包括嵌套在内的) 必须实现 <code>java.io.Serializable</code> - 即，必须是可序列化的</p><blockquote><p>那第三方的对象万一无法被序列化咋办呢？它没有实现 <code>java.io.Serializable</code> 接口，我还要修改它的源代码不成？？</p></blockquote></li><li><p>JOS 比较慢</p></li><li><p>Byte array stream 的实现是 <strong>线程安全</strong> 的，因此会有一些额外的开销</p></li></ul><p>可能的优化方式：</p><ol><li><code>ByteArrayOutputStream</code> 默认会初始化 32 字节的数组，然后动态增长 - 那么可以用更大的值初始化</li><li><code>ByteArrayOutputStream</code> 的所有函数都是 <code>synchronized</code> 的 - 由于我们确保是在单线程中执行，同步关键字可以去掉</li><li><code>toByteArray()</code> 会返回 stream 的字节数组的一份拷贝 - 浪费空间和时间</li></ol><hr><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference"><span>Reference</span></a></h2><p><a href="http://javatechniques.com/blog/faster-deep-copies-of-java-objects/" target="_blank" rel="noopener noreferrer">Java Techniques - Faster Deep Copies of Java Objects</a></p><h2 id="summary" tabindex="-1"><a class="header-anchor" href="#summary"><span>Summary</span></a></h2><p>还是需要多读读 JDK 源码。</p><hr>`,41)]))}const i=a(o,[["render",p],["__file","Java Deep Copy.html.vue"]]),r=JSON.parse('{"path":"/notes/Java/Java%20Deep%20Copy.html","title":"Java - Deep Copy","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"About","slug":"about","link":"#about","children":[]},{"level":2,"title":"Clone Function","slug":"clone-function","link":"#clone-function","children":[]},{"level":2,"title":"Issues","slug":"issues","link":"#issues","children":[]},{"level":2,"title":"Solution","slug":"solution","link":"#solution","children":[]},{"level":2,"title":"Reference","slug":"reference","link":"#reference","children":[]},{"level":2,"title":"Summary","slug":"summary","link":"#summary","children":[]}],"git":{},"filePathRelative":"notes/Java/Java Deep Copy.md"}');export{i as comp,r as data};
