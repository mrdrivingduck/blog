import{_ as n,c as a,a as e,o as p}from"./app-7eKjwDat.js";const t={};function o(c,s){return p(),a("div",null,s[0]||(s[0]=[e(`<h1 id="chapter-4-字典" tabindex="-1"><a class="header-anchor" href="#chapter-4-字典"><span>Chapter 4 - 字典</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 06 / 01 15:47</p><p>Nanjing, Jiangsu, China</p><hr><p>字典是用于保存 key-value pair 的抽象数据结构，其中的每一个 key 都是独一无二的。由于 C 内置没有这样的数据结构，Redis 通过实现一个 hash 表来作为字典的底层实现。</p><h2 id="definition" tabindex="-1"><a class="header-anchor" href="#definition"><span>Definition</span></a></h2><p>首先是 hash 表的定义，表结构本身的定义：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictht</span> <span class="token punctuation">{</span></span>
<span class="line">    dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span> <span class="token comment">// Hash 表数组</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span> <span class="token comment">// 表大小 (2^n)</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span> <span class="token comment">// 表大小掩码 == size - 1</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span> <span class="token comment">// 已有结点的数量</span></span>
<span class="line"><span class="token punctuation">}</span> dictht<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>表结点的定义：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">union</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">uint64_t</span> u64<span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">int64_t</span> s64<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span> v<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    sturct dictEntry <span class="token operator">*</span>next<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span> dictEntry<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的实现与 JDK 8 中的 HashMap 实现类似。<code>struct dictht</code> 中，通过 <code>table</code> 指针开辟一个一维的数组。每个元素通过 <code>sizemask</code> 映射到一维数组的相应位置。如果该位置已经存在元素，说明出现了 hash 冲突，冲突结点通过 <code>next</code> 指针的链地址法处理冲突。</p><p>另外，由于冲突链表是一个单向链表，没有表尾指针，因此新加入的冲突结点总是插入到链表的表头位置，这样时间复杂度为 O(1)。</p><p>最上层的字典定义：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dict</span> <span class="token punctuation">{</span></span>
<span class="line">    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 哈希表</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">int</span> trehashidx<span class="token punctuation">;</span> <span class="token comment">// rehash 索引</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用途不同的字典会有不同类型的函数：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> sturct dictType <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 计算 hash 的函数</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>hashFunction<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 复制 key 的函数</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>keyDup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 复制 value 的函数</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>valDup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 对比 key 的函数</span></span>
<span class="line">    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>keyCompare<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key2<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 销毁 key 的函数</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>keyDestructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 销毁 value 的函数</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>valDestructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span> dictType<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="hash-calculation" tabindex="-1"><a class="header-anchor" href="#hash-calculation"><span>Hash Calculation</span></a></h2><p>关于 hash 值的计算是显而易见的。通过定义好的 hash 函数对 key 运算，将得到的结果与 mask 作与运算，就能得到在 hash table 中的 index。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line">hash <span class="token operator">=</span> dict<span class="token operator">-&gt;</span>type<span class="token operator">-&gt;</span><span class="token function">hashFunction</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">index <span class="token operator">=</span> hash <span class="token operator">&amp;</span> dict<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>sizemask<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="rehash" tabindex="-1"><a class="header-anchor" href="#rehash"><span>Rehash</span></a></h2><p>与 JDK HashMap 类似，最复杂的操作应该就是 hash table 的扩容了。当 hash table 的 load factor 超出了一定阈值，就要对表进行扩容，然后对原有的结点重新计算 hash，映射到新的位置上。在字典的 <code>dict</code> 结构体的定义中，为什么要定义两个 hash table <code>ht[2]</code> 呢？</p><p>在平时，hash table 只使用 <code>ht[0]</code>；当 rehash 时，hash table 使用 <code>ht[1]</code> 分配内存。分配内存时有两种情况，但需要保证分配的内存对应的结点数为 <strong>2 的整数次幂</strong>：</p><ul><li>扩容</li><li>收缩</li></ul><p>内存分配完毕后，将 <code>ht[0]</code> 上的点 <strong>逐步迁移</strong> 到 <code>ht[1]</code> 中，直到 <code>ht[0]</code> 称为一个空表。将 <code>ht[1]</code> 赋值给 <code>ht[0]</code>，使 <code>ht[1]</code> 为下一次 rehash 做准备。</p><h2 id="trigger-condition-of-rehash" tabindex="-1"><a class="header-anchor" href="#trigger-condition-of-rehash"><span>Trigger Condition of Rehash</span></a></h2><p>Rehash 在什么条件下才会触发呢？Redis 中定义了一个负载因子的概念：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line">load_factor <span class="token operator">=</span> ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">/</span> ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在什么条件下触发 rehash 呢？</p><ol><li>扩容 - 在 <code>BGSAVE</code> 或 <code>BGREWRITEAOF</code> 命令执行期间，负载因子超过 5</li><li>扩容 - 否则，负载因子超过 1</li><li>收缩 - 负载因子小于 0.1</li></ol><blockquote><p>为什么在 <code>BGSAVE</code> 和 <code>BGREWRITEAOF</code> 命令执行期间，rehash 的触发条件更加苛刻呢？</p><p>在这两个命令执行期间，Redis 会创建子进程，而大部分 OS 使用 copy-on-write 机制来优化子进程。在这期间，如果进行 rehash，那么将带来页面写操作，OS 不得不为写页面的进程重新分配内存。因此，将负载因子阈值调高一些，使 rehash 较难发生。</p></blockquote><h2 id="gradual-rehash" tabindex="-1"><a class="header-anchor" href="#gradual-rehash"><span>Gradual Rehash</span></a></h2><p>Rehash 期间，从 <code>ht[0]</code> 到 <code>ht[1]</code> 的迁移不是一次性完成的，否则可能会因为一次性迁移量太多，而使服务器停止服务。</p><p>Redis 通过 <code>rehashidx</code> 标志字典的 rehash 状态。在 rehash 进行期间，每次对字典进行增删改查时，首先到 <code>ht[0]</code> 上查找，如果找不到再找 <code>ht[1]</code>。在完成相应操作的同时，顺便将 <code>ht[0]</code> 上的结点迁移到 <code>ht[1]</code> 上 (但是新插入结点就只会在 <code>ht[1]</code> 上)。直到 <code>ht[0]</code> 成为空表。</p><p>这种方法，避免了集中式 rehash 带来的庞大计算量，将迁移成本均摊到了每次对字典进行增删改查上。666666 👍</p><hr><p>与 JDK 中的 HashMap 可以说是各有千秋吧，挺有趣的。</p>`,37)]))}const i=n(t,[["render",o],["__file","Chapter 4 - 字典.html.vue"]]),d=JSON.parse('{"path":"/redis-implementation-notes/Part%201%20-%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/Chapter%204%20-%20%E5%AD%97%E5%85%B8.html","title":"Chapter 4 - 字典","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Definition","slug":"definition","link":"#definition","children":[]},{"level":2,"title":"Hash Calculation","slug":"hash-calculation","link":"#hash-calculation","children":[]},{"level":2,"title":"Rehash","slug":"rehash","link":"#rehash","children":[]},{"level":2,"title":"Trigger Condition of Rehash","slug":"trigger-condition-of-rehash","link":"#trigger-condition-of-rehash","children":[]},{"level":2,"title":"Gradual Rehash","slug":"gradual-rehash","link":"#gradual-rehash","children":[]}],"git":{},"filePathRelative":"redis-implementation-notes/Part 1 - 数据结构与对象/Chapter 4 - 字典.md"}');export{i as comp,d as data};
