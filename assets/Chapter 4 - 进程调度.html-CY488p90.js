import{_ as s,c as a,a as e,o as p}from"./app-7eKjwDat.js";const t={};function l(c,n){return p(),a("div",null,n[0]||(n[0]=[e(`<h1 id="chapter-4-进程调度" tabindex="-1"><a class="header-anchor" href="#chapter-4-进程调度"><span>Chapter 4 - 进程调度</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 10 / 14 14:24</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="_4-1-多任务" tabindex="-1"><a class="header-anchor" href="#_4-1-多任务"><span>4.1 多任务</span></a></h2><p>多任务 OS 能够同时并发地交互执行多个进程的 OS</p><ul><li>在单 CPU 上，会产生多个进程同时运行的幻觉</li><li>在多 CPU 上，会有多个进程真正同时、并行地运行</li></ul><p>多任务系统可以被分为两类：</p><ul><li>非抢占式多任务 OS (cooperative multitasking)</li><li>抢占式多任务 OS (preemptive multitasking)</li></ul><p>Linux 提供了抢占式的多任务模式，由调度程序决定什么时候停止一个进程的运行。这个强制挂起的操作就叫做 <strong>抢占</strong>。进程被抢占前能够运行的时间是设置好的——时间片（timeslice）。在非抢占式的多任务模式下，除非进程自己主动停止运行，否则将会一直执行。进程主动挂起自己的操作称为 <strong>让步 （yielding）</strong>。</p><h2 id="_4-2-linux-的进程调度" tabindex="-1"><a class="header-anchor" href="#_4-2-linux-的进程调度"><span>4.2 Linux 的进程调度</span></a></h2><p>Linux 的第一版到 2.4，调度程序都想当简陋，设计近乎原始；在 Linux 2.5 中，引入了 <strong>O(1)</strong> 调度程序：</p><ul><li>该调度程序可以在恒定时间内完成工作，不管输入有多大</li><li>对于调度响应时间敏感的程序有先天不足 (交互进程)</li><li>对于大服务器的工作负载很理想</li><li>在桌面系统上表现不佳</li></ul><p>在 Linux 2.6 中，为了提高对交互程序的调度性能，引入了 <em>Rotating Staircase Deadline scheduler (RSDL)</em>，将 <strong>公平调度</strong> 的概念引入了 Linux 程序，在 2.6.23 内核中替代了 O(1)，被称为 <strong>完全公平调度算法</strong> (CFS)。</p><h2 id="_4-3-策略" tabindex="-1"><a class="header-anchor" href="#_4-3-策略"><span>4.3 策略</span></a></h2><p>策略决定调度程序在何时让什么进程运行。</p><h3 id="_4-3-1-i-o-消耗型和处理器消耗型的进程" tabindex="-1"><a class="header-anchor" href="#_4-3-1-i-o-消耗型和处理器消耗型的进程"><span>4.3.1 I/O 消耗型和处理器消耗型的进程</span></a></h3><p>I/O 消耗型：大部分时间都用于提交 I/O 请求，或等待 I/O 请求，进程经常处于可运行状态。多数 GUI 程序都属于 I/O 密集型。</p><p>CPU 消耗型：时间大部分用于执行代码。</p><ul><li>除非被抢占，否则一直不停地运行</li><li>策略应当是尽量降低调度频率，延长其运行时间</li></ul><p>调度策略需要在两个矛盾的目标上寻找平衡：</p><ul><li>进程响应迅速</li><li>最大系统利用率</li></ul><p>Linux 更倾向于优先调度 I/O 消耗型进程，保证交互式应用和桌面系统的性能；但调度程序也未忽略 CPU 消耗型的进程。</p><h3 id="_4-3-2-进程优先级" tabindex="-1"><a class="header-anchor" href="#_4-3-2-进程优先级"><span>4.3.2 进程优先级</span></a></h3><p>根据进程的 <strong>价值</strong> 和 <strong>对 CPU 时间的需求</strong> 来对进程分级</p><ul><li>优先级高的先运行，低的后运行</li><li>相同优先级按轮转方式进行调度</li></ul><p>Linux 使用了两种不同的优先级范围：</p><ul><li>nice 值 <ul><li><code>-20</code> 到 <code>+19</code></li><li>越大的 nice 值意味着越低的优先级</li></ul></li><li>实时优先级 <ul><li>越高的实时优先级意味着进程优先级越高</li><li>任何实时进程的优先级都高于普通的进程</li></ul></li></ul><h3 id="_4-3-3-时间片" tabindex="-1"><a class="header-anchor" href="#_4-3-3-时间片"><span>4.3.3 时间片</span></a></h3><p>时间片过长 - 系统对交互的响应表现欠佳；时间片过短 - 增大进程切换带来的 CPU 耗时。</p><p>矛盾：</p><ul><li>I/O 消耗型进程不需要较长的时间片</li><li>CPU 消耗型进程希望时间片越长越好</li></ul><p>Linux 的 CFS 调度器并没有直接给进程分配时间片，而是将 CPU 的 <strong>使用比</strong> 划分给了进程。</p><ul><li>进程所获的 CPU 时间与系统负载相关</li><li>比例还会进一步受 nice 值影响</li><li>nice 值作为权重，调整进程使用的 CPU 时间比</li></ul><p>使用 CFS 调度器，进程的抢占时机取决于新的可运行程序消耗了多少 CPU 使用比——如果消耗的使用比比当前进程小，则新进程投入运行。</p><h3 id="_4-3-4-调度策略的活动" tabindex="-1"><a class="header-anchor" href="#_4-3-4-调度策略的活动"><span>4.3.4 调度策略的活动</span></a></h3><h2 id="_4-4-linux-调度算法" tabindex="-1"><a class="header-anchor" href="#_4-4-linux-调度算法"><span>4.4 Linux 调度算法</span></a></h2><h3 id="_4-4-1-调度器类" tabindex="-1"><a class="header-anchor" href="#_4-4-1-调度器类"><span>4.4.1 调度器类</span></a></h3><p>Linux 调度器以模块方式提供，允许不同进程可以有针对性地选择调度算法，允许多种不同的可动态添加的调度算法并存。每个调度算法调度属于自己范畴的进程，每个调度器有一个优先级，按照优先级顺序遍历调度器类，拥有一个可执行进程的最高优先级调度器类胜出。</p><p>完全公平调度 (CFS) 是针对 <strong>普通进程</strong> 的调度类：<code>SCHED_NORMAL</code>。</p><h3 id="_4-4-2-unix-系统中的进程调度" tabindex="-1"><a class="header-anchor" href="#_4-4-2-unix-系统中的进程调度"><span>4.4.2 Unix 系统中的进程调度</span></a></h3><p>问题：</p><ol><li>nice 的单位对应到 CPU 的绝对时间有问题</li><li>把 nice 的值减小 1 所带来的效果极大地取决于 nice 的初始值</li><li>...</li><li>...</li></ol><p>实质：分配绝对的时间片引发的固定的切换频率，给公平性造成了很大变数。CFS 对时间片的分配方式进行了根本性的重新设计，确保了进程调度能够有恒定的公平性。</p><h3 id="_4-4-3-公平调度" tabindex="-1"><a class="header-anchor" href="#_4-4-3-公平调度"><span>4.4.3 公平调度</span></a></h3><p>CFS 的出发点：n 个进程，则每个进程能获得 1/n 的 CPU 时间。</p><p>在任何可测量周期内，给予 n 个进程中每个进程同样多的时间。CFS 允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程，不再给每个进程分配时间片。CFS 在所有可运行进程总数的基础上计算出一个进程应该运行多久，不依靠 nice 值来计算时间片。nice 值被作为进程获得 CPU 运行比的权重。</p><p>CFS 为调度周期的近似值设立了一个目标：<strong>目标延迟</strong>。调度周期越小，越接近完美的多任务，但必须承受更高的切换代价和更差的系统吞吐能力。若任务数量趋近于无限，所获得的 CPU 使用比将趋近于 0。CFS 为每个进程获得的时间片设置了一个底线——最小粒度，确保进程的最少运行时间。</p><p>另外，绝对的 nice 值不再影响调度决策 - 相对值才会影响分配比。进程的 CPU 时间由它自己和所有其它可运行进程的 nice 差值决定，nice 值对时间片的作用不再是算术加权，而是几何加权，CFS 确保给每个进程公平的 CPU 使用比。</p><h2 id="_4-5-linux-调度的实现" tabindex="-1"><a class="header-anchor" href="#_4-5-linux-调度的实现"><span>4.5 Linux 调度的实现</span></a></h2><h3 id="_4-5-1-时间记账" tabindex="-1"><a class="header-anchor" href="#_4-5-1-时间记账"><span>4.5.1 时间记账</span></a></h3><p>所有调度器都需要对进程的运行时间记账：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">load_weight</span> load<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> run_node<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> group_node<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> on_rq<span class="token punctuation">;</span></span>
<span class="line">    u64 exec_start<span class="token punctuation">;</span></span>
<span class="line">    u64 sum_exec_runtime<span class="token punctuation">;</span></span>
<span class="line">    u64 vruntime<span class="token punctuation">;</span></span>
<span class="line">    u64 prev_sum_exec_runtime<span class="token punctuation">;</span></span>
<span class="line">    u64 last_wakeup<span class="token punctuation">;</span></span>
<span class="line">    u64 avg_overlap<span class="token punctuation">;</span></span>
<span class="line">    u64 nr_migrations<span class="token punctuation">;</span></span>
<span class="line">    u64 start_runtime<span class="token punctuation">;</span></span>
<span class="line">    u64 avg_wakeup<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个结构作为一个名为 <code>se</code> 的成员变量，嵌入在 PCB 内：</p><ul><li><code>vruntime</code> 存放进程的虚拟运行时间</li><li>ns 为单位</li><li>记录一个程序到底运行了多长时间，以及它还应该再运行多久</li></ul><p>记账功能实现：由系统定时器周期性调用。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">update_curr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr <span class="token operator">=</span> cfs_rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span></span>
<span class="line">    u64 now <span class="token operator">=</span> <span class="token function">rq_of</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token operator">-&gt;</span>clock<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> delta_exec<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>curr<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    delta_exec <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>now <span class="token operator">-</span> curr<span class="token operator">-&gt;</span>exec_start<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 计算当前进程的执行时间</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>delta_exec<span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">__update_curr</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> curr<span class="token punctuation">,</span> delta_exec<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据可运行进程总数对运行时间进程加权计算</span></span>
<span class="line">    curr<span class="token operator">-&gt;</span>exec_start <span class="token operator">=</span> now<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">entity_is_task</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curtask <span class="token operator">=</span> <span class="token function">task_of</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token function">trace_sched_stat_runtime</span><span class="token punctuation">(</span>curtask<span class="token punctuation">,</span> delta_exec<span class="token punctuation">,</span> curr<span class="token operator">-&gt;</span>vruntime<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token function">cpuacct_charge</span><span class="token punctuation">(</span>curtask<span class="token punctuation">,</span> delta_exec<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token function">account_group_exec_runtime</span><span class="token punctuation">(</span>curtask<span class="token punctuation">,</span> delta_exec<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__update_curr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> delta_exec<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> delta_exec_weighted<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token function">schedstat_set</span><span class="token punctuation">(</span>curr<span class="token operator">-&gt;</span>exec_max<span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">(</span>u64<span class="token punctuation">)</span>delta_exec<span class="token punctuation">,</span> curr<span class="token operator">-&gt;</span>exec_max<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    curr<span class="token operator">-&gt;</span>sum_exec_runtime <span class="token operator">+=</span> delta_exec<span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">schedstat_add</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> exec_clock<span class="token punctuation">,</span> delta_exec<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    delta_exec_weighted <span class="token operator">=</span> <span class="token function">calc_delta_fair</span><span class="token punctuation">(</span>delta_exec<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    curr<span class="token operator">-&gt;</span>vruntime <span class="token operator">+=</span> delta_exec_weighted<span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">update_min_vruntime</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-5-2-进程选择" tabindex="-1"><a class="header-anchor" href="#_4-5-2-进程选择"><span>4.5.2 进程选择</span></a></h3><p>均衡进程的虚拟运行时间——挑选一个具有最小 <code>vruntime</code> 的进程。如何实现选择具有最小 <code>vruntime</code> 的进程？CFS 使用 <strong>红黑树</strong> 来组织可运行进程队列，迅速找到 <code>vruntime</code> 最小的进程——只需找到树的最左下子节点即可。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span><span class="token function">__pick_next_entity</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>left <span class="token operator">=</span> cfs_rq<span class="token operator">-&gt;</span>rb_leftmost<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>left<span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token function">rb_entry</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span><span class="token punctuation">,</span> run_node<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>并不遍历获得最左子节点。该值已经缓存在 <code>rb_leftmost</code> 中，如果返回值为 NULL，则说明没有最左子节点，也就是树中没有任何结点。即没有可运行进程——CFS 便选择 idle 任务运行。当进程变为可运行状态（wake up）或第一次创建进程时，CFS 将进程加入红黑树中：</p></blockquote><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">enqueue_entity</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> ENQUEUE_WAKEUP<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> ENQUEUE_MIGRATE<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">        se<span class="token operator">-&gt;</span>vruntime <span class="token operator">+=</span> cfs_rq<span class="token operator">-&gt;</span>min_vruntime<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token function">update_curr</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">account_entity_enqueue</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> ENQUEUE_WAKEUP<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">place_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token function">enqueue_sleeper</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token function">update_stats_enqueue</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">check_spread</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>se <span class="token operator">!=</span> cfs_rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">)</span></span>
<span class="line">        <span class="token function">__enqueue_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将一些统计信息记录到 <code>se</code> 中，然后调用繁重的插入操作：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">__enqueue_entity</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token operator">*</span>link <span class="token operator">=</span> <span class="token operator">&amp;</span>cfs_rq<span class="token operator">-&gt;</span>tasks_timeline<span class="token punctuation">.</span>rb_node<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>parent <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>entry<span class="token punctuation">;</span></span>
<span class="line">    s64 key <span class="token operator">=</span> <span class="token function">entity_key</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">int</span> leftmost <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>link<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        parent <span class="token operator">=</span> <span class="token operator">*</span>link<span class="token punctuation">;</span></span>
<span class="line">        entry <span class="token operator">=</span> <span class="token function">rb_entry</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span><span class="token punctuation">,</span> run_node<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> <span class="token function">entity_key</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            link <span class="token operator">=</span> <span class="token operator">&amp;</span>parent<span class="token operator">-&gt;</span>rb_left<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">            link <span class="token operator">=</span> <span class="token operator">&amp;</span>parent<span class="token operator">-&gt;</span>rb_right<span class="token punctuation">;</span></span>
<span class="line">            leftmost <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 新插入结点不是最左结点</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>leftmost<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 新插入结点是最左结点，更新缓存</span></span>
<span class="line">        cfs_rq<span class="token operator">-&gt;</span>rb_leftmost <span class="token operator">=</span> <span class="token operator">&amp;</span>se<span class="token operator">-&gt;</span>run_node<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token function">rb_link_node</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>se<span class="token operator">-&gt;</span>run_node<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> link<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 插入子节点</span></span>
<span class="line">    <span class="token function">rb_insert_color</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>se<span class="token operator">-&gt;</span>run_node<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cfs_rq<span class="token operator">-&gt;</span>tasks_timeline<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新自平衡属性</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>进程从树中的删除发生在进程阻塞（不可运行状态）或终止时：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">dequeue_entity</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">,</span> <span class="token keyword">int</span> sleep<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">update_curr</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token function">update_stats_dequeue</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">clear_buddies</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>se <span class="token operator">!=</span> cfs_rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">)</span></span>
<span class="line">        <span class="token function">__dequeue_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">account_entity_dequeue</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">update_min_vruntime</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sleep<span class="token punctuation">)</span></span>
<span class="line">        se<span class="token operator">-&gt;</span>vruntime <span class="token operator">-=</span> cfs_rq<span class="token operator">-&gt;</span>min_vruntime<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">__dequeue_entity</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>cfs_rq<span class="token operator">-&gt;</span>rb_leftmost <span class="token operator">==</span> <span class="token operator">&amp;</span>se<span class="token operator">-&gt;</span>run_node<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 要删除的结点是最左结点</span></span>
<span class="line">        <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>next_node<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        next_node <span class="token operator">=</span> <span class="token function">rb_next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>se<span class="token operator">-&gt;</span>run_node<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        cfs_rq<span class="token operator">-&gt;</span>rb_leftmost <span class="token operator">=</span> next_node<span class="token punctuation">;</span> <span class="token comment">// 更新缓存</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token function">rb_erase</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>se<span class="token operator">-&gt;</span>run_node<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cfs_rq<span class="token operator">-&gt;</span>tasks_timeline<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-5-3-调度器入口" tabindex="-1"><a class="header-anchor" href="#_4-5-3-调度器入口"><span>4.5.3 调度器入口</span></a></h3><p>进程调度的入口点是函数 <code>schedule()</code>，是内核其它部分调用进程调度器的入口。在其中调用 <code>pick_next_task()</code>，以优先级从高到低依次检查调度类，选择最高优先级的调度类中，最高优先级的进程。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 优化：如果所有任务都在公平类中</span></span>
<span class="line">    <span class="token comment">// 所有可运行进程数 == cfs 的可运行进程数</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>rq<span class="token operator">-&gt;</span>nr_running <span class="token operator">==</span> rq<span class="token operator">-&gt;</span>cfs<span class="token punctuation">.</span>nr_running<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        p <span class="token operator">=</span> fair_sched_class<span class="token punctuation">.</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">            <span class="token keyword">return</span> p<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    class <span class="token operator">=</span> sched_class_highest<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        p <span class="token operator">=</span> class<span class="token operator">-&gt;</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment">// 永远不会返回 NULL，因为 idle 总是返回非 NULL 的 p</span></span>
<span class="line">            <span class="token keyword">return</span> p<span class="token punctuation">;</span></span>
<span class="line">        class <span class="token operator">=</span> class<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于绝大多数进程运行在 CFS 类中，因为上面函数中做了一定的优化。循环以优先级为序，遍历每个调度类，每个调度类都实现了 <code>pick_next_task()</code> 函数，返回下一个可运行进程的指针。</p><h3 id="_4-5-4-睡眠和唤醒" tabindex="-1"><a class="header-anchor" href="#_4-5-4-睡眠和唤醒"><span>4.5.4 睡眠和唤醒</span></a></h3><p>睡眠：</p><ul><li>进程把自己标记为休眠状态</li><li>从可执行红黑树中移出，放入等待队列</li><li>然后调用 <code>schedule()</code> 选择和执行一个进程</li></ul><p>唤醒：</p><ul><li>进程被设置为可执行状态</li><li>从等待队列移到可执行红黑树中</li></ul><p>休眠通过 <strong>等待队列</strong> 进行处理。等待队列是由等待某些事件发生的进程组成的简单链表，内核用 <code>wake_queue_head_t</code> 来代表等待队列。进程将自己放入等待队列，并设置为不可执行状态。</p><p>休眠和唤醒的实现不能有纰漏，因为可能存在竞争条件：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token function">DEFINE_WAIT</span><span class="token punctuation">(</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建等待队列的等待项</span></span>
<span class="line"><span class="token function">add_wait_queue</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将等待项加入到队列中</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// condition 是等待的事件</span></span>
<span class="line">    <span class="token function">prepare_to_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">,</span> TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 进程状态变更</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">signal_pending</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 唤醒不是因为事件的发生，而是信号</span></span>
<span class="line">        <span class="token comment">// 检查并处理信号</span></span>
<span class="line">    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调度，继续等待</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token comment">// 等待的事件到来</span></span>
<span class="line"><span class="token function">finish_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将自己设置为 TASK_RUNNING，移除等待队列</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>唤醒通过 <code>wake_up()</code> 函数进行</p><ul><li>唤醒等待队列上的所有进程</li><li>设置进程的 <code>TASK_RUNNING</code> 状态</li><li>加入可执行红黑树</li><li>如果被唤醒进程的优先级比当前进程高，则设置 <code>need_resched</code> 标志</li></ul><p>进程被唤醒并不是因为等待的条件达成，可能是因为收到了信号。</p><h2 id="_4-6-抢占和上下文切换" tabindex="-1"><a class="header-anchor" href="#_4-6-抢占和上下文切换"><span>4.6 抢占和上下文切换</span></a></h2><p>上下文切换，即从一个可执行进程切换到另一个可执行进程：</p><ul><li>由 <code>context_switch()</code> 函数负责处理</li><li>该函数被 <code>schedule()</code> 调用</li></ul><p>完成两项基本工作：</p><ul><li>调用 <code>switch_mm()</code>，把虚拟内存映射切换到新进程中</li><li>调用 <code>switch_to()</code>，从上一个进程的 CPU 状态切换到新进程的 CPU 状态</li></ul><blockquote><p>这两个好像都是和体系结构有关的宏。</p></blockquote><p>内核提供一个 <code>need_resched</code> 标志，表明是否需要重新执行一次调度。何时设置这个标志呢？</p><ul><li>某个进程应该被抢占时</li><li>当一个优先级高的进程进入可执行状态时</li></ul><p>该标志对于内核来说是一个信息，表示有其它进程应当被运行了，要尽快执行调度程序。内核检查该标志，并调用 <code>schedule()</code> 切换到新进程。检查该标志的时机：</p><ul><li>返回用户空间前</li><li>从中断返回时</li></ul><p>每个进程都有一个 <code>need_resched</code> 标志</p><ul><li>之前位于 <code>task_struct</code> 中，2.6 位于 <code>thread_info</code> 中</li><li>因为访问 PCB 中的数据比访问全局变量快，因此 <code>current</code> 宏速度很快，而且通常都在 cache 中</li></ul><h3 id="_4-6-1-用户抢占" tabindex="-1"><a class="header-anchor" href="#_4-6-1-用户抢占"><span>4.6.1 用户抢占</span></a></h3><p>如果 <code>need_resched</code> 标志被设置，就会导致调度函数被调用。时机：</p><ul><li>从系统调用返回用户空间时</li><li>从中断处理程序返回用户空间时</li></ul><h3 id="_4-6-2-内核抢占" tabindex="-1"><a class="header-anchor" href="#_4-6-2-内核抢占"><span>4.6.2 内核抢占</span></a></h3><p>在不支持内核抢占的内核中，内核代码可以一直执行，到完成为止。在 2.6 的内核中，引入了抢占能力 - 只要重新调度是安全的，内核就可以在任何时间抢占正在执行的任务。什么时候重新调度才是安全的？</p><ul><li>只要没有持有锁，内核就可以被抢占</li><li>如果没有持有锁，正在执行的代码就是可重入的</li></ul><p>因此，为每个 <code>thread_info</code> 引入 <code>preempt_count</code> 计数器</p><ul><li>初始值为 0</li><li>使用锁的时候 +1，释放锁的时候 -1</li><li>当数值为 0 时，内核就可以被抢占</li></ul><p>当中断返回内核空间时，若 <code>need_reschd</code> 被设置，<code>preempt_count</code> 为 0，则说明有更重要的任务要被执行，且可以安全抢占。调度程序会被调用。</p><p>如果内核代码被阻塞了，或者显式调用了 <code>schedule()</code>：</p><ul><li>内核抢占会显式地发生</li><li>这种形式的内核抢占从来都是受支持的</li><li>显式调用意味着它应该清楚自己是可以被安全地抢占的</li></ul><p>时机：</p><ul><li>中断处理程序返回内核空间之前</li><li>内核代码再一次具有可抢占性 (所有锁被释放)</li><li>内核任务显式调用调度函数</li><li>内核中的任务阻塞</li></ul><h2 id="_4-7-实时调度策略" tabindex="-1"><a class="header-anchor" href="#_4-7-实时调度策略"><span>4.7 实时调度策略</span></a></h2><p>两种实时调度策略：</p><ul><li><code>SCHED_FIFO</code><ul><li>简单的先入先出调度算法</li><li>不使用时间片，执行到自身受阻塞或显式释放 CPU 为止</li><li>比普通的 <code>SCHED_NORMAL</code> 进程更先得到调度</li></ul></li><li><code>SCHED_RR</code><ul><li>与 <code>SCHED_FIFO</code> 大致相同</li><li>耗尽预先分配的时间片以后就不再继续执行</li><li>实时轮转调度算法</li></ul></li></ul><p>两种算法都使用了静态优先级。Linux 的实时调度算法提供了 <strong>软实时</strong> 工作方式，尽力保证在限定时间到来前运行。Linux 对于实时任务的调度不做任何保证。</p><h2 id="_4-8-与调度相关的系统调用" tabindex="-1"><a class="header-anchor" href="#_4-8-与调度相关的系统调用"><span>4.8 与调度相关的系统调用</span></a></h2><p>Linux 提供了一些系统调用，用于管理与调度程序相关的参数。</p><h3 id="_4-8-1-与调度策略和优先级相关的系统调用" tabindex="-1"><a class="header-anchor" href="#_4-8-1-与调度策略和优先级相关的系统调用"><span>4.8.1 与调度策略和优先级相关的系统调用</span></a></h3><ul><li>设置和获取进程的调度策略和实时优先级 <ul><li><code>sched_setscheduler()</code></li><li><code>sched_getscheduler()</code></li></ul></li><li>设置和获取进程的实时优先级 <ul><li><code>sched_setparam()</code></li><li><code>sched_getparam()</code></li></ul></li><li>对于普通进程，可以调用 <code>nice()</code></li></ul><h3 id="_4-8-2-与处理器绑定有关的系统调用" tabindex="-1"><a class="header-anchor" href="#_4-8-2-与处理器绑定有关的系统调用"><span>4.8.2 与处理器绑定有关的系统调用</span></a></h3><p>使进程 <strong>尽量</strong> 在同一个 CPU 上运行；但允许用户 <strong>强制指定</strong> 这个进程必须在某个 CPU 上执行。</p><h3 id="_4-8-3-放弃处理器时间" tabindex="-1"><a class="header-anchor" href="#_4-8-3-放弃处理器时间"><span>4.8.3 放弃处理器时间</span></a></h3><p>通过 <code>sched_yield()</code> 系统调用，让进程显式地将 CPU 时间让给其它进程：</p><ul><li>对于普通进程，将其从活动队列移到过期队列</li><li>对于实时进程，将其移动到活动队列的最后</li></ul>`,122)]))}const o=s(t,[["render",l],["__file","Chapter 4 - 进程调度.html.vue"]]),u=JSON.parse('{"path":"/linux-kernel-development-notes/Chapter%204%20-%20%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6.html","title":"Chapter 4 - 进程调度","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"4.1 多任务","slug":"_4-1-多任务","link":"#_4-1-多任务","children":[]},{"level":2,"title":"4.2 Linux 的进程调度","slug":"_4-2-linux-的进程调度","link":"#_4-2-linux-的进程调度","children":[]},{"level":2,"title":"4.3 策略","slug":"_4-3-策略","link":"#_4-3-策略","children":[{"level":3,"title":"4.3.1 I/O 消耗型和处理器消耗型的进程","slug":"_4-3-1-i-o-消耗型和处理器消耗型的进程","link":"#_4-3-1-i-o-消耗型和处理器消耗型的进程","children":[]},{"level":3,"title":"4.3.2 进程优先级","slug":"_4-3-2-进程优先级","link":"#_4-3-2-进程优先级","children":[]},{"level":3,"title":"4.3.3 时间片","slug":"_4-3-3-时间片","link":"#_4-3-3-时间片","children":[]},{"level":3,"title":"4.3.4 调度策略的活动","slug":"_4-3-4-调度策略的活动","link":"#_4-3-4-调度策略的活动","children":[]}]},{"level":2,"title":"4.4 Linux 调度算法","slug":"_4-4-linux-调度算法","link":"#_4-4-linux-调度算法","children":[{"level":3,"title":"4.4.1 调度器类","slug":"_4-4-1-调度器类","link":"#_4-4-1-调度器类","children":[]},{"level":3,"title":"4.4.2 Unix 系统中的进程调度","slug":"_4-4-2-unix-系统中的进程调度","link":"#_4-4-2-unix-系统中的进程调度","children":[]},{"level":3,"title":"4.4.3 公平调度","slug":"_4-4-3-公平调度","link":"#_4-4-3-公平调度","children":[]}]},{"level":2,"title":"4.5 Linux 调度的实现","slug":"_4-5-linux-调度的实现","link":"#_4-5-linux-调度的实现","children":[{"level":3,"title":"4.5.1 时间记账","slug":"_4-5-1-时间记账","link":"#_4-5-1-时间记账","children":[]},{"level":3,"title":"4.5.2 进程选择","slug":"_4-5-2-进程选择","link":"#_4-5-2-进程选择","children":[]},{"level":3,"title":"4.5.3 调度器入口","slug":"_4-5-3-调度器入口","link":"#_4-5-3-调度器入口","children":[]},{"level":3,"title":"4.5.4 睡眠和唤醒","slug":"_4-5-4-睡眠和唤醒","link":"#_4-5-4-睡眠和唤醒","children":[]}]},{"level":2,"title":"4.6 抢占和上下文切换","slug":"_4-6-抢占和上下文切换","link":"#_4-6-抢占和上下文切换","children":[{"level":3,"title":"4.6.1 用户抢占","slug":"_4-6-1-用户抢占","link":"#_4-6-1-用户抢占","children":[]},{"level":3,"title":"4.6.2 内核抢占","slug":"_4-6-2-内核抢占","link":"#_4-6-2-内核抢占","children":[]}]},{"level":2,"title":"4.7 实时调度策略","slug":"_4-7-实时调度策略","link":"#_4-7-实时调度策略","children":[]},{"level":2,"title":"4.8 与调度相关的系统调用","slug":"_4-8-与调度相关的系统调用","link":"#_4-8-与调度相关的系统调用","children":[{"level":3,"title":"4.8.1 与调度策略和优先级相关的系统调用","slug":"_4-8-1-与调度策略和优先级相关的系统调用","link":"#_4-8-1-与调度策略和优先级相关的系统调用","children":[]},{"level":3,"title":"4.8.2 与处理器绑定有关的系统调用","slug":"_4-8-2-与处理器绑定有关的系统调用","link":"#_4-8-2-与处理器绑定有关的系统调用","children":[]},{"level":3,"title":"4.8.3 放弃处理器时间","slug":"_4-8-3-放弃处理器时间","link":"#_4-8-3-放弃处理器时间","children":[]}]}],"git":{},"filePathRelative":"linux-kernel-development-notes/Chapter 4 - 进程调度.md"}');export{o as comp,u as data};
