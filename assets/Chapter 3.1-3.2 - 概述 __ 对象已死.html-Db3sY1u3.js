import{_ as l,c as a,a as i,o as n}from"./app-7eKjwDat.js";const t={};function r(s,e){return n(),a("div",null,e[0]||(e[0]=[i('<h1 id="chapter-3-1-3-2-概述-对象已死" tabindex="-1"><a class="header-anchor" href="#chapter-3-1-3-2-概述-对象已死"><span>Chapter 3.1-3.2 - 概述 &amp;&amp; 对象已死</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 01 / 25 16:24 🧨🧧</p><p>Ningbo, Zhejiang, China</p><hr><h2 id="_3-1-概述" tabindex="-1"><a class="header-anchor" href="#_3-1-概述"><span>3.1 概述</span></a></h2><p>程序计数器、虚拟机栈、本地方法栈随线程而生，随线程而灭，因此这些区域的内存分配和回收具有确定性，所以不需要过多考虑内存回收的问题。而 Java Heap 和方法区这两个部分有着很显著的不确定性，内存的分配和回收是动态的。</p><h2 id="_3-2-对象已死" tabindex="-1"><a class="header-anchor" href="#_3-2-对象已死"><span>3.2 对象已死？</span></a></h2><p>垃圾收集器对堆进行回收前，首先要确定对象是否还存活或是死去。</p><h3 id="_3-2-1-引用计数算法" tabindex="-1"><a class="header-anchor" href="#_3-2-1-引用计数算法"><span>3.2.1 引用计数算法</span></a></h3><p>在对象中添加一个引用计数器</p><ul><li>有一个地方引用它时，计数器 +1</li><li>引用失效时，计数器 -1</li></ul><p>任何时刻，计数器为 0 的对象就是不可能再被使用的。</p><p>这个方法存在互相循环引用的问题：</p><ul><li>两个对象互相引用对方，计数器都不为零</li><li>但两个对象已经不可能再被访问</li><li>GC 也无法回收这两个对象</li></ul><h3 id="_3-2-2-可达性分析-reachability-analysis-算法" tabindex="-1"><a class="header-anchor" href="#_3-2-2-可达性分析-reachability-analysis-算法"><span>3.2.2 可达性分析 (Reachability Analysis) 算法</span></a></h3><p>以 <strong>GC Roots</strong> 作为根对象 (起点集)，顺着引用关系进行搜索。搜索过的路径称为 <strong>引用链 (Reference Chain)</strong>。如果某个对象到 GC Roots 之间没有任何引用链，就说明该对象不可能再被使用。</p><h3 id="_3-2-3-再谈引用" tabindex="-1"><a class="header-anchor" href="#_3-2-3-再谈引用"><span>3.2.3 再谈引用</span></a></h3><p>引用只有 <strong>被引用</strong> 和 <strong>未被引用</strong> 两个状态过于绝对。JDK 1.2 之后，对引用概念进行了补充：</p><ul><li>强引用 (Strong Reference) 是最传统的引用定义：只要强引用关系还存在，GC 就永远不会回收掉被引用的对象</li><li>软引用 (Soft Reference) 用于描述一些还有用但非必须的对象：在内存溢出异常前，会对这些对象进行回收，如果回收后还是没有足够的内存，才会抛出内存溢出异常</li><li>弱引用 (Weak Reference)：只能生存到下一次 GC 发生前</li><li>虚引用 (Phantom Reference)：对象在被 GC 时能收到一个系统通知</li></ul><h3 id="_3-2-4-生存还是死亡" tabindex="-1"><a class="header-anchor" href="#_3-2-4-生存还是死亡"><span>3.2.4 生存还是死亡？</span></a></h3><p>宣告一个对象死亡的过程</p><ol><li>对象在进行可达性分析后发现没有与 GC Roots 相连，就被第一次标记，随后进行一次筛选 <ul><li>筛选条件是，是否需要为对象执行 <code>finalize()</code> 函数 <ul><li>一个对象的 <code>finalize()</code> 函数只能被调用一次</li><li>对象需要覆盖 <code>finalize()</code> 函数才会被调用</li></ul></li><li>如果有必要执行 <code>finalize()</code> 函数，则对象加入 F-Queue 队列中 <ul><li>由 JVM 中的一个低调度优先级的线程来执行</li><li>在 <code>finalize()</code> 中如果能够与引用链建立关系，就能避免被 GC</li></ul></li></ul></li><li>垃圾收集器对 F-Queue 中的对象进行第二次标记 <ul><li>如果对象重新建立引用关系，就移除待 GC 集合</li><li>剩下的对象会被最终 GC</li></ul></li></ol><p>注意，同一个对象的 <code>finalize()</code> 不会被调用两次，官方声明尽量避免使用 <code>finalize()</code>。</p><h3 id="_3-2-5-回收方法区" tabindex="-1"><a class="header-anchor" href="#_3-2-5-回收方法区"><span>3.2.5 回收方法区</span></a></h3><p>在方法区回收垃圾的性价比较低。回收对象：</p><ul><li>废弃的常量</li><li>不再使用的类型</li></ul>',27)]))}const c=l(t,[["render",r],["__file","Chapter 3.1-3.2 - 概述 __ 对象已死.html.vue"]]),p=JSON.parse('{"path":"/understanding-the-jvm-notes/Part%202%20-%20%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Chapter%203.1-3.2%20-%20%E6%A6%82%E8%BF%B0%20__%20%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB.html","title":"Chapter 3.1-3.2 - 概述 && 对象已死","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"3.1 概述","slug":"_3-1-概述","link":"#_3-1-概述","children":[]},{"level":2,"title":"3.2 对象已死？","slug":"_3-2-对象已死","link":"#_3-2-对象已死","children":[{"level":3,"title":"3.2.1 引用计数算法","slug":"_3-2-1-引用计数算法","link":"#_3-2-1-引用计数算法","children":[]},{"level":3,"title":"3.2.2 可达性分析 (Reachability Analysis) 算法","slug":"_3-2-2-可达性分析-reachability-analysis-算法","link":"#_3-2-2-可达性分析-reachability-analysis-算法","children":[]},{"level":3,"title":"3.2.3 再谈引用","slug":"_3-2-3-再谈引用","link":"#_3-2-3-再谈引用","children":[]},{"level":3,"title":"3.2.4 生存还是死亡？","slug":"_3-2-4-生存还是死亡","link":"#_3-2-4-生存还是死亡","children":[]},{"level":3,"title":"3.2.5 回收方法区","slug":"_3-2-5-回收方法区","link":"#_3-2-5-回收方法区","children":[]}]}],"git":{},"filePathRelative":"understanding-the-jvm-notes/Part 2 - 自动内存管理/Chapter 3.1-3.2 - 概述 && 对象已死.md"}');export{c as comp,p as data};
