import{_ as a,c as t,a as i,o as l}from"./app-7eKjwDat.js";const n={};function r(p,e){return l(),t("div",null,e[0]||(e[0]=[i('<h1 id="chapter-4-4-分页机制" tabindex="-1"><a class="header-anchor" href="#chapter-4-4-分页机制"><span>Chapter 4.4 - 分页机制</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 07 / 25 11:45</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="_4-4-分页机制" tabindex="-1"><a class="header-anchor" href="#_4-4-分页机制"><span>4.4 分页机制</span></a></h2><p>80X86 内存管理机制的第二部分：负责将线性地址转换为物理地址。线性地址空间中的页面被映射到物理地址空间的页面上。设置 CR0 的 PG 位以启用分页机制，分页机制对 <strong>固定大小</strong> 的内存块进行操作。分页机制将线性地址空间和物理地址空间划分成页面，任何线性地址空间中的页都可以映射到任何物理地址空间中的页上。</p><p>80X86 使用 <code>2^12</code> (4KB) 大小的固定页面，并对齐于 4K 地址边界。也就是说，4G 线性地址空间被划分为 <code>2^20</code> (1M) 个页面。由于页对齐，线性地址空间的高 20-bit 被转换为物理地址空间的高 20-bit，低 12-bit 被直接用作页内偏移量。</p><p>地址转换机制允许一个线性地址被标注为无效的：</p><ol><li>OS 不支持的线性地址，产生无效地址的程序应当被终止</li><li>对应的页面在磁盘上，不在物理内存中，触发 OS 的异常，请求 OS 将对应页面从磁盘上载入物理内存</li></ol><p>页错误异常：由页错误异常的处理程序让 OS 将相应页面载入内存。此过程中，OS 可能还需要将被替换的页面保存到磁盘上。页被载入物理内存后，异常返回操作会使得导致异常的指令被重新执行。用于 <strong>线性地址 → 物理地址</strong> 和 <strong>产生页错误异常</strong> 的信息保存在 <strong>页目录</strong> 和 <strong>页表</strong> 中</p><p>分页使用了固定长度的页面。因此，一个数据结构可以一部分存在于物理内存中，一部分存在于磁盘中。为了减少地址转换需要的总线周期，最近被访问的页目录和页表都会被放在 TLB 中 - 满足大多数读取页目录和页表的需求，无需使用总线周期。</p><h3 id="_4-4-1-页表结构" tabindex="-1"><a class="header-anchor" href="#_4-4-1-页表结构"><span>4.4.1 页表结构</span></a></h3><p>Page Table - 存放于物理地址空间中。可以看作是具有 <code>2^20</code> 个项的数组，映射功能即数组查找。由于页面基地址对齐于 4K 地址边界，低 12-bit 肯定是 0。</p><p>页表中每个页表项的大小为 32-bit (4B)其中只需要 20-bit 来存储物理页基地址，剩下 12-bit 可用于存放页属性信息。</p><h4 id="_4-4-1-1-两级页表结构" tabindex="-1"><a class="header-anchor" href="#_4-4-1-1-两级页表结构"><span>4.4.1.1 两级页表结构</span></a></h4><p>页表含有 1M 个表项，每个项 4B，共需要 4MB 的空间。为了减少内存占用量，80X86 使用了两级表，高 20-bit 的线性地址转换被分为两步，每步使用 10-bit。</p><p>第一级：页目录 (Page Directory)，存放在一个 4KB 的页中，具有 <code>2^10</code> (1K) 个 4B 的页目录项。页目录项中存放对应页表的页的 20-bit 物理基地址，线性地址的最高 10-bit 用于在页目录中进行查找。</p><p>第二级：页表 (Page Table)，长度也是一个页，最多含有 1K 个 4B 的页表项。表项中存放对应页面的 20-bit 物理基地址，线性地址的中间 10-bit 用于在页面中进行查找。</p><p>查找到的 20-bit 物理基地址 + 线性地址低 12-bit 的页内偏移组成 32-bit 物理地址。其中，CR3 寄存器存放了页目录表的物理基地址。</p><h4 id="_4-4-1-2-不存在的页表" tabindex="-1"><a class="header-anchor" href="#_4-4-1-2-不存在的页表"><span>4.4.1.2 不存在的页表</span></a></h4><p>二级表结构允许页表被分散在内存各个页面中，不需要保存在连续的 4MB 空间中。而页目录表的页面必须总是存在于物理内存中。二级页表可以在需要时再分配。</p><p>页目录表和页表中每项的低 12-bit 有一个存在 (present) 属性，指明对应访问的页是否存在于物理内存。若不存在，则产生异常，令 OS 将页调入内存。因此，任何时候只需要部分二级页表存放在内存中即可，其余可保存在磁盘上。</p><h3 id="_4-4-2-页表项格式" tabindex="-1"><a class="header-anchor" href="#_4-4-2-页表项格式"><span>4.4.2 页表项格式</span></a></h3><p>每个页表项为 32-bit</p><ul><li>高 20-bit 为对应页面的物理基地址</li><li>低 12-bit 为页属性信息 <ul><li>P - Present - 页存在位</li><li>R/W - Read/Write - 页面是否可被读写或执行</li><li>U/S - User/Supervisor - 页面特权级</li><li>A - Accessed - 页面是否被访问 <ul><li>CPU 只负责设置该标志</li><li>OS 可定期复位该标志来统计页面使用</li></ul></li><li>D - Dirty - 处理器是否对页面进行了修改</li><li>AVL - 专供使用，处理器不会修改</li></ul></li></ul><h3 id="_4-4-3-虚拟存储" tabindex="-1"><a class="header-anchor" href="#_4-4-3-虚拟存储"><span>4.4.3 虚拟存储</span></a></h3><p>页表和页目录表的 P 标志为虚拟存储提供了必要的支持，已访问标志 A 和已修改标志 D 可以用于有效实现虚拟存储技术。周期性检查和复位所有的 A 标志，能够确定哪些页面最近没有被访问，这些页面会成为被替换到磁盘上的候选者。如果移出页面到磁盘时 D 标志位 0，说明该页没有被修改过，则说明磁盘上该页的副本与内存一致，无需写回磁盘。</p>',28)]))}const h=a(n,[["render",r],["__file","Chapter 4.4 - 分页机制.html.vue"]]),o=JSON.parse('{"path":"/linux-kernel-comments-notes/Chapter%204%20-%2080X86%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B6%E7%BC%96%E7%A8%8B/Chapter%204.4%20-%20%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6.html","title":"Chapter 4.4 - 分页机制","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"4.4 分页机制","slug":"_4-4-分页机制","link":"#_4-4-分页机制","children":[{"level":3,"title":"4.4.1 页表结构","slug":"_4-4-1-页表结构","link":"#_4-4-1-页表结构","children":[]},{"level":3,"title":"4.4.2 页表项格式","slug":"_4-4-2-页表项格式","link":"#_4-4-2-页表项格式","children":[]},{"level":3,"title":"4.4.3 虚拟存储","slug":"_4-4-3-虚拟存储","link":"#_4-4-3-虚拟存储","children":[]}]}],"git":{},"filePathRelative":"linux-kernel-comments-notes/Chapter 4 - 80X86 保护模式及其编程/Chapter 4.4 - 分页机制.md"}');export{h as comp,o as data};
