import{_ as n,c as a,a as e,o as l}from"./app-7eKjwDat.js";const t="/blog/assets/3-2-DrpH1-zE.png",c={};function i(p,s){return l(),a("div",null,s[0]||(s[0]=[e(`<h1 id="chapter-3-进程管理" tabindex="-1"><a class="header-anchor" href="#chapter-3-进程管理"><span>Chapter 3 - 进程管理</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 10 / 08 22:37</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="_3-1-进程" tabindex="-1"><a class="header-anchor" href="#_3-1-进程"><span>3.1 进程</span></a></h2><p>进程是处于执行期的程序，包含：</p><ul><li>代码段</li><li>打开的文件</li><li>挂起的信号</li><li>内核内部数据</li><li>处理器状态</li><li>内存地址空间</li><li>一个或多个执行线程</li></ul><p>在 Linux 中，通过 <code>fork()</code> 系统调用来复制一个现有进程，创建全新的进程。在该调用结束时，返回点在相同的位置上</p><ul><li>父进程恢复执行</li><li>子进程开始执行</li></ul><p>通常，创建新进程是为了执行新的不同程序。调用 <code>exec()</code> 函数以创建新的地址空间，并把新程序载入其中。最终，程序通过 <code>exit()</code> 系统调用退出执行，终结进程并释放资源。父进程通过 <code>wait4()</code> 系统调用等待子进程执行完毕。</p><h2 id="_3-2-进程描述符及任务结构" tabindex="-1"><a class="header-anchor" href="#_3-2-进程描述符及任务结构"><span>3.2 进程描述符及任务结构</span></a></h2><p>内核把进程列表存放在称为 <strong>task list</strong> 的 <strong>双向循环链表</strong> 中。</p><blockquote><p>似乎和 Linux 0.12 不一样了？Linux 0.12 好像是数组喔。</p></blockquote><p>链表中的每一项都是 <code>task_struct</code> 结构，也就是 PCB。在 32-bit 机器上，<code>task_struct</code> 大约有 1.7kB，但其中的数据可以完整地描述一个正在执行的程序。</p><h3 id="_3-2-1-分配进程描述符" tabindex="-1"><a class="header-anchor" href="#_3-2-1-分配进程描述符"><span>3.2.1 分配进程描述符</span></a></h3><p>在 Linux 2.6 之前的内核中，各进程的 <code>task_struct</code> 存放在内核栈的尾端——为了让 x86 等寄存器较少的体系结构只需通过栈指针就能计算出其位置。而 Linux 2.6 开始，由 slab 分配器动态生成 <code>task_struct</code>，因此只需要在内核栈底或栈顶创建一个新的结构 <code>struct thread_info</code>。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">exec_domain</span> <span class="token operator">*</span>exec_domain<span class="token punctuation">;</span></span>
<span class="line">    __u32 flags<span class="token punctuation">;</span></span>
<span class="line">    __u32 status<span class="token punctuation">;</span></span>
<span class="line">    __u32 cpu<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">int</span> preempt_count<span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">mm_segment_t</span> addr_limit<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">restart_block</span> restart_block<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token operator">*</span>sysenter_return<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">int</span> uaccess_err<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，<code>task</code> 域存放了指向 PCB 的指针：</p><img src="`+t+`" alt="3-2" style="zoom:50%;"><h3 id="_3-2-2-进程描述符的存放" tabindex="-1"><a class="header-anchor" href="#_3-2-2-进程描述符的存放"><span>3.2.2 进程描述符的存放</span></a></h3><p>内核通过一个唯一的 PID 来标识每个进程。<code>pid_t</code> 类型 (int)，最大默认值为 32768。内核中大部分处理进程的代码都是通过 <code>task_struct</code> 进行的</p><ul><li>通过 <code>current</code> 宏查找当前正在执行执行的速度十分重要</li><li>体系结构不同，该宏的实现方式也不同 <ul><li>有些体系结构可以专门拿出一个寄存器存放当前 <code>task_struct</code> 的指针</li><li>x86 等就只能通过 <code>thread_info</code> 间接查找</li></ul></li></ul><h3 id="_3-2-3-进程状态" tabindex="-1"><a class="header-anchor" href="#_3-2-3-进程状态"><span>3.2.3 进程状态</span></a></h3><ul><li><code>TASK_RUNNING</code></li><li><code>TASK_INTERRUPTIBLE</code></li><li><code>TASK_UNINTERRUPTIBLE</code></li><li><code>__TASK_TRACED</code></li><li><code>__TASK_STOPPED</code></li></ul><h3 id="_3-2-4-设置当前进程状态" tabindex="-1"><a class="header-anchor" href="#_3-2-4-设置当前进程状态"><span>3.2.4 设置当前进程状态</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token function">set_task_state</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// set_current_state(state);</span></span>
<span class="line"><span class="token comment">// task-&gt;state = state;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-2-5-进程上下文" tabindex="-1"><a class="header-anchor" href="#_3-2-5-进程上下文"><span>3.2.5 进程上下文</span></a></h3><p>当程序在用户空间调用了系统调用。此时，内核 &quot;代表进程执行&quot; ，并处于进程上下文中。</p><h3 id="_3-2-6-进程家族树" tabindex="-1"><a class="header-anchor" href="#_3-2-6-进程家族树"><span>3.2.6 进程家族树</span></a></h3><p>Unix 和 Linux 系统的进程之间存在明显的继承关系，所有进程都是 init (PID == 1) 的后代。每个 <code>task_struct</code> 都包含一个指向父进程的 parent 指针，还包含一个称为 children 的子进程链表。访问父进程：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>my_parent <span class="token operator">=</span> current<span class="token operator">-&gt;</span>parent<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>依次访问子进程：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">list_head</span> <span class="token operator">*</span>list<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token function">list_for_each</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>current<span class="token operator">-&gt;</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    task <span class="token operator">=</span> <span class="token function">list_entry</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">,</span> sibling<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于进程列表的实现是双向链表，可以随时访问前一个或后一个进程。由 <code>next_task(task)</code> 和 <code>prev_task(task)</code> 两个宏实现：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token function">list_entry</span><span class="token punctuation">(</span>task<span class="token operator">-&gt;</span>tasks<span class="token punctuation">.</span>next<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">,</span> tasks<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token function">list_entry</span><span class="token punctuation">(</span>task<span class="token operator">-&gt;</span>tasks<span class="token punctuation">.</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">,</span> tasks<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>for_each_process(task)</code> 宏提供了依次访问整个任务队列的能力：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token function">for_each_process</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// task-&gt;...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>尽量不要重复遍历所有进程。代价很大。</p></blockquote><h2 id="_3-3-进程创建" tabindex="-1"><a class="header-anchor" href="#_3-3-进程创建"><span>3.3 进程创建</span></a></h2><p>其它 OS 中使用了 <strong>产生 (spawn)</strong> 机制来创建进程：</p><ul><li>在新的地址空间里创建进程</li><li>读入可执行文件</li><li>开始执行</li></ul><p>Unix 将上述步骤分解到 <code>fork()</code> 和 <code>exec()</code> 两个函数中</p><ul><li><code>fork()</code> 拷贝当前进程，创建一个子进程 <ul><li>区别为 PID (每个进程必须唯一)</li><li>PPID (父进程进程号)</li><li>资源和统计量</li></ul></li><li><code>exec()</code> 负责读取可执行文件，并载入地址空间开始运行</li></ul><h3 id="_3-3-1-写时拷贝" tabindex="-1"><a class="header-anchor" href="#_3-3-1-写时拷贝"><span>3.3.1 写时拷贝</span></a></h3><p>如果说 <code>fork()</code> 直接把所有资源复制给新创建的进程，而新进程打算立即执行一个新的映像，那么之前的所有拷贝就前功尽弃了。Linux 使用 <strong>copy-on-write</strong> 技术：</p><ul><li>推迟，甚至免除数据拷贝</li><li>内核不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝 (只读)</li><li>需要向地址空间写入数据时，数据才会被复制，从各进程拥有各自的拷贝</li></ul><p>Unix 强调进程快速执行的能力，一般情况下，进程创建后会马上运行一个可执行文件。这种优化可以避免拷贝大量根本就不会用的数据。</p><h3 id="_3-3-2-fork" tabindex="-1"><a class="header-anchor" href="#_3-3-2-fork"><span>3.3.2 fork()</span></a></h3><p>Linux 中通过 <code>clone()</code> 系统调用实现 <code>fork()</code>。<code>clone()</code> 中调用 <code>do_fork()</code>，<code>do_fork()</code> 调用 <code>copy_process()</code> 函数，然后让进程开始运行：</p><ol><li>调用 <code>dup_task_struct()</code>，为新进程创建内核栈、<code>thread_info</code>、<code>task_struct</code> (纯复制)</li><li>检查，确保进程数目没有超出分配资源的限制</li><li>子进程着手使自己与父进程区分 - 对 PCB 进行清零或初始化</li><li>设置子进程状态为 <code>TASK_UNINTERRUPTIBLE</code> 以保证不会被调度执行</li><li>调用 <code>copy_flags()</code> 更新 PCB 中的 flags</li><li>调用 <code>alloc_pid()</code> 为新进程分配 PID</li><li>拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间等</li><li>扫尾，返回指向子进程的指针</li></ol><p>如果 <code>copy_process()</code> 函数成功返回，该子进程就会被唤醒。内核会有意选择子进程首先执行，因为一般子进程都会立刻调用 <code>exec()</code> 函数，避免 copy-on-write 的额外开销；如果父进程首先执行，有可能会开始向地址空间写入。</p><h3 id="_3-3-3-vfork" tabindex="-1"><a class="header-anchor" href="#_3-3-3-vfork"><span>3.3.3 vfork()</span></a></h3><p>除了不拷贝父进程的页表项外，<code>vfork()</code> 与 <code>fork()</code> 的功能相同</p><ul><li>子进程作为父进程的一个单独的线程，在其地址空间里运行</li><li>父进程被阻塞，直到子进程退出或执行 <code>exec()</code> 😧 ?</li><li>子进程不能向地址空间写入</li></ul><blockquote><p>似乎不推荐使用？</p></blockquote><h2 id="_3-4-线程在-linux-中的实现" tabindex="-1"><a class="header-anchor" href="#_3-4-线程在-linux-中的实现"><span>3.4 线程在 Linux 中的实现</span></a></h2><p>在同一程序内共享内存地址空间，还可以共享打开的文件和其它资源。Linux 内核中没有线程这个概念，把所有线程都当做进程来实现。每个线程都有唯一隶属于自己的 PCB，只是线程和其它一些进程共享某些资源（比如地址空间）。对于 Linux 来说，线程只是进程间共享资源的手段。</p><h3 id="_3-4-1-创建线程" tabindex="-1"><a class="header-anchor" href="#_3-4-1-创建线程"><span>3.4.1 创建线程</span></a></h3><p>与创建进程类似，只不过在调用 <code>clone()</code> 时需要传递一些参数标志，指明需要共享的资源。创建线程：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token function">clone</span><span class="token punctuation">(</span>CLONE_VM <span class="token operator">|</span> CLONE_FS <span class="token operator">|</span> CLONE_FILES <span class="token operator">|</span> CLONE_SIGHAND<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>创建进程 (<code>fork()</code>)：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token function">clone</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>vfork()</code>：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token function">clone</span><span class="token punctuation">(</span>CLONE_VFORK <span class="token operator">|</span> CLONE_VM <span class="token operator">|</span> SIGCHLD<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>传递给 <code>clone()</code> 的参数标志决定了新创建进程的行为，和父子进程之间共享的资源种类。</p><h3 id="_3-4-2-内核线程" tabindex="-1"><a class="header-anchor" href="#_3-4-2-内核线程"><span>3.4.2 内核线程</span></a></h3><p>独立运行在内核空间的标准进程没有独立的地址空间（因为只在内核空间运行）。可以被调度，可以被抢占，只能由其它内核线程创建。传递一个函数指针和参数给新进程，并唤醒它即可。</p><h2 id="_3-5-进程终结" tabindex="-1"><a class="header-anchor" href="#_3-5-进程终结"><span>3.5 进程终结</span></a></h2><p>一个进程终结时，内核必须释放它所占有的资源，并通知父进程。进程终结由 <code>do_exit()</code> 完成：</p><ol><li>设置 PCB 中的 <code>PF_EXITING</code></li><li>调用 <code>del_timer_sync()</code> 删除任一内核定时器，确保没有定时器在排队</li><li>记账？？</li><li>调用 <code>exit_mm()</code> 释放进程占用的 <code>mm_struct</code>；如果没有别的进程共享，就彻底释放</li><li>调用 <code>sem__exit()</code> 函数</li><li>调用 <code>exit_files()</code> 和 <code>exit_fs()</code>，递减文件描述符、文件系统数据的引用计数；如果引用降为 0，则释放</li><li>将 PCB 中的 <code>exit_code</code> 设为 <code>exit()</code> 提供的退出代码，供父进程检索</li><li>调用 <code>exit_notify()</code> 向父进程发送信号，给子进程找养父，设置进程状态为 <code>EXIT_ZOMBIE</code></li><li>调用调度函数，切换到新进程</li></ol><p><code>do_exit()</code> 不会再被调度，因此永远不返回。此时，进程占用的资源都被释放，进程仅占用的内存就是内核栈、<code>thread_info</code> 和 <code>task_struct</code>。进程还存在的目的就是向父进程提供退出信息，父进程检索到信息后，子进程的剩余资源被释放，归还系统使用。</p><h3 id="_3-5-1-删除进程描述符" tabindex="-1"><a class="header-anchor" href="#_3-5-1-删除进程描述符"><span>3.5.1 删除进程描述符</span></a></h3><p>调用 <code>do_exit()</code>，进程处于僵死状态，但系统还是保留其 PID，使系统依然有办法在进程终结后获取其信息。清理工作和删除进程描述符的工作是分开执行的，父进程获得已终结的子进程的信息后，子进程的 PCB 才被释放。<code>wait()</code> 族的函数都是由 <code>wait4()</code> 系统调用实现的：</p><ul><li>挂起调用它的进程</li><li>直到其中的一个子进程退出</li><li>函数返回子进程的 PID</li><li>调用该函数提供的指针中，包含子进程退出时的退出码</li></ul><p>调用 <code>release_task()</code> 释放 PID：</p><ol><li>调用 <code>__exit_signal()</code> 从任务列表中删除该进程</li><li>释放僵死进程所使用的所有剩余资源，进行最终的统计和记录</li><li>如果是线程组的最后一个线程，且领头进程已经死掉，则通知僵死领头进程的父进程</li><li>回访进程内核栈和 <code>thread_info</code> 所占用的页，释放 <code>task_struct</code> 占用的 slab 高速缓存</li></ol><h3 id="_3-5-2-孤儿进程造成的进退维谷" tabindex="-1"><a class="header-anchor" href="#_3-5-2-孤儿进程造成的进退维谷"><span>3.5.2 孤儿进程造成的进退维谷</span></a></h3><p>若父进程在子进程之前退出，必须有机制保证子进程能找到一个新的父亲，不然成为孤儿的进程在退出时将永远处于僵死状态。</p><ul><li>首先试图找到进程所在线程组内的其它进程</li><li>若没有，则利用 init 进程</li></ul><p>遍历所有子进程，并为它们设置父进程。</p><h2 id="summary" tabindex="-1"><a class="header-anchor" href="#summary"><span>Summary</span></a></h2><p>进程和线程乱窜一通，不知道是原著就是这样写的，还是翻译的问题。反正在 Linux 里面只有任务（进程）这一个概念，只是通过 PCB 中一些字段的共享程度体现进程和线程的一些差别。这样做似乎也挺好的，很简洁 🤙</p>`,83)]))}const d=n(c,[["render",i],["__file","Chapter 3 - 进程管理.html.vue"]]),r=JSON.parse('{"path":"/linux-kernel-development-notes/Chapter%203%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html","title":"Chapter 3 - 进程管理","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"3.1 进程","slug":"_3-1-进程","link":"#_3-1-进程","children":[]},{"level":2,"title":"3.2 进程描述符及任务结构","slug":"_3-2-进程描述符及任务结构","link":"#_3-2-进程描述符及任务结构","children":[{"level":3,"title":"3.2.1 分配进程描述符","slug":"_3-2-1-分配进程描述符","link":"#_3-2-1-分配进程描述符","children":[]},{"level":3,"title":"3.2.2 进程描述符的存放","slug":"_3-2-2-进程描述符的存放","link":"#_3-2-2-进程描述符的存放","children":[]},{"level":3,"title":"3.2.3 进程状态","slug":"_3-2-3-进程状态","link":"#_3-2-3-进程状态","children":[]},{"level":3,"title":"3.2.4 设置当前进程状态","slug":"_3-2-4-设置当前进程状态","link":"#_3-2-4-设置当前进程状态","children":[]},{"level":3,"title":"3.2.5 进程上下文","slug":"_3-2-5-进程上下文","link":"#_3-2-5-进程上下文","children":[]},{"level":3,"title":"3.2.6 进程家族树","slug":"_3-2-6-进程家族树","link":"#_3-2-6-进程家族树","children":[]}]},{"level":2,"title":"3.3 进程创建","slug":"_3-3-进程创建","link":"#_3-3-进程创建","children":[{"level":3,"title":"3.3.1 写时拷贝","slug":"_3-3-1-写时拷贝","link":"#_3-3-1-写时拷贝","children":[]},{"level":3,"title":"3.3.2 fork()","slug":"_3-3-2-fork","link":"#_3-3-2-fork","children":[]},{"level":3,"title":"3.3.3 vfork()","slug":"_3-3-3-vfork","link":"#_3-3-3-vfork","children":[]}]},{"level":2,"title":"3.4 线程在 Linux 中的实现","slug":"_3-4-线程在-linux-中的实现","link":"#_3-4-线程在-linux-中的实现","children":[{"level":3,"title":"3.4.1 创建线程","slug":"_3-4-1-创建线程","link":"#_3-4-1-创建线程","children":[]},{"level":3,"title":"3.4.2 内核线程","slug":"_3-4-2-内核线程","link":"#_3-4-2-内核线程","children":[]}]},{"level":2,"title":"3.5 进程终结","slug":"_3-5-进程终结","link":"#_3-5-进程终结","children":[{"level":3,"title":"3.5.1 删除进程描述符","slug":"_3-5-1-删除进程描述符","link":"#_3-5-1-删除进程描述符","children":[]},{"level":3,"title":"3.5.2 孤儿进程造成的进退维谷","slug":"_3-5-2-孤儿进程造成的进退维谷","link":"#_3-5-2-孤儿进程造成的进退维谷","children":[]}]},{"level":2,"title":"Summary","slug":"summary","link":"#summary","children":[]}],"git":{},"filePathRelative":"linux-kernel-development-notes/Chapter 3 - 进程管理.md"}');export{d as comp,r as data};
