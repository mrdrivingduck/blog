import{_ as s,c as a,a as e,o as p}from"./app-7eKjwDat.js";const t={};function l(i,n){return p(),a("div",null,n[0]||(n[0]=[e(`<h1 id="postgresql-read-stream" tabindex="-1"><a class="header-anchor" href="#postgresql-read-stream"><span>PostgreSQL - Read Stream</span></a></h1><p>Created by: Mr Dk.</p><p>2025 / 06 / 29 16:20</p><p>Hangzhou, Zhejiang, China</p><hr><h2 id="背景" tabindex="-1"><a class="header-anchor" href="#背景"><span>背景</span></a></h2><p>一直以来，PostgreSQL 的 I/O 模型都是 Buffered I/O，依赖更底层的操作系统/文件系统实现页面缓存和 I/O 合并。这样 PostgreSQL 自身并不需要做太复杂的 I/O 管理，同时也在一定程度上收获了可移植性，但这并不是性能上的极致。</p><p>事实上，最希望能够绕过 OS 来自行管理 I/O 的软件就是包括 DBMS 在内的各类数据处理系统。为了提升性能，这类系统通常都有自己的内存缓存，比如 DBMS 的 Buffer Pool。OS 如果也缓存了相同页面，那么实际上是一种浪费；系统处于高吞吐状态时，在 OS 的页面缓存和 DBMS 的页面缓存之间的互相拷贝也会浪费不少 CPU。另外有一句很著名的结论叫作：DBMS <strong>always</strong> knows more than the OS，对于某个页面的缓存应该保留在内存中还是被逐出，OS 的判断并不一定是准确的，DBMS 永远拥有更多的信息。</p><p>PostgreSQL 的 I/O 模型自 PostgreSQL 16 开始逐渐向 Direct I/O + Asynchronous I/O 模型过渡。引入 Direct I/O 是为了彻底绕开操作系统，由数据库自身完全管理 I/O；引入 Asynchronous I/O 则是为了补齐并超越原先由 OS 实现的页面预读和 I/O 合并，达成更高的 I/O Concurrency，以获得更好的性能。这对于运行在高带宽、高延时的云存储上的 PostgreSQL 来说意义重大。I/O 模型的过渡并不是在一个版本内完成的：</p><ul><li>PostgreSQL 16 引入了可选的 Direct I/O 参数，但只作为开发者选项</li><li>PostgreSQL 17 引入了 Read Stream，作为 Asynchronous I/O 的更高层接口，兼容现存的 Buffered I/O 模型</li><li>PostgreSQL 18 引入了 Asynchronous I/O 基础设施，但并未正式开始使用</li></ul><p>本文编写时 PostgreSQL 18 即将发布 BETA 2。通过分析 PostgreSQL 17 中引入的 Read Stream，窥探 PostgreSQL 的 I/O 模型改造之路。</p><h2 id="read-stream" tabindex="-1"><a class="header-anchor" href="#read-stream"><span>Read Stream</span></a></h2><p>Read Stream 是一层抽象接口。使用这层接口的代码需要告诉 Read Stream 接下来将会依次访问的页面编号，然后就可以从 Read Stream 中依次拖出已经在 Buffer Pool 中被 pin 住的所需页面。Read Stream 根据调用方提供的页面编号序列，在内部完成 I/O 合并和页面预读，对调用方屏蔽相关细节。</p><p>需要访问的页面编号序列由调用方提供一个回调函数产生，这个函数每被回调一次就返回下一个要访问的页面编号。比如，对于 sequential scan 来说，这个回调函数就应该依次返回从 0 开始的所有页面编号。</p><p>Read Stream 的使用模式类似于：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line">ReadStream <span class="token operator">*</span>stream <span class="token operator">=</span> <span class="token function">read_stream_begin_relation</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> next_block_cb<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>buffer <span class="token operator">=</span> <span class="token function">read_stream_next_buffer</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> InvalidBuffer<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">/* deal with buffer */</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token function">read_stream_end</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，Read Stream 要解决的核心问题是：已知一个确定的页面编号序列，如何以最高效的方式管理这些页面的 I/O？针对不同的 I/O pattern，Read Stream 定义了三种场景：</p><ol><li>Behavior A：需要访问的页面已在 Buffer Pool 中，那么无需任何 I/O，pin 住页面立刻返回</li><li>Behavior B：需要访问的页面是连续的，那么可以进行 I/O 合并，选择一个最佳的粒度用一次 I/O 将多个页面装入 Buffer Pool 并 pin 住返回，这样上层代码可以一次处理多个页面而无需离开 CPU</li><li>Behavior C：需要访问的页面是随机离散的，无法合并 I/O，但由于后续要访问的页面编号已知，可以提前让后台进程将这些页面异步地装入 Buffer Pool 中并 pin 住；在未来真正要访问这些页面时，期望这些页面已经在 Buffer Pool 中了，这样上层代码也可以立刻开始处理页面，不再需要等待 I/O 完成</li></ol><p>基于这些场景，我们可以归纳出需要被 Read Stream 实现的重点：</p><ol><li>额外的状态信息需要被记录：被 pin 住的 Buffer、被提前发起的 I/O 请求</li><li>处理某个页面编号的 I/O 请求时，需要展望未来，分析后续访问的页面编号，不仅要吃碗里的还要看锅里的</li><li>对连续的页面读取请求，可以进行 I/O 合并；合并粒度不能过大，否则可能冲击其他的并发进程，需要有一个最大值</li><li>对离散的页面读取请求，可以同时发起多个 I/O 请求；并发的 I/O 请求数量不能过多，否则同样可能冲击其他并发进程，需要有一个最大的 I/O 并发限度</li></ol><h3 id="前置条件-buffer-manager-的改造" tabindex="-1"><a class="header-anchor" href="#前置条件-buffer-manager-的改造"><span>前置条件：Buffer Manager 的改造</span></a></h3><p>I/O 异步化的精髓就是当前进程发起 I/O 请求，委托后台进程代为处理 I/O；当前进程可以先做别的事，稍晚些时候再回来检查 I/O 结果即可。为了过渡到能够委托后台进程来处理 I/O 的 Asynchronous I/O 模式，访问一个 Buffer 的过程被拆分为 <code>StartReadBuffers</code> 和 <code>WaitReadBuffers</code> 两步：</p><ul><li><code>StartReadBuffers</code>：向后台进程发起一个 I/O 请求，立刻返回</li><li><code>WaitReadBuffers</code>：阻塞等待 I/O 请求完成才返回</li></ul><p>这两个步骤中间就是留给 I/O 请求被处理的时间。理论上，尽可能早地发起 I/O 请求，尽可能晚地确认 I/O 结果，中间的时间如果足够 I/O 请求处理完成，那么进程就不需要停滞等待 I/O。</p><p>由于 PostgreSQL 17 还在使用 Buffered I/O + Synchronous I/O 模式，因此 <code>StartReadBuffers</code> 里实际上不做任何 I/O 工作，仅通过 <code>fadvise</code> 建议 OS 的后台线程把页面提前装入页面缓存内；在 <code>WaitReadBuffers</code> 里真正进行 I/O 操作时，如果 OS 已经提前将页面装入页面缓存，那么 <code>WaitReadBuffers</code> 中的 I/O 操作就只有系统调用 + 内存拷贝的开销了。这也可以算是一种简易的 I/O 异步化。</p><p>如果使用 Direct I/O 模式，则需要通过数据库的 I/O 工作进程或特定操作系统的异步 I/O 接口 (比如 Linux 的 <a href="https://en.wikipedia.org/wiki/Io_uring" target="_blank" rel="noopener noreferrer">io_uring</a>) 代为处理 I/O 请求。这也是 PostgreSQL 后续版本中需要完善的能力。</p><h3 id="buffer-和-i-o-的状态管理" tabindex="-1"><a class="header-anchor" href="#buffer-和-i-o-的状态管理"><span>Buffer 和 I/O 的状态管理</span></a></h3><p>Read Stream 对象中管理了两个固定长度的环形队列。此处直接复用代码中的注释来进行说明：</p><ul><li>Buffer 队列 (左侧)：<code>oldest_buffer_index</code> 和 <code>next_buffer_index</code> 中间的部分记录了 Read Stream 已经 pin 住但还未被调用方消费的 Buffer</li><li>In-flight I/O 队列 (右侧)：<code>oldest_io_index</code> 和 <code>next_io_index</code> 中间的部分记录了 Read Stream 已经发起但还未确认完成的 I/O 请求</li></ul><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token comment">/*-------------------------------------------------------------------------</span>
<span class="line"> *</span>
<span class="line"> * ...</span>
<span class="line"> *</span>
<span class="line"> *                          buffers buf/data       ios</span>
<span class="line"> *</span>
<span class="line"> *                          +----+  +-----+       +--------+</span>
<span class="line"> *                          |    |  |     |  +----+ 42..44 | &lt;- oldest_io_index</span>
<span class="line"> *                          +----+  +-----+  |    +--------+</span>
<span class="line"> *   oldest_buffer_index -&gt; | 10 |  |  ?  |  | +--+ 60..60 |</span>
<span class="line"> *                          +----+  +-----+  | |  +--------+</span>
<span class="line"> *                          | 42 |  |  ?  |&lt;-+ |  |        | &lt;- next_io_index</span>
<span class="line"> *                          +----+  +-----+    |  +--------+</span>
<span class="line"> *                          | 43 |  |  ?  |    |  |        |</span>
<span class="line"> *                          +----+  +-----+    |  +--------+</span>
<span class="line"> *                          | 44 |  |  ?  |    |  |        |</span>
<span class="line"> *                          +----+  +-----+    |  +--------+</span>
<span class="line"> *                          | 60 |  |  ?  |&lt;---+</span>
<span class="line"> *                          +----+  +-----+</span>
<span class="line"> *     next_buffer_index -&gt; |    |  |     |</span>
<span class="line"> *                          +----+  +-----+</span>
<span class="line"> *</span>
<span class="line"> * ...</span>
<span class="line"> *</span>
<span class="line"> *-------------------------------------------------------------------------</span>
<span class="line"> */</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两个核心队列的长度，分别决定了 Read Stream 对象能一次性持有多少 Buffer，以及能同时发起多少个并发 I/O。它们都由 GUC 参数控制。队列的长度越长，意味着更加超前、贪婪的 I/O 管理，同时也意味着更多的 Buffer 和 I/O 处理能力的资源消耗。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token comment">/*</span>
<span class="line"> * State for managing a stream of reads.</span>
<span class="line"> */</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">ReadStream</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">/* ... */</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">/* Read operations that have been started but not waited for yet. */</span></span>
<span class="line">    InProgressIO <span class="token operator">*</span>ios<span class="token punctuation">;</span></span>
<span class="line">    int16       oldest_io_index<span class="token punctuation">;</span></span>
<span class="line">    int16       next_io_index<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">/* ... */</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">/* Circular queue of buffers. */</span></span>
<span class="line">    int16       oldest_buffer_index<span class="token punctuation">;</span>    <span class="token comment">/* Next pinned buffer to return */</span></span>
<span class="line">    int16       next_buffer_index<span class="token punctuation">;</span>  <span class="token comment">/* Index of next buffer to pin */</span></span>
<span class="line">    Buffer      buffers<span class="token punctuation">[</span>FLEXIBLE_ARRAY_MEMBER<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="处理-i-o-结果并返回-buffer" tabindex="-1"><a class="header-anchor" href="#处理-i-o-结果并返回-buffer"><span>处理 I/O 结果并返回 Buffer</span></a></h3><p>Read Stream 的核心逻辑由 <code>read_stream_next_buffer</code> 函数实现。让我们去除所有的非主要路径代码，看看这个函数的主要路径做了什么。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token comment">/*</span>
<span class="line"> * Pull one pinned buffer out of a stream.  Each call returns successive</span>
<span class="line"> * blocks in the order specified by the callback.  If per_buffer_data_size was</span>
<span class="line"> * set to a non-zero size, *per_buffer_data receives a pointer to the extra</span>
<span class="line"> * per-buffer data that the callback had a chance to populate, which remains</span>
<span class="line"> * valid until the next call to read_stream_next_buffer().  When the stream</span>
<span class="line"> * runs out of data, InvalidBuffer is returned.  The caller may decide to end</span>
<span class="line"> * the stream early at any time by calling read_stream_end().</span>
<span class="line"> */</span></span>
<span class="line">Buffer</span>
<span class="line"><span class="token function">read_stream_next_buffer</span><span class="token punctuation">(</span>ReadStream <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>per_buffer_data<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先，确认当前 Read Stream 中是否有已经完成 I/O 可以被立刻消费的 Buffer，如果有，则直接返回。这类 Buffer 可能来自于与前置页面合并 I/O 后被 pin 住的 Buffer。</p><ul><li>通过 <code>oldest_buffer_index</code> 从 Buffer 队列中得到下一个待消费 Buffer</li><li>通过 I/O 队列确认当前 Buffer 的 I/O 已经完成</li><li>更新 <code>oldest_buffer_index</code> 将 Buffer 移出 Buffer 队列</li><li>调用 <code>read_stream_look_ahead</code> 提前对后续页面发起读取请求，尽量填满 I/O 队列</li><li>返回 Buffer</li></ul><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line">Buffer</span>
<span class="line"><span class="token function">read_stream_next_buffer</span><span class="token punctuation">(</span>ReadStream <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>per_buffer_data<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">/* ... */</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">/* Grab the oldest pinned buffer and associated per-buffer data. */</span></span>
<span class="line">    <span class="token function">Assert</span><span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>pinned_buffers <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    oldest_buffer_index <span class="token operator">=</span> stream<span class="token operator">-&gt;</span>oldest_buffer_index<span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">Assert</span><span class="token punctuation">(</span>oldest_buffer_index <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span></span>
<span class="line">           oldest_buffer_index <span class="token operator">&lt;</span> stream<span class="token operator">-&gt;</span>queue_size<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    buffer <span class="token operator">=</span> stream<span class="token operator">-&gt;</span>buffers<span class="token punctuation">[</span>oldest_buffer_index<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>per_buffer_data<span class="token punctuation">)</span></span>
<span class="line">        <span class="token operator">*</span>per_buffer_data <span class="token operator">=</span> <span class="token function">get_per_buffer_data</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> oldest_buffer_index<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token function">Assert</span><span class="token punctuation">(</span><span class="token function">BufferIsValid</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">/* Do we have to wait for an associated I/O first? */</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>ios_in_progress <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span></span>
<span class="line">        stream<span class="token operator">-&gt;</span>ios<span class="token punctuation">[</span>stream<span class="token operator">-&gt;</span>oldest_io_index<span class="token punctuation">]</span><span class="token punctuation">.</span>buffer_index <span class="token operator">==</span> oldest_buffer_index<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">/* ... */</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">/* Pin transferred to caller. */</span></span>
<span class="line">    <span class="token function">Assert</span><span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>pinned_buffers <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    stream<span class="token operator">-&gt;</span>pinned_buffers<span class="token operator">--</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">/* Advance oldest buffer, with wrap-around. */</span></span>
<span class="line">    stream<span class="token operator">-&gt;</span>oldest_buffer_index<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>oldest_buffer_index <span class="token operator">==</span> stream<span class="token operator">-&gt;</span>queue_size<span class="token punctuation">)</span></span>
<span class="line">        stream<span class="token operator">-&gt;</span>oldest_buffer_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">/* Prepare for the next call. */</span></span>
<span class="line">    <span class="token function">read_stream_look_ahead</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">return</span> buffer<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果 I/O 队列显示这个 Buffer 的 I/O 请求暂未被确认，则需要调用 <code>WaitReadBuffers</code> 一直等待到 I/O 请求完成，然后将 I/O 请求从 I/O 队列中移出。在返回 Buffer 前，决定后续 I/O 请求的大小。通常来说，以之前 I/O 预读窗口大小的两倍快速扩大预读窗口，以便尽量发起更多的 I/O 请求，但不超过 Buffer 队列的长度；如果探测到顺序访问页面的 pattern，则保持 I/O 请求不超过 I/O 合并的最大粒度。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line">Buffer</span>
<span class="line"><span class="token function">read_stream_next_buffer</span><span class="token punctuation">(</span>ReadStream <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>per_buffer_data<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">/* ... */</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">/* Do we have to wait for an associated I/O first? */</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>ios_in_progress <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span></span>
<span class="line">        stream<span class="token operator">-&gt;</span>ios<span class="token punctuation">[</span>stream<span class="token operator">-&gt;</span>oldest_io_index<span class="token punctuation">]</span><span class="token punctuation">.</span>buffer_index <span class="token operator">==</span> oldest_buffer_index<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        int16       io_index <span class="token operator">=</span> stream<span class="token operator">-&gt;</span>oldest_io_index<span class="token punctuation">;</span></span>
<span class="line">        int16       distance<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">/* Sanity check that we still agree on the buffers. */</span></span>
<span class="line">        <span class="token function">Assert</span><span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>ios<span class="token punctuation">[</span>io_index<span class="token punctuation">]</span><span class="token punctuation">.</span>op<span class="token punctuation">.</span>buffers <span class="token operator">==</span></span>
<span class="line">               <span class="token operator">&amp;</span>stream<span class="token operator">-&gt;</span>buffers<span class="token punctuation">[</span>oldest_buffer_index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token function">WaitReadBuffers</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stream<span class="token operator">-&gt;</span>ios<span class="token punctuation">[</span>io_index<span class="token punctuation">]</span><span class="token punctuation">.</span>op<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token function">Assert</span><span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>ios_in_progress <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        stream<span class="token operator">-&gt;</span>ios_in_progress<span class="token operator">--</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>stream<span class="token operator">-&gt;</span>oldest_io_index <span class="token operator">==</span> stream<span class="token operator">-&gt;</span>max_ios<span class="token punctuation">)</span></span>
<span class="line">            stream<span class="token operator">-&gt;</span>oldest_io_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>ios<span class="token punctuation">[</span>io_index<span class="token punctuation">]</span><span class="token punctuation">.</span>op<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> READ_BUFFERS_ISSUE_ADVICE<span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">{</span></span>
<span class="line">            <span class="token comment">/* Distance ramps up fast (behavior C). */</span></span>
<span class="line">            distance <span class="token operator">=</span> stream<span class="token operator">-&gt;</span>distance <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line">            distance <span class="token operator">=</span> <span class="token function">Min</span><span class="token punctuation">(</span>distance<span class="token punctuation">,</span> stream<span class="token operator">-&gt;</span>max_pinned_buffers<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            stream<span class="token operator">-&gt;</span>distance <span class="token operator">=</span> distance<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">else</span></span>
<span class="line">        <span class="token punctuation">{</span></span>
<span class="line">            <span class="token comment">/* No advice; move towards io_combine_limit (behavior B). */</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>distance <span class="token operator">&gt;</span> stream<span class="token operator">-&gt;</span>io_combine_limit<span class="token punctuation">)</span></span>
<span class="line">            <span class="token punctuation">{</span></span>
<span class="line">                stream<span class="token operator">-&gt;</span>distance<span class="token operator">--</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">            <span class="token keyword">else</span></span>
<span class="line">            <span class="token punctuation">{</span></span>
<span class="line">                distance <span class="token operator">=</span> stream<span class="token operator">-&gt;</span>distance <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line">                distance <span class="token operator">=</span> <span class="token function">Min</span><span class="token punctuation">(</span>distance<span class="token punctuation">,</span> stream<span class="token operator">-&gt;</span>io_combine_limit<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                distance <span class="token operator">=</span> <span class="token function">Min</span><span class="token punctuation">(</span>distance<span class="token punctuation">,</span> stream<span class="token operator">-&gt;</span>max_pinned_buffers<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                stream<span class="token operator">-&gt;</span>distance <span class="token operator">=</span> distance<span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">/* ... */</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，用一个单独的 <code>if</code> 分支处理读到 Read Stream 结尾的场景，即 Read Stream 对象已经不持有任何 Buffer。向调用方返回 <code>InvalidBuffer</code> 表示结束：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line">Buffer</span>
<span class="line"><span class="token function">read_stream_next_buffer</span><span class="token punctuation">(</span>ReadStream <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>per_buffer_data<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">/* ... */</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>pinned_buffers <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">Assert</span><span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>oldest_buffer_index <span class="token operator">==</span> stream<span class="token operator">-&gt;</span>next_buffer_index<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">/* End of stream reached?  */</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>distance <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line">            <span class="token keyword">return</span> InvalidBuffer<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">/*</span>
<span class="line">         * The usual order of operations is that we look ahead at the bottom</span>
<span class="line">         * of this function after potentially finishing an I/O and making</span>
<span class="line">         * space for more, but if we&#39;re just starting up we&#39;ll need to crank</span>
<span class="line">         * the handle to get started.</span>
<span class="line">         */</span></span>
<span class="line">        <span class="token function">read_stream_look_ahead</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">/* End of stream reached? */</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>pinned_buffers <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">{</span></span>
<span class="line">            <span class="token function">Assert</span><span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>distance <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">return</span> InvalidBuffer<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">/* ... */</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="i-o-合并" tabindex="-1"><a class="header-anchor" href="#i-o-合并"><span>I/O 合并</span></a></h3><p>上面的函数可以认为是在消费 I/O 请求的结果。每消费掉一个 Buffer，都需要尽快发起新的 I/O 请求，或合并相邻页面的 I/O 请求，在资源限制的范围内尽可能填满 I/O 队列。这个过程在 <code>read_stream_look_ahead</code> 中实现。</p><p>在 I/O 队列未满时，不断获取下一个要访问的页面编号：</p><ul><li>如果目前积攒的 I/O 请求大小已经达到 I/O 合并的最大粒度，那么立刻发起 I/O 请求</li><li>如果目前积攒的 I/O 请求大小尚未达到 I/O 合并的最大粒度，那么通过 <code>read_stream_get_block</code> 确认下一个页面与当前读请求是否相邻 <ul><li>如果相邻，那么 I/O 可以合并，记录合并后继续查看下一个页面</li><li>如果不相邻，则 I/O 无法合并，那么立刻发起已积攒的 I/O 请求，然后将下一个页面作为后续积攒 I/O 请求的第一个页面</li></ul></li></ul><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span></span>
<span class="line"><span class="token function">read_stream_look_ahead</span><span class="token punctuation">(</span>ReadStream <span class="token operator">*</span>stream<span class="token punctuation">,</span> bool suppress_advice<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">while</span> <span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>ios_in_progress <span class="token operator">&lt;</span> stream<span class="token operator">-&gt;</span>max_ios <span class="token operator">&amp;&amp;</span></span>
<span class="line">           stream<span class="token operator">-&gt;</span>pinned_buffers <span class="token operator">+</span> stream<span class="token operator">-&gt;</span>pending_read_nblocks <span class="token operator">&lt;</span> stream<span class="token operator">-&gt;</span>distance<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        BlockNumber blocknum<span class="token punctuation">;</span></span>
<span class="line">        int16       buffer_index<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">void</span>       <span class="token operator">*</span>per_buffer_data<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>pending_read_nblocks <span class="token operator">==</span> stream<span class="token operator">-&gt;</span>io_combine_limit<span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">{</span></span>
<span class="line">            <span class="token function">read_stream_start_pending_read</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> suppress_advice<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            suppress_advice <span class="token operator">=</span> false<span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">continue</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">/*</span>
<span class="line">         * See which block the callback wants next in the stream.  We need to</span>
<span class="line">         * compute the index of the Nth block of the pending read including</span>
<span class="line">         * wrap-around, but we don&#39;t want to use the expensive % operator.</span>
<span class="line">         */</span></span>
<span class="line">        buffer_index <span class="token operator">=</span> stream<span class="token operator">-&gt;</span>next_buffer_index <span class="token operator">+</span> stream<span class="token operator">-&gt;</span>pending_read_nblocks<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>buffer_index <span class="token operator">&gt;=</span> stream<span class="token operator">-&gt;</span>queue_size<span class="token punctuation">)</span></span>
<span class="line">            buffer_index <span class="token operator">-=</span> stream<span class="token operator">-&gt;</span>queue_size<span class="token punctuation">;</span></span>
<span class="line">        <span class="token function">Assert</span><span class="token punctuation">(</span>buffer_index <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> buffer_index <span class="token operator">&lt;</span> stream<span class="token operator">-&gt;</span>queue_size<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        per_buffer_data <span class="token operator">=</span> <span class="token function">get_per_buffer_data</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> buffer_index<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        blocknum <span class="token operator">=</span> <span class="token function">read_stream_get_block</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> per_buffer_data<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>blocknum <span class="token operator">==</span> InvalidBlockNumber<span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">{</span></span>
<span class="line">            <span class="token comment">/* End of stream. */</span></span>
<span class="line">            stream<span class="token operator">-&gt;</span>distance <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">break</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">/* Can we merge it with the pending read? */</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>pending_read_nblocks <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span></span>
<span class="line">            stream<span class="token operator">-&gt;</span>pending_read_blocknum <span class="token operator">+</span> stream<span class="token operator">-&gt;</span>pending_read_nblocks <span class="token operator">==</span> blocknum<span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">{</span></span>
<span class="line">            stream<span class="token operator">-&gt;</span>pending_read_nblocks<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">continue</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">/* We have to start the pending read before we can build another. */</span></span>
<span class="line">        <span class="token keyword">while</span> <span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>pending_read_nblocks <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">{</span></span>
<span class="line">            <span class="token function">read_stream_start_pending_read</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> suppress_advice<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            suppress_advice <span class="token operator">=</span> false<span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>ios_in_progress <span class="token operator">==</span> stream<span class="token operator">-&gt;</span>max_ios<span class="token punctuation">)</span></span>
<span class="line">            <span class="token punctuation">{</span></span>
<span class="line">                <span class="token comment">/* And we&#39;ve hit the limit.  Rewind, and stop here. */</span></span>
<span class="line">                <span class="token function">read_stream_unget_block</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> blocknum<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">/* This is the start of a new pending read. */</span></span>
<span class="line">        stream<span class="token operator">-&gt;</span>pending_read_blocknum <span class="token operator">=</span> blocknum<span class="token punctuation">;</span></span>
<span class="line">        stream<span class="token operator">-&gt;</span>pending_read_nblocks <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">/* ... */</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果已经没有更多页面需要访问了，那么立刻发出已积攒的读请求：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span></span>
<span class="line"><span class="token function">read_stream_look_ahead</span><span class="token punctuation">(</span>ReadStream <span class="token operator">*</span>stream<span class="token punctuation">,</span> bool suppress_advice<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">while</span> <span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>ios_in_progress <span class="token operator">&lt;</span> stream<span class="token operator">-&gt;</span>max_ios <span class="token operator">&amp;&amp;</span></span>
<span class="line">           stream<span class="token operator">-&gt;</span>pinned_buffers <span class="token operator">+</span> stream<span class="token operator">-&gt;</span>pending_read_nblocks <span class="token operator">&lt;</span> stream<span class="token operator">-&gt;</span>distance<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">/* ... */</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">/*</span>
<span class="line">     * We don&#39;t start the pending read just because we&#39;ve hit the distance</span>
<span class="line">     * limit, preferring to give it another chance to grow to full</span>
<span class="line">     * io_combine_limit size once more buffers have been consumed.  However,</span>
<span class="line">     * if we&#39;ve already reached io_combine_limit, or we&#39;ve reached the</span>
<span class="line">     * distance limit and there isn&#39;t anything pinned yet, or the callback has</span>
<span class="line">     * signaled end-of-stream, we start the read immediately.</span>
<span class="line">     */</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>pending_read_nblocks <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span></span>
<span class="line">        <span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>pending_read_nblocks <span class="token operator">==</span> stream<span class="token operator">-&gt;</span>io_combine_limit <span class="token operator">||</span></span>
<span class="line">         <span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>pending_read_nblocks <span class="token operator">==</span> stream<span class="token operator">-&gt;</span>distance <span class="token operator">&amp;&amp;</span></span>
<span class="line">          stream<span class="token operator">-&gt;</span>pinned_buffers <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span></span>
<span class="line">         stream<span class="token operator">-&gt;</span>distance <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></span>
<span class="line">        stream<span class="token operator">-&gt;</span>ios_in_progress <span class="token operator">&lt;</span> stream<span class="token operator">-&gt;</span>max_ios<span class="token punctuation">)</span></span>
<span class="line">        <span class="token function">read_stream_start_pending_read</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> suppress_advice<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="获取页面编号序列" tabindex="-1"><a class="header-anchor" href="#获取页面编号序列"><span>获取页面编号序列</span></a></h3><p>上述函数中，需要不断迭代下一个将要访问的页面编号，这是通过 <code>read_stream_get_block</code> 函数完成的。该函数中回调了调用方提供的 callback，得到下一个要访问的页面编号：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token comment">/*</span>
<span class="line"> * Ask the callback which block it would like us to read next, with a one block</span>
<span class="line"> * buffer in front to allow read_stream_unget_block() to work.</span>
<span class="line"> */</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">inline</span> BlockNumber</span>
<span class="line"><span class="token function">read_stream_get_block</span><span class="token punctuation">(</span>ReadStream <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>per_buffer_data<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    BlockNumber blocknum<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    blocknum <span class="token operator">=</span> stream<span class="token operator">-&gt;</span>buffered_blocknum<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>blocknum <span class="token operator">!=</span> InvalidBlockNumber<span class="token punctuation">)</span></span>
<span class="line">        stream<span class="token operator">-&gt;</span>buffered_blocknum <span class="token operator">=</span> InvalidBlockNumber<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">else</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">/*</span>
<span class="line">         * Tell Valgrind that the per-buffer data is undefined.  That replaces</span>
<span class="line">         * the &quot;noaccess&quot; state that was set when the consumer moved past this</span>
<span class="line">         * entry last time around the queue, and should also catch callbacks</span>
<span class="line">         * that fail to initialize data that the buffer consumer later</span>
<span class="line">         * accesses.  On the first go around, it is undefined already.</span>
<span class="line">         */</span></span>
<span class="line">        <span class="token function">VALGRIND_MAKE_MEM_UNDEFINED</span><span class="token punctuation">(</span>per_buffer_data<span class="token punctuation">,</span></span>
<span class="line">                                    stream<span class="token operator">-&gt;</span>per_buffer_data_size<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        blocknum <span class="token operator">=</span> stream<span class="token operator">-&gt;</span><span class="token function">callback</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span></span>
<span class="line">                                    stream<span class="token operator">-&gt;</span>callback_private_data<span class="token punctuation">,</span></span>
<span class="line">                                    per_buffer_data<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">return</span> blocknum<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>回调函数的实现方式因调用方而异。对于 sequential scan 来说，回调函数需要依次返回文件的每一个页面编号：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token comment">/*</span>
<span class="line"> * Streaming read API callback for serial sequential and TID range scans.</span>
<span class="line"> * Returns the next block the caller wants from the read stream or</span>
<span class="line"> * InvalidBlockNumber when done.</span>
<span class="line"> */</span></span>
<span class="line"><span class="token keyword">static</span> BlockNumber</span>
<span class="line"><span class="token function">heap_scan_stream_read_next_serial</span><span class="token punctuation">(</span>ReadStream <span class="token operator">*</span>stream<span class="token punctuation">,</span></span>
<span class="line">                                  <span class="token keyword">void</span> <span class="token operator">*</span>callback_private_data<span class="token punctuation">,</span></span>
<span class="line">                                  <span class="token keyword">void</span> <span class="token operator">*</span>per_buffer_data<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    HeapScanDesc scan <span class="token operator">=</span> <span class="token punctuation">(</span>HeapScanDesc<span class="token punctuation">)</span> callback_private_data<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>scan<span class="token operator">-&gt;</span>rs_inited<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        scan<span class="token operator">-&gt;</span>rs_prefetch_block <span class="token operator">=</span> <span class="token function">heapgettup_initial_block</span><span class="token punctuation">(</span>scan<span class="token punctuation">,</span> scan<span class="token operator">-&gt;</span>rs_dir<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        scan<span class="token operator">-&gt;</span>rs_inited <span class="token operator">=</span> true<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">else</span></span>
<span class="line">        scan<span class="token operator">-&gt;</span>rs_prefetch_block <span class="token operator">=</span> <span class="token function">heapgettup_advance_block</span><span class="token punctuation">(</span>scan<span class="token punctuation">,</span></span>
<span class="line">                                                           scan<span class="token operator">-&gt;</span>rs_prefetch_block<span class="token punctuation">,</span></span>
<span class="line">                                                           scan<span class="token operator">-&gt;</span>rs_dir<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">return</span> scan<span class="token operator">-&gt;</span>rs_prefetch_block<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 <a href="https://www.postgresql.org/docs/current/sql-analyze.html" target="_blank" rel="noopener noreferrer">ANALYZE</a> 来说，则是返回下一个被采样收集统计信息的页面编号：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token comment">/*</span>
<span class="line"> * Read stream callback returning the next BlockNumber as chosen by the</span>
<span class="line"> * BlockSampling algorithm.</span>
<span class="line"> */</span></span>
<span class="line"><span class="token keyword">static</span> BlockNumber</span>
<span class="line"><span class="token function">block_sampling_read_stream_next</span><span class="token punctuation">(</span>ReadStream <span class="token operator">*</span>stream<span class="token punctuation">,</span></span>
<span class="line">                                <span class="token keyword">void</span> <span class="token operator">*</span>callback_private_data<span class="token punctuation">,</span></span>
<span class="line">                                <span class="token keyword">void</span> <span class="token operator">*</span>per_buffer_data<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    BlockSamplerData <span class="token operator">*</span>bs <span class="token operator">=</span> callback_private_data<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">return</span> <span class="token function">BlockSampler_HasMore</span><span class="token punctuation">(</span>bs<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">BlockSampler_Next</span><span class="token punctuation">(</span>bs<span class="token punctuation">)</span> <span class="token operator">:</span> InvalidBlockNumber<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="发起-i-o-请求" tabindex="-1"><a class="header-anchor" href="#发起-i-o-请求"><span>发起 I/O 请求</span></a></h3><p>在分析完后续要访问的页面编号后，Read Stream 组装出了每个 I/O 请求的位置和大小。接下来需要将这些 I/O 请求发送出去，并将这些请求的信息记录到 I/O 队列中，以便后续消费 I/O 结果。这个过程在函数 <code>read_stream_start_pending_read</code> 中完成：</p><ul><li>调用 <code>StartReadBuffers</code> 发起 I/O 请求 (PostgreSQL 17 中暂时使用 <a href="https://man7.org/linux/man-pages/man1/fadvise.1.html" target="_blank" rel="noopener noreferrer"><code>fadvise</code></a>)</li><li>将本次 I/O 需要 pin 住的 Buffer 记录到 Buffer 队列中</li><li>如果 Buffer 命中 Buffer Pool，则控制好预读窗口，先把碗里的吃完</li><li>如果 Buffer 未命中，则将 I/O 请求记录到 I/O 队列中</li></ul><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span></span>
<span class="line"><span class="token function">read_stream_start_pending_read</span><span class="token punctuation">(</span>ReadStream <span class="token operator">*</span>stream<span class="token punctuation">,</span> bool suppress_advice<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">/* ... */</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">/*</span>
<span class="line">     * If advice hasn&#39;t been suppressed, this system supports it, and this</span>
<span class="line">     * isn&#39;t a strictly sequential pattern, then we&#39;ll issue advice.</span>
<span class="line">     */</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>suppress_advice <span class="token operator">&amp;&amp;</span></span>
<span class="line">        stream<span class="token operator">-&gt;</span>advice_enabled <span class="token operator">&amp;&amp;</span></span>
<span class="line">        stream<span class="token operator">-&gt;</span>pending_read_blocknum <span class="token operator">!=</span> stream<span class="token operator">-&gt;</span>seq_blocknum<span class="token punctuation">)</span></span>
<span class="line">        flags <span class="token operator">=</span> READ_BUFFERS_ISSUE_ADVICE<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">else</span></span>
<span class="line">        flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">/* We say how many blocks we want to read, but may be smaller on return. */</span></span>
<span class="line">    buffer_index <span class="token operator">=</span> stream<span class="token operator">-&gt;</span>next_buffer_index<span class="token punctuation">;</span></span>
<span class="line">    io_index <span class="token operator">=</span> stream<span class="token operator">-&gt;</span>next_io_index<span class="token punctuation">;</span></span>
<span class="line">    nblocks <span class="token operator">=</span> stream<span class="token operator">-&gt;</span>pending_read_nblocks<span class="token punctuation">;</span></span>
<span class="line">    need_wait <span class="token operator">=</span> <span class="token function">StartReadBuffers</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stream<span class="token operator">-&gt;</span>ios<span class="token punctuation">[</span>io_index<span class="token punctuation">]</span><span class="token punctuation">.</span>op<span class="token punctuation">,</span></span>
<span class="line">                                 <span class="token operator">&amp;</span>stream<span class="token operator">-&gt;</span>buffers<span class="token punctuation">[</span>buffer_index<span class="token punctuation">]</span><span class="token punctuation">,</span></span>
<span class="line">                                 stream<span class="token operator">-&gt;</span>pending_read_blocknum<span class="token punctuation">,</span></span>
<span class="line">                                 <span class="token operator">&amp;</span>nblocks<span class="token punctuation">,</span></span>
<span class="line">                                 flags<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    stream<span class="token operator">-&gt;</span>pinned_buffers <span class="token operator">+=</span> nblocks<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">/* Remember whether we need to wait before returning this buffer. */</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>need_wait<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">/* Look-ahead distance decays, no I/O necessary (behavior A). */</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>distance <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span></span>
<span class="line">            stream<span class="token operator">-&gt;</span>distance<span class="token operator">--</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">else</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">/*</span>
<span class="line">         * Remember to call WaitReadBuffers() before returning head buffer.</span>
<span class="line">         * Look-ahead distance will be adjusted after waiting.</span>
<span class="line">         */</span></span>
<span class="line">        stream<span class="token operator">-&gt;</span>ios<span class="token punctuation">[</span>io_index<span class="token punctuation">]</span><span class="token punctuation">.</span>buffer_index <span class="token operator">=</span> buffer_index<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>stream<span class="token operator">-&gt;</span>next_io_index <span class="token operator">==</span> stream<span class="token operator">-&gt;</span>max_ios<span class="token punctuation">)</span></span>
<span class="line">            stream<span class="token operator">-&gt;</span>next_io_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token function">Assert</span><span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>ios_in_progress <span class="token operator">&lt;</span> stream<span class="token operator">-&gt;</span>max_ios<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        stream<span class="token operator">-&gt;</span>ios_in_progress<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line">        stream<span class="token operator">-&gt;</span>seq_blocknum <span class="token operator">=</span> stream<span class="token operator">-&gt;</span>pending_read_blocknum <span class="token operator">+</span> nblocks<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">/* ... */</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">/* Compute location of start of next read, without using % operator. */</span></span>
<span class="line">    buffer_index <span class="token operator">+=</span> nblocks<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>buffer_index <span class="token operator">&gt;=</span> stream<span class="token operator">-&gt;</span>queue_size<span class="token punctuation">)</span></span>
<span class="line">        buffer_index <span class="token operator">-=</span> stream<span class="token operator">-&gt;</span>queue_size<span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">Assert</span><span class="token punctuation">(</span>buffer_index <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> buffer_index <span class="token operator">&lt;</span> stream<span class="token operator">-&gt;</span>queue_size<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    stream<span class="token operator">-&gt;</span>next_buffer_index <span class="token operator">=</span> buffer_index<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">/* Adjust the pending read to cover the remaining portion, if any. */</span></span>
<span class="line">    stream<span class="token operator">-&gt;</span>pending_read_blocknum <span class="token operator">+=</span> nblocks<span class="token punctuation">;</span></span>
<span class="line">    stream<span class="token operator">-&gt;</span>pending_read_nblocks <span class="token operator">-=</span> nblocks<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p><a href="https://www.youtube.com/watch?v=8d6YrSByNew" target="_blank" rel="noopener noreferrer">Thomas Munro, Nazir Bilal Yavuz - Streaming I/O and vectored I/O (PGConf.EU 2024)</a></p><p><a href="https://www.youtube.com/watch?v=qX50xrHwQa4" target="_blank" rel="noopener noreferrer">Andres Freund: The path to using AIO in postgres (PGConf.EU 2023)</a></p>`,63)]))}const o=s(t,[["render",l],["__file","PostgreSQL Read Stream.html.vue"]]),r=JSON.parse('{"path":"/notes/PostgreSQL/PostgreSQL%20Read%20Stream.html","title":"PostgreSQL - Read Stream","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"背景","slug":"背景","link":"#背景","children":[]},{"level":2,"title":"Read Stream","slug":"read-stream","link":"#read-stream","children":[{"level":3,"title":"前置条件：Buffer Manager 的改造","slug":"前置条件-buffer-manager-的改造","link":"#前置条件-buffer-manager-的改造","children":[]},{"level":3,"title":"Buffer 和 I/O 的状态管理","slug":"buffer-和-i-o-的状态管理","link":"#buffer-和-i-o-的状态管理","children":[]},{"level":3,"title":"处理 I/O 结果并返回 Buffer","slug":"处理-i-o-结果并返回-buffer","link":"#处理-i-o-结果并返回-buffer","children":[]},{"level":3,"title":"I/O 合并","slug":"i-o-合并","link":"#i-o-合并","children":[]},{"level":3,"title":"获取页面编号序列","slug":"获取页面编号序列","link":"#获取页面编号序列","children":[]},{"level":3,"title":"发起 I/O 请求","slug":"发起-i-o-请求","link":"#发起-i-o-请求","children":[]}]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{},"filePathRelative":"notes/PostgreSQL/PostgreSQL Read Stream.md"}');export{o as comp,r as data};
