import{_ as n,c as a,a as p,o as t}from"./app-BeHGwf2X.js";const e={};function o(c,s){return t(),a("div",null,s[0]||(s[0]=[p(`<h1 id="chapter-6-4-基本算法" tabindex="-1"><a class="header-anchor" href="#chapter-6-4-基本算法"><span>Chapter 6.4 - 基本算法</span></a></h1><p>Created by : Mr Dk.</p><p>2021 / 04 / 11 15:00</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="equal" tabindex="-1"><a class="header-anchor" href="#equal"><span>equal</span></a></h2><p>比较两个区间内的对应元素是否相等。如果第二个序列的元素比较多，则多出来的元素不考虑 (看源码就知道为啥了)：因此如果想比较两个序列是否完全相等，需要先比较序列长度是否相等，或者直接使用容器提供的 <code>operator==</code>。</p><p>算法默认使用 <code>operator==</code> 对元素进行大小比较，用户也可以自行指定二元仿函数。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_InputIter1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_InputIter2</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">bool</span> <span class="token function">equal</span><span class="token punctuation">(</span>_InputIter1 __first1<span class="token punctuation">,</span> _InputIter1 __last1<span class="token punctuation">,</span></span>
<span class="line">                  _InputIter2 __first2<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_InputIter1<span class="token punctuation">,</span> _InputIterator<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_InputIter2<span class="token punctuation">,</span> _InputIterator<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>_InputIter1<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_type<span class="token punctuation">,</span></span>
<span class="line">                 _EqualityComparable<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>_InputIter2<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_type<span class="token punctuation">,</span></span>
<span class="line">                 _EqualityComparable<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> __first1 <span class="token operator">!=</span> __last1<span class="token punctuation">;</span> <span class="token operator">++</span>__first1<span class="token punctuation">,</span> <span class="token operator">++</span>__first2<span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>__first1 <span class="token operator">!=</span> <span class="token operator">*</span>__first2<span class="token punctuation">)</span>  <span class="token comment">// 使用 == 运算符</span></span>
<span class="line">      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">// 如果发现不相等，立刻返回</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">// 第一序列内的所有元素都和第二序列对应相等</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_InputIter1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_InputIter2</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_BinaryPredicate</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">bool</span> <span class="token function">equal</span><span class="token punctuation">(</span>_InputIter1 __first1<span class="token punctuation">,</span> _InputIter1 __last1<span class="token punctuation">,</span></span>
<span class="line">                  _InputIter2 __first2<span class="token punctuation">,</span> _BinaryPredicate __binary_pred<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_InputIter1<span class="token punctuation">,</span> _InputIterator<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_InputIter2<span class="token punctuation">,</span> _InputIterator<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> __first1 <span class="token operator">!=</span> __last1<span class="token punctuation">;</span> <span class="token operator">++</span>__first1<span class="token punctuation">,</span> <span class="token operator">++</span>__first2<span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">__binary_pred</span><span class="token punctuation">(</span><span class="token operator">*</span>__first1<span class="token punctuation">,</span> <span class="token operator">*</span>__first2<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// 使用二元仿函数</span></span>
<span class="line">      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="fill" tabindex="-1"><a class="header-anchor" href="#fill"><span>fill</span></a></h2><p>将指定区间内的所有元素设置为新值。该函数只对元素进行赋值，不对元素进行构造，因此操作区间不能超过容器的实际大小。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_ForwardIter</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_Tp</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">fill</span><span class="token punctuation">(</span>_ForwardIter __first<span class="token punctuation">,</span> _ForwardIter __last<span class="token punctuation">,</span> <span class="token keyword">const</span> _Tp<span class="token operator">&amp;</span> __value<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_ForwardIter<span class="token punctuation">,</span> _Mutable_ForwardIterator<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> __first <span class="token operator">!=</span> __last<span class="token punctuation">;</span> <span class="token operator">++</span>__first<span class="token punctuation">)</span></span>
<span class="line">    <span class="token operator">*</span>__first <span class="token operator">=</span> __value<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于单字节的类型，直接使用 <code>memset()</code>。以下是部分具体化的版本：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">fill</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> __first<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> __last<span class="token punctuation">,</span></span>
<span class="line">                 <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> __c<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">unsigned</span> <span class="token keyword">char</span> __tmp <span class="token operator">=</span> __c<span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">memset</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> __tmp<span class="token punctuation">,</span> __last <span class="token operator">-</span> __first<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">fill</span><span class="token punctuation">(</span><span class="token keyword">signed</span> <span class="token keyword">char</span><span class="token operator">*</span> __first<span class="token punctuation">,</span> <span class="token keyword">signed</span> <span class="token keyword">char</span><span class="token operator">*</span> __last<span class="token punctuation">,</span></span>
<span class="line">                 <span class="token keyword">const</span> <span class="token keyword">signed</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> __c<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">signed</span> <span class="token keyword">char</span> __tmp <span class="token operator">=</span> __c<span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">memset</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>__tmp<span class="token punctuation">)</span><span class="token punctuation">,</span> __last <span class="token operator">-</span> __first<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">fill</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> __first<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> __last<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> __c<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">char</span> __tmp <span class="token operator">=</span> __c<span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">memset</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>__tmp<span class="token punctuation">)</span><span class="token punctuation">,</span> __last <span class="token operator">-</span> __first<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将从某个位置开始的前 n 个元素设置为新值：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_OutputIter</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_Size</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_Tp</span><span class="token operator">&gt;</span></span>
<span class="line">_OutputIter <span class="token function">fill_n</span><span class="token punctuation">(</span>_OutputIter __first<span class="token punctuation">,</span> _Size __n<span class="token punctuation">,</span> <span class="token keyword">const</span> _Tp<span class="token operator">&amp;</span> __value<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_OutputIter<span class="token punctuation">,</span> _OutputIterator<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> __n <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>__n<span class="token punctuation">,</span> <span class="token operator">++</span>__first<span class="token punctuation">)</span>  <span class="token comment">// 循环条件里多了 n</span></span>
<span class="line">    <span class="token operator">*</span>__first <span class="token operator">=</span> __value<span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">return</span> __first<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果想要获得的是插入行为而不是赋值，那么可以使用具有插入能力的迭代器适配器：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> iv<span class="token punctuation">;</span></span>
<span class="line"><span class="token function">fill_n</span><span class="token punctuation">(</span><span class="token function">inserter</span><span class="token punctuation">(</span>iv<span class="token punctuation">,</span> iv<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 在 iv.begin() 前插入 5 个 7</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="iter-swap" tabindex="-1"><a class="header-anchor" href="#iter-swap"><span>iter_swap</span></a></h2><p>将两个迭代器所指向的对象进行交换。由于交换操作需要使用到一个临时变量，如果不知道这个临时变量的数据类型，代码应该怎么写呢？如何声明这个临时变量呢？这里使用到了迭代器的数据类型萃取功能，提取出了迭代器的 value type：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_ForwardIter1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_ForwardIter2</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_Tp</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__iter_swap</span><span class="token punctuation">(</span>_ForwardIter1 __a<span class="token punctuation">,</span> _ForwardIter2 __b<span class="token punctuation">,</span> _Tp<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// _Tp 为迭代器所指对象类型</span></span>
<span class="line">  _Tp __tmp <span class="token operator">=</span> <span class="token operator">*</span>__a<span class="token punctuation">;</span></span>
<span class="line">  <span class="token operator">*</span>__a <span class="token operator">=</span> <span class="token operator">*</span>__b<span class="token punctuation">;</span></span>
<span class="line">  <span class="token operator">*</span>__b <span class="token operator">=</span> __tmp<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_ForwardIter1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_ForwardIter2</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">iter_swap</span><span class="token punctuation">(</span>_ForwardIter1 __a<span class="token punctuation">,</span> _ForwardIter2 __b<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_ForwardIter1<span class="token punctuation">,</span> _Mutable_ForwardIterator<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_ForwardIter2<span class="token punctuation">,</span> _Mutable_ForwardIterator<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">__STL_CONVERTIBLE</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>_ForwardIter1<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_type<span class="token punctuation">,</span></span>
<span class="line">                    <span class="token keyword">typename</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>_ForwardIter2<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_type<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">__STL_CONVERTIBLE</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>_ForwardIter2<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_type<span class="token punctuation">,</span></span>
<span class="line">                    <span class="token keyword">typename</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>_ForwardIter1<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_type<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">__iter_swap</span><span class="token punctuation">(</span>__a<span class="token punctuation">,</span> __b<span class="token punctuation">,</span> <span class="token function">__VALUE_TYPE</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 萃取迭代器所指对象类型</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="lexicographical-compare" tabindex="-1"><a class="header-anchor" href="#lexicographical-compare"><span>lexicographical_compare</span></a></h2><p>按 <strong>字典序</strong> 对两个序列进行比较，直到两个序列的某组对应元素不相等，或者到达结尾。默认使用 <code>operator&lt;</code> 进行比较，也支持用户提供二元仿函数。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token comment">//--------------------------------------------------</span></span>
<span class="line"><span class="token comment">// lexicographical_compare and lexicographical_compare_3way.</span></span>
<span class="line"><span class="token comment">// (the latter is not part of the C++ standard.)</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_InputIter1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_InputIter2</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">bool</span> <span class="token function">lexicographical_compare</span><span class="token punctuation">(</span>_InputIter1 __first1<span class="token punctuation">,</span> _InputIter1 __last1<span class="token punctuation">,</span></span>
<span class="line">                             _InputIter2 __first2<span class="token punctuation">,</span> _InputIter2 __last2<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_InputIter1<span class="token punctuation">,</span> _InputIterator<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_InputIter2<span class="token punctuation">,</span> _InputIterator<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>_InputIter1<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_type<span class="token punctuation">,</span></span>
<span class="line">                 _LessThanComparable<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>_InputIter2<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_type<span class="token punctuation">,</span></span>
<span class="line">                 _LessThanComparable<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> __first1 <span class="token operator">!=</span> __last1 <span class="token operator">&amp;&amp;</span> __first2 <span class="token operator">!=</span> __last2</span>
<span class="line">        <span class="token punctuation">;</span> <span class="token operator">++</span>__first1<span class="token punctuation">,</span> <span class="token operator">++</span>__first2<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>__first1 <span class="token operator">&lt;</span> <span class="token operator">*</span>__first2<span class="token punctuation">)</span>  <span class="token comment">// 不相等，直接返回</span></span>
<span class="line">      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>__first2 <span class="token operator">&lt;</span> <span class="token operator">*</span>__first1<span class="token punctuation">)</span>  <span class="token comment">// 不相等，直接返回</span></span>
<span class="line">      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token comment">// 之前的元素全部对应相等</span></span>
<span class="line">  <span class="token comment">// 第一个序列到结尾，第二个序列还没有到结尾，则 1 &lt; 2</span></span>
<span class="line">  <span class="token keyword">return</span> __first1 <span class="token operator">==</span> __last1 <span class="token operator">&amp;&amp;</span> __first2 <span class="token operator">!=</span> __last2<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_InputIter1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_InputIter2</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_Compare</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">bool</span> <span class="token function">lexicographical_compare</span><span class="token punctuation">(</span>_InputIter1 __first1<span class="token punctuation">,</span> _InputIter1 __last1<span class="token punctuation">,</span></span>
<span class="line">                             _InputIter2 __first2<span class="token punctuation">,</span> _InputIter2 __last2<span class="token punctuation">,</span></span>
<span class="line">                             _Compare __comp<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_InputIter1<span class="token punctuation">,</span> _InputIterator<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_InputIter2<span class="token punctuation">,</span> _InputIterator<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> __first1 <span class="token operator">!=</span> __last1 <span class="token operator">&amp;&amp;</span> __first2 <span class="token operator">!=</span> __last2</span>
<span class="line">        <span class="token punctuation">;</span> <span class="token operator">++</span>__first1<span class="token punctuation">,</span> <span class="token operator">++</span>__first2<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__comp</span><span class="token punctuation">(</span><span class="token operator">*</span>__first1<span class="token punctuation">,</span> <span class="token operator">*</span>__first2<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// 二元仿函数比较</span></span>
<span class="line">      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__comp</span><span class="token punctuation">(</span><span class="token operator">*</span>__first2<span class="token punctuation">,</span> <span class="token operator">*</span>__first1<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// 二元仿函数比较</span></span>
<span class="line">      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token keyword">return</span> __first1 <span class="token operator">==</span> __last1 <span class="token operator">&amp;&amp;</span> __first2 <span class="token operator">!=</span> __last2<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>部分具体化：对于单字节的字符串，使用 <code>memcmp()</code> 进行比较。如果已经比较完毕的部分大小不相上下，那么长度更长的字符串更大。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">inline</span> <span class="token keyword">bool</span></span>
<span class="line"><span class="token function">lexicographical_compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> __first1<span class="token punctuation">,</span></span>
<span class="line">                        <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> __last1<span class="token punctuation">,</span></span>
<span class="line">                        <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> __first2<span class="token punctuation">,</span></span>
<span class="line">                        <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> __last2<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> size_t __len1 <span class="token operator">=</span> __last1 <span class="token operator">-</span> __first1<span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">const</span> size_t __len2 <span class="token operator">=</span> __last2 <span class="token operator">-</span> __first2<span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">const</span> <span class="token keyword">int</span> __result <span class="token operator">=</span> <span class="token function">memcmp</span><span class="token punctuation">(</span>__first1<span class="token punctuation">,</span> __first2<span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>__len1<span class="token punctuation">,</span> __len2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 比较长度相同的部分</span></span>
<span class="line">  <span class="token keyword">return</span> __result <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">?</span> __result <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">:</span> __len1 <span class="token operator">&lt;</span> __len2<span class="token punctuation">;</span>  <span class="token comment">// 结果为 0，则比较长度</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">bool</span> <span class="token function">lexicographical_compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> __first1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> __last1<span class="token punctuation">,</span></span>
<span class="line">                                    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> __first2<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> __last2<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token function">lexicographical_compare</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">signed</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> __first1<span class="token punctuation">,</span></span>
<span class="line">                                 <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">signed</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> __last1<span class="token punctuation">,</span></span>
<span class="line">                                 <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">signed</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> __first2<span class="token punctuation">,</span></span>
<span class="line">                                 <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">signed</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> __last2<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="max-min" tabindex="-1"><a class="header-anchor" href="#max-min"><span>max / min</span></a></h2><p>默认使用 <code>operator&lt;</code> 来获得两个对象中的最大 / 最小值，用户可以提供二元仿函数。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token comment">//--------------------------------------------------</span></span>
<span class="line"><span class="token comment">// min and max</span></span>
<span class="line"></span>
<span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token operator">!</span><span class="token function">defined</span><span class="token punctuation">(</span>__BORLANDC__<span class="token punctuation">)</span> <span class="token operator">||</span> __BORLANDC__ <span class="token operator">&gt;=</span> <span class="token number">0x540</span> </span><span class="token comment">/* C++ Builder 4.0 */</span></span></span>
<span class="line"></span>
<span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">min</span></span></span>
<span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">max</span></span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Tp</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">const</span> _Tp<span class="token operator">&amp;</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Tp<span class="token operator">&amp;</span> __a<span class="token punctuation">,</span> <span class="token keyword">const</span> _Tp<span class="token operator">&amp;</span> __b<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_Tp<span class="token punctuation">,</span> _LessThanComparable<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">return</span> __b <span class="token operator">&lt;</span> __a <span class="token operator">?</span> __b <span class="token operator">:</span> __a<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Tp</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">const</span> _Tp<span class="token operator">&amp;</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Tp<span class="token operator">&amp;</span> __a<span class="token punctuation">,</span> <span class="token keyword">const</span> _Tp<span class="token operator">&amp;</span> __b<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_Tp<span class="token punctuation">,</span> _LessThanComparable<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">return</span>  __a <span class="token operator">&lt;</span> __b <span class="token operator">?</span> __b <span class="token operator">:</span> __a<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* __BORLANDC__ */</span></span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Tp</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_Compare</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">const</span> _Tp<span class="token operator">&amp;</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Tp<span class="token operator">&amp;</span> __a<span class="token punctuation">,</span> <span class="token keyword">const</span> _Tp<span class="token operator">&amp;</span> __b<span class="token punctuation">,</span> _Compare __comp<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token function">__comp</span><span class="token punctuation">(</span>__b<span class="token punctuation">,</span> __a<span class="token punctuation">)</span> <span class="token operator">?</span> __b <span class="token operator">:</span> __a<span class="token punctuation">;</span>  <span class="token comment">// 二元仿函数</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Tp</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_Compare</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">const</span> _Tp<span class="token operator">&amp;</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Tp<span class="token operator">&amp;</span> __a<span class="token punctuation">,</span> <span class="token keyword">const</span> _Tp<span class="token operator">&amp;</span> __b<span class="token punctuation">,</span> _Compare __comp<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token function">__comp</span><span class="token punctuation">(</span>__a<span class="token punctuation">,</span> __b<span class="token punctuation">)</span> <span class="token operator">?</span> __b <span class="token operator">:</span> __a<span class="token punctuation">;</span>  <span class="token comment">// 二元仿函数</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="mismatch" tabindex="-1"><a class="header-anchor" href="#mismatch"><span>mismatch</span></a></h2><p>平行比较两个序列，并返回两个序列之间的第一个不匹配点 (迭代器)。如果第二个序列的元素个数更多，那么多出来的元素忽略不计。缺省情况使用 <code>operator==</code> 来比较元素，用户可以自行提供二元仿函数。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token comment">//--------------------------------------------------</span></span>
<span class="line"><span class="token comment">// equal and mismatch</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_InputIter1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_InputIter2</span><span class="token operator">&gt;</span></span>
<span class="line">pair<span class="token operator">&lt;</span>_InputIter1<span class="token punctuation">,</span> _InputIter2<span class="token operator">&gt;</span> <span class="token function">mismatch</span><span class="token punctuation">(</span>_InputIter1 __first1<span class="token punctuation">,</span></span>
<span class="line">                                        _InputIter1 __last1<span class="token punctuation">,</span></span>
<span class="line">                                        _InputIter2 __first2<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_InputIter1<span class="token punctuation">,</span> _InputIterator<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_InputIter2<span class="token punctuation">,</span> _InputIterator<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>_InputIter1<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_type<span class="token punctuation">,</span></span>
<span class="line">                 _EqualityComparable<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>_InputIter2<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_type<span class="token punctuation">,</span></span>
<span class="line">                 _EqualityComparable<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">while</span> <span class="token punctuation">(</span>__first1 <span class="token operator">!=</span> __last1 <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>__first1 <span class="token operator">==</span> <span class="token operator">*</span>__first2<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 第一序列没到尾，使用 operator== 比较</span></span>
<span class="line">    <span class="token operator">++</span>__first1<span class="token punctuation">;</span></span>
<span class="line">    <span class="token operator">++</span>__first2<span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>_InputIter1<span class="token punctuation">,</span> _InputIter2<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>__first1<span class="token punctuation">,</span> __first2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回失配位置的迭代器</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_InputIter1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_InputIter2</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_BinaryPredicate</span><span class="token operator">&gt;</span></span>
<span class="line">pair<span class="token operator">&lt;</span>_InputIter1<span class="token punctuation">,</span> _InputIter2<span class="token operator">&gt;</span> <span class="token function">mismatch</span><span class="token punctuation">(</span>_InputIter1 __first1<span class="token punctuation">,</span></span>
<span class="line">                                        _InputIter1 __last1<span class="token punctuation">,</span></span>
<span class="line">                                        _InputIter2 __first2<span class="token punctuation">,</span></span>
<span class="line">                                        _BinaryPredicate __binary_pred<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_InputIter1<span class="token punctuation">,</span> _InputIterator<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_InputIter2<span class="token punctuation">,</span> _InputIterator<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">while</span> <span class="token punctuation">(</span>__first1 <span class="token operator">!=</span> __last1 <span class="token operator">&amp;&amp;</span> <span class="token function">__binary_pred</span><span class="token punctuation">(</span><span class="token operator">*</span>__first1<span class="token punctuation">,</span> <span class="token operator">*</span>__first2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 第一序列没到尾，使用二元仿函数比较</span></span>
<span class="line">    <span class="token operator">++</span>__first1<span class="token punctuation">;</span></span>
<span class="line">    <span class="token operator">++</span>__first2<span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>_InputIter1<span class="token punctuation">,</span> _InputIter2<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>__first1<span class="token punctuation">,</span> __first2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回失配位置的迭代器</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="swap" tabindex="-1"><a class="header-anchor" href="#swap"><span>swap</span></a></h2><p>对换两个对象中的内容 (使用 <code>operator=</code>)：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Tp</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>_Tp<span class="token operator">&amp;</span> __a<span class="token punctuation">,</span> _Tp<span class="token operator">&amp;</span> __b<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_Tp<span class="token punctuation">,</span> _Assignable<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  _Tp __tmp <span class="token operator">=</span> __a<span class="token punctuation">;</span></span>
<span class="line">  __a <span class="token operator">=</span> __b<span class="token punctuation">;</span></span>
<span class="line">  __b <span class="token operator">=</span> __tmp<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="copy" tabindex="-1"><a class="header-anchor" href="#copy"><span>copy</span></a></h2><p>在区间之间复制。由于复制基本上使用的是 <code>operator=</code> 或拷贝构造函数，对于拥有简单拷贝构造函数的对象来说，直接使用底层的内存复制能够节省大量的时间。SGI STL 中使用的是 <code>memmove()</code>：它会将整个区间复制下来，然后搬运。</p><p><code>copy()</code> 将 <code>[first, last)</code> 区间内的元素复制到 <code>result</code> 开始的区间内。<code>first</code> 和 <code>result</code> 可以在同一个容器中，但是 <code>result</code> 如果处于 <code>first</code> 和 <code>last</code> 之间将会出现问题：因为 <code>result</code> 中的原有数据也是复制区间的一部分，而它将会被 <code>first</code> 的元素覆盖。换句话说，如果复制区间存在重叠，<code>copy()</code> <strong>仅支持向前复制</strong> (<code>result</code> 位置位于 <code>first</code> 之间)。</p><blockquote><p>但是对于使用了 <code>memmove()</code> 的类型来说，不存在上述问题。</p></blockquote><p><code>copy()</code> 对性能上的优化分为两个层次：</p><ul><li>针对参数给定的迭代器类型，可以使用不同的操作算法</li><li>针对被复制元素的数据类型，选择是否使用高效的内存移动算法</li></ul><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token comment">//--------------------------------------------------</span></span>
<span class="line"><span class="token comment">// copy</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// All of these auxiliary functions serve two purposes.  (1) Replace</span></span>
<span class="line"><span class="token comment">// calls to copy with memmove whenever possible.  (Memmove, not memcpy,</span></span>
<span class="line"><span class="token comment">// because the input and output ranges are permitted to overlap.)</span></span>
<span class="line"><span class="token comment">// (2) If we&#39;re using random access iterators, then write the loop as</span></span>
<span class="line"><span class="token comment">// a for loop with an explicit count.</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最泛化的版本：接收两个 Input Iterator (被复制区间) 和一个 Output Iterator (目标区间起始位置) 进行复制。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_InputIter</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_OutputIter</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> _OutputIter <span class="token function">copy</span><span class="token punctuation">(</span>_InputIter __first<span class="token punctuation">,</span> _InputIter __last<span class="token punctuation">,</span></span>
<span class="line">                        _OutputIter __result<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token function">__copy</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> __last<span class="token punctuation">,</span> __result<span class="token punctuation">,</span></span>
<span class="line">                <span class="token function">__ITERATOR_CATEGORY</span><span class="token punctuation">(</span>__first<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// 萃取迭代器的类型</span></span>
<span class="line">                <span class="token function">__DISTANCE_TYPE</span><span class="token punctuation">(</span>__first<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 Input Iterator，使用迭代器的 <code>operator==</code> 和 <code>operator++</code> 能够实现遍历；而对于 Ramdom Access Iterator 来说，可以直接计算两个迭代器的距离，并基于首尾迭代器的距离进行计算，效率更高：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_InputIter</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_OutputIter</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_Distance</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> _OutputIter <span class="token function">__copy</span><span class="token punctuation">(</span>_InputIter __first<span class="token punctuation">,</span> _InputIter __last<span class="token punctuation">,</span></span>
<span class="line">                          _OutputIter __result<span class="token punctuation">,</span></span>
<span class="line">                          input_iterator_tag<span class="token punctuation">,</span> _Distance<span class="token operator">*</span><span class="token punctuation">)</span>  <span class="token comment">// input iterator</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> __first <span class="token operator">!=</span> __last<span class="token punctuation">;</span> <span class="token operator">++</span>__result<span class="token punctuation">,</span> <span class="token operator">++</span>__first<span class="token punctuation">)</span></span>
<span class="line">    <span class="token operator">*</span>__result <span class="token operator">=</span> <span class="token operator">*</span>__first<span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">return</span> __result<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_RandomAccessIter</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_OutputIter</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_Distance</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> _OutputIter</span>
<span class="line"><span class="token function">__copy</span><span class="token punctuation">(</span>_RandomAccessIter __first<span class="token punctuation">,</span> _RandomAccessIter __last<span class="token punctuation">,</span></span>
<span class="line">       _OutputIter __result<span class="token punctuation">,</span> random_access_iterator_tag<span class="token punctuation">,</span> _Distance<span class="token operator">*</span><span class="token punctuation">)</span>  <span class="token comment">// random access iterator</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">for</span> <span class="token punctuation">(</span>_Distance __n <span class="token operator">=</span> __last <span class="token operator">-</span> __first<span class="token punctuation">;</span> __n <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>__n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 计算首尾迭代器之间的距离</span></span>
<span class="line">    <span class="token operator">*</span>__result <span class="token operator">=</span> <span class="token operator">*</span>__first<span class="token punctuation">;</span></span>
<span class="line">    <span class="token operator">++</span>__first<span class="token punctuation">;</span></span>
<span class="line">    <span class="token operator">++</span>__result<span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token keyword">return</span> __result<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而对于原生数据类型，SGI STL 认为它们具有简单的拷贝构造函数，因此直接可以使用 <code>memmove</code>：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__SGI_STL_DECLARE_COPY_TRIVIAL</span><span class="token expression"><span class="token punctuation">(</span>_Tp<span class="token punctuation">)</span>                                </span><span class="token punctuation">\\</span></span>
<span class="line">  <span class="token expression"><span class="token keyword">inline</span> _Tp<span class="token operator">*</span> <span class="token function">copy</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Tp<span class="token operator">*</span> __first<span class="token punctuation">,</span> <span class="token keyword">const</span> _Tp<span class="token operator">*</span> __last<span class="token punctuation">,</span> _Tp<span class="token operator">*</span> __result<span class="token punctuation">)</span> <span class="token punctuation">{</span> </span><span class="token punctuation">\\</span></span>
<span class="line">    <span class="token expression"><span class="token function">memmove</span><span class="token punctuation">(</span>__result<span class="token punctuation">,</span> __first<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>_Tp<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>__last <span class="token operator">-</span> __first<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          </span><span class="token punctuation">\\</span></span>
<span class="line">    <span class="token expression"><span class="token keyword">return</span> __result <span class="token operator">+</span> <span class="token punctuation">(</span>__last <span class="token operator">-</span> __first<span class="token punctuation">)</span><span class="token punctuation">;</span>                                  </span><span class="token punctuation">\\</span></span>
<span class="line">  <span class="token expression"><span class="token punctuation">}</span></span></span></span>
<span class="line"></span>
<span class="line"><span class="token function">__SGI_STL_DECLARE_COPY_TRIVIAL</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">__SGI_STL_DECLARE_COPY_TRIVIAL</span><span class="token punctuation">(</span><span class="token keyword">signed</span> <span class="token keyword">char</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">__SGI_STL_DECLARE_COPY_TRIVIAL</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">__SGI_STL_DECLARE_COPY_TRIVIAL</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">__SGI_STL_DECLARE_COPY_TRIVIAL</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">__SGI_STL_DECLARE_COPY_TRIVIAL</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">__SGI_STL_DECLARE_COPY_TRIVIAL</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">__SGI_STL_DECLARE_COPY_TRIVIAL</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">__SGI_STL_DECLARE_COPY_TRIVIAL</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__STL_HAS_WCHAR_T</span></span></span>
<span class="line"><span class="token function">__SGI_STL_DECLARE_COPY_TRIVIAL</span><span class="token punctuation">(</span><span class="token keyword">wchar_t</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></span>
<span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_STL_LONG_LONG</span></span></span>
<span class="line"><span class="token function">__SGI_STL_DECLARE_COPY_TRIVIAL</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">__SGI_STL_DECLARE_COPY_TRIVIAL</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></span>
<span class="line"><span class="token function">__SGI_STL_DECLARE_COPY_TRIVIAL</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">__SGI_STL_DECLARE_COPY_TRIVIAL</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">__SGI_STL_DECLARE_COPY_TRIVIAL</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">double</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">__SGI_STL_DECLARE_COPY_TRIVIAL</span></span></span>
<span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上并没有使用数据类型萃取机制，不知道是不是和编译器类型有关。有些编译器无法识别用户自定义的类型是否具有简单的拷贝构造函数。对于那些有能力识别自定义类型是否有简单拷贝构造函数的编译器而言，实现方式就有所不同了：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_InputIter</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_OutputIter</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> _OutputIter <span class="token function">copy</span><span class="token punctuation">(</span>_InputIter __first<span class="token punctuation">,</span> _InputIter __last<span class="token punctuation">,</span></span>
<span class="line">                        _OutputIter __result<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_InputIter<span class="token punctuation">,</span> _InputIterator<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">__STL_REQUIRES</span><span class="token punctuation">(</span>_OutputIter<span class="token punctuation">,</span> _OutputIterator<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>_InputIter<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_type _Tp<span class="token punctuation">;</span>  <span class="token comment">// 迭代器指向的数据类型</span></span>
<span class="line">  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">__type_traits</span><span class="token operator">&lt;</span>_Tp<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>has_trivial_assignment_operator</span>
<span class="line">          _Trivial<span class="token punctuation">;</span>  <span class="token comment">// 萃取数据类型是否有简单的拷贝构造函数</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token class-name">__copy_dispatch</span><span class="token operator">&lt;</span>_InputIter<span class="token punctuation">,</span> _OutputIter<span class="token punctuation">,</span> _Trivial<span class="token operator">&gt;</span></span>
<span class="line">    <span class="token double-colon punctuation">::</span><span class="token function">copy</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> __last<span class="token punctuation">,</span> __result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_InputIter</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_OutputIter</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_BoolType</span><span class="token operator">&gt;</span>  <span class="token comment">// false type，没有简单拷贝构造函数</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">__copy_dispatch</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">static</span> _OutputIter <span class="token function">copy</span><span class="token punctuation">(</span>_InputIter __first<span class="token punctuation">,</span> _InputIter __last<span class="token punctuation">,</span></span>
<span class="line">                          _OutputIter __result<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>_InputIter<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator_category _Category<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>_InputIter<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>difference_type _Distance<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token function">__copy</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> __last<span class="token punctuation">,</span> __result<span class="token punctuation">,</span> <span class="token function">_Category</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>_Distance<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Tp</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">__copy_dispatch</span><span class="token operator">&lt;</span>_Tp<span class="token operator">*</span><span class="token punctuation">,</span> _Tp<span class="token operator">*</span><span class="token punctuation">,</span> __true_type<span class="token operator">&gt;</span>  <span class="token comment">// true type，有简单拷贝构造函数</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">static</span> _Tp<span class="token operator">*</span> <span class="token function">copy</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Tp<span class="token operator">*</span> __first<span class="token punctuation">,</span> <span class="token keyword">const</span> _Tp<span class="token operator">*</span> __last<span class="token punctuation">,</span> _Tp<span class="token operator">*</span> __result<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token function">__copy_trivial</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> __last<span class="token punctuation">,</span> __result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Tp</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> _Tp<span class="token operator">*</span></span>
<span class="line"><span class="token function">__copy_trivial</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Tp<span class="token operator">*</span> __first<span class="token punctuation">,</span> <span class="token keyword">const</span> _Tp<span class="token operator">*</span> __last<span class="token punctuation">,</span> _Tp<span class="token operator">*</span> __result<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">memmove</span><span class="token punctuation">(</span>__result<span class="token punctuation">,</span> __first<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>_Tp<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>__last <span class="token operator">-</span> __first<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 直接使用 memmove 拷贝</span></span>
<span class="line">  <span class="token keyword">return</span> __result <span class="token operator">+</span> <span class="token punctuation">(</span>__last <span class="token operator">-</span> __first<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="copy-backward" tabindex="-1"><a class="header-anchor" href="#copy-backward"><span>copy backward</span></a></h2><p><code>copy_backward()</code> 和 <code>copy()</code> 几乎相同，唯一的区别是，拷贝是从被拷贝区间的最后一个元素开始，拷贝到目标区间的最后一个位置。因此，拷贝和目标区间可以重叠，但是目标区间的位置需要在拷贝区间之后，否则可能会有问题。</p><p>另外，由于是从后向前拷贝，那么迭代器需要支持 <code>operator--</code>，迭代器类型需要是 Bidirectional Iterator。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token comment">//--------------------------------------------------</span></span>
<span class="line"><span class="token comment">// copy_backward</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_BidirectionalIter1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_BidirectionalIter2</span><span class="token punctuation">,</span></span>
<span class="line">          <span class="token keyword">class</span> <span class="token class-name">_Distance</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> _BidirectionalIter2 <span class="token function">__copy_backward</span><span class="token punctuation">(</span>_BidirectionalIter1 __first<span class="token punctuation">,</span></span>
<span class="line">                                           _BidirectionalIter1 __last<span class="token punctuation">,</span></span>
<span class="line">                                           _BidirectionalIter2 __result<span class="token punctuation">,</span></span>
<span class="line">                                           bidirectional_iterator_tag<span class="token punctuation">,</span></span>
<span class="line">                                           _Distance<span class="token operator">*</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">while</span> <span class="token punctuation">(</span>__first <span class="token operator">!=</span> __last<span class="token punctuation">)</span>   <span class="token comment">// 从 last 开始复制到 first</span></span>
<span class="line">    <span class="token operator">*</span><span class="token operator">--</span>__result <span class="token operator">=</span> <span class="token operator">*</span><span class="token operator">--</span>__last<span class="token punctuation">;</span>  <span class="token comment">// 复制的目标位置为 result，result 迭代器不断前移</span></span>
<span class="line">  <span class="token keyword">return</span> __result<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 针对 Random Access Iterator 的特化版本，提升性能</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_RandomAccessIter</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_BidirectionalIter</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_Distance</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> _BidirectionalIter <span class="token function">__copy_backward</span><span class="token punctuation">(</span>_RandomAccessIter __first<span class="token punctuation">,</span></span>
<span class="line">                                          _RandomAccessIter __last<span class="token punctuation">,</span></span>
<span class="line">                                          _BidirectionalIter __result<span class="token punctuation">,</span></span>
<span class="line">                                          random_access_iterator_tag<span class="token punctuation">,</span></span>
<span class="line">                                          _Distance<span class="token operator">*</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">for</span> <span class="token punctuation">(</span>_Distance __n <span class="token operator">=</span> __last <span class="token operator">-</span> __first<span class="token punctuation">;</span> __n <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>__n<span class="token punctuation">)</span></span>
<span class="line">    <span class="token operator">*</span><span class="token operator">--</span>__result <span class="token operator">=</span> <span class="token operator">*</span><span class="token operator">--</span>__last<span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">return</span> __result<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,55)]))}const i=n(e,[["render",o],["__file","Chapter 6.4 - 基本算法.html.vue"]]),r=JSON.parse('{"path":"/the-annotated-stl-sources-notes/Chapter%206%20-%20%E7%AE%97%E6%B3%95/Chapter%206.4%20-%20%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95.html","title":"Chapter 6.4 - 基本算法","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"equal","slug":"equal","link":"#equal","children":[]},{"level":2,"title":"fill","slug":"fill","link":"#fill","children":[]},{"level":2,"title":"iter_swap","slug":"iter-swap","link":"#iter-swap","children":[]},{"level":2,"title":"lexicographical_compare","slug":"lexicographical-compare","link":"#lexicographical-compare","children":[]},{"level":2,"title":"max / min","slug":"max-min","link":"#max-min","children":[]},{"level":2,"title":"mismatch","slug":"mismatch","link":"#mismatch","children":[]},{"level":2,"title":"swap","slug":"swap","link":"#swap","children":[]},{"level":2,"title":"copy","slug":"copy","link":"#copy","children":[]},{"level":2,"title":"copy backward","slug":"copy-backward","link":"#copy-backward","children":[]}],"git":{},"filePathRelative":"the-annotated-stl-sources-notes/Chapter 6 - 算法/Chapter 6.4 - 基本算法.md"}');export{i as comp,r as data};
