import{_ as s,c as a,a as e,o as p}from"./app-BeHGwf2X.js";const t={};function l(c,n){return p(),a("div",null,n[0]||(n[0]=[e(`<h1 id="chapter-7-中断和中断处理" tabindex="-1"><a class="header-anchor" href="#chapter-7-中断和中断处理"><span>Chapter 7 - 中断和中断处理</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 10 / 19 10:02</p><p>Nanjing, Jiangsu, China</p><hr><p>硬件响应很慢，内核应该在等待硬件响应期间处理其它任务，等到硬件真正完成请求后，再进行处理。<strong>轮询 (polling)</strong> 可能是一种解决方法，但更好的方法是，让硬件在需要的时候向内核发出信号。</p><h2 id="_7-1-中断" tabindex="-1"><a class="header-anchor" href="#_7-1-中断"><span>7.1 中断</span></a></h2><p>中断的本质是一种电信号，由硬件设备发送到 CPU。CPU 接收到中断后，马上向 OS 反应此信号的到来，然后由 OS 负责处理这些新到来的数据。生成中断时，设备并不考虑与 CPU 的时钟同步——中断可以随时产生。</p><p>中断控制器是一个简单的电子芯片，将多路中断管线采用复用技术，只通过一个和 CPU 相连接的管线通信。CPU 接收到中断信号后，转为处理中断。每个中断都有一个唯一的数字标识，使 OS 能对其进行区分。</p><blockquote><p>异常：异常产生时必须考虑与 CPU 时钟同步，因此也被称为同步中断。异常与中断的处理方式类似。</p></blockquote><h2 id="_7-2-中断处理程序" tabindex="-1"><a class="header-anchor" href="#_7-2-中断处理程序"><span>7.2 中断处理程序</span></a></h2><p>与特定的中断相关联，一个设备的中断处理程序是它驱动设备程序的一部分，由内核调用，运行于 <strong>中断上下文</strong> 中。中断上下文与进程上下文不同，不可阻塞。中断随时可能发生，因此中断处理程序也就随时可能执行。所以必须保证中断处理程序能够快速执行，也要让中断处理程序在尽可能短的时间内完成。</p><h2 id="_7-3-上半部与下半部的对比" tabindex="-1"><a class="header-anchor" href="#_7-3-上半部与下半部的对比"><span>7.3 上半部与下半部的对比</span></a></h2><p>中断处理程序 <strong>运行得快</strong> / <strong>工作量多</strong> 是两个矛盾的目标。因此把中断处理切分为两部分：</p><ul><li>上半部（top half）：接收到中断后立刻开始执行，只做有严格时限的工作（应答或复位硬件），在 <strong>关中断</strong> 的条件下被执行</li><li>下半部（bottom half）：在 <strong>开中断</strong> 的条件下被执行</li></ul><blockquote><p>以网卡为例，上半部负责将最新的报文从设备拷贝到内核（时序要求严格），下半部负责对报文进行具体处理。</p></blockquote><h2 id="_7-4-注册中断处理程序" tabindex="-1"><a class="header-anchor" href="#_7-4-注册中断处理程序"><span>7.4 注册中断处理程序</span></a></h2><p>如果设备使用中断，那么驱动程序就注册一个中断处理程序。驱动程序通过 <code>request_irp()</code> 注册一个中断处理程序。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">int</span> <span class="token function">request_irq</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> irq<span class="token punctuation">,</span></span>
<span class="line">               <span class="token class-name">irq_handler_t</span> handler<span class="token punctuation">,</span></span>
<span class="line">               <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">,</span></span>
<span class="line">               <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span></span>
<span class="line">               <span class="token keyword">void</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><code>irq</code> 为要分配的中断号</p></li><li><p><code>handler</code> 是一个函数指针，函数原型需要满足：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token class-name">irqreturn_t</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token class-name">irq_handler_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><h3 id="_7-4-1-中断处理程序标志" tabindex="-1"><a class="header-anchor" href="#_7-4-1-中断处理程序标志"><span>7.4.1 中断处理程序标志</span></a></h3><ul><li><code>IRQF_DISABLED</code> - 内核在处理中断处理程序期间，要禁止所有的其它中断</li><li><code>IRQF_SAMPLE_RANDOM</code> - 中断对内核熵池有贡献 - 产生随机数</li><li><code>IRQF_TIMER</code> - 为时钟中断准备</li><li><code>IRQF_SHARED</code> - 在多个共享处理程序之间共享中断线，否则，在每条中断线上只能有一个处理程序</li></ul><p><code>name</code> 参数是设备的 ASCII 文本表示<code>dev</code> 参数用于共享中断线。当中断处理程序需要被释放时，该参数提供唯一的标识信息。内核调用中断处理程序时，会将这个指针传递。</p><p><code>request_irp()</code> 成功执行后返回 0，如果返回非 0，则中断处理程序不会被注册。通常是中断线已被占用，而没有指定共享中断线。</p><p>此外，这个函数可能会睡眠，所以不能在中断上下文或其它不允许阻塞的代码中使用。</p><h3 id="_7-4-2-一个中断例子" tabindex="-1"><a class="header-anchor" href="#_7-4-2-一个中断例子"><span>7.4.2 一个中断例子</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">request_irq</span><span class="token punctuation">(</span>irqn<span class="token punctuation">,</span> my_interrupt<span class="token punctuation">,</span> IRQF_SHARED<span class="token punctuation">,</span> <span class="token string">&quot;my_device&quot;</span><span class="token punctuation">,</span> my_dev<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">&quot;my_device: cannot register IRQ %d\\n&quot;</span><span class="token punctuation">,</span> irqn<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token operator">-</span>EIO<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_7-4-3-释放中断处理程序" tabindex="-1"><a class="header-anchor" href="#_7-4-3-释放中断处理程序"><span>7.4.3 释放中断处理程序</span></a></h3><p>卸载驱动程序时：</p><ul><li>注销中断处理程序</li><li>释放中断线</li></ul><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">void</span> <span class="token function">free_irq</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果中断线不是共享的，那么同时将禁用这条中断线；如果是共享的，那么仅删除对应处理程序，在所有处理程序被卸载后才禁用中断线。</p><h2 id="_7-5-编写中断处理程序" tabindex="-1"><a class="header-anchor" href="#_7-5-编写中断处理程序"><span>7.5 编写中断处理程序</span></a></h2><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">static</span> <span class="token class-name">irqreturn_t</span> <span class="token function">intr_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在 Linux 2.0 之前没有 <code>dev</code> 参数，只能通过中断号区分驱动程序。<code>dev</code> 参数可以用于区分共享同一中断处理程序的多个设备。</p><p>中断处理程序的两个可能的返回值：<code>IRQ_NONE</code> 和 <code>IRQ_HANDLED</code>：</p><ul><li><code>IRQ_NONE</code> - 检测到中断，但中断对应的设备并不是处理函数所指定的来源设备</li><li><code>IRQ_HANDLED</code> - 确实是中断处理程序所对应的设备产生的中断</li></ul><p>利用这两个值，内核可以知道设备是否发出了虚假请求</p><blockquote><p>重入</p><p>Linux 的中断处理程序是无须重入的，因为在给定的中断处理程序正在执行时，相应中断线在所有 CPU 上都会被屏蔽。同一个中断处理程序绝对不会被同时调用以处理嵌套的中断。</p></blockquote><h3 id="_7-5-1-共享的中断处理程序" tabindex="-1"><a class="header-anchor" href="#_7-5-1-共享的中断处理程序"><span>7.5.1 共享的中断处理程序</span></a></h3><p><code>IRQF_SHARED</code> 标志必须被设置。对于每个注册的中断处理程序来说，<code>dev</code> 参数必须唯一，中断处理程序必须能够区分它的设备是否发生了中断。内核接收到中断后，将依次调用在该中断线上注册的每一个处理程序。因此，处理程序必须知道它是否改为这个中断负责。如果不是相关设备产生的中断，则处理程序应当立即退出。这需要硬件提供类似状态寄存器的机制，以便中断处理程序检查。</p><h2 id="_7-6-中断上下文" tabindex="-1"><a class="header-anchor" href="#_7-6-中断上下文"><span>7.6 中断上下文</span></a></h2><p>Interrupt context。</p><p>Re-cap: 进程上下文。通过 <code>current</code> 关联当前进程，进程以进程上下文的形式连接在内核中，进程上下文可以睡眠，也可以调用调度程序。而中断上下文没有后备进程，因此不可以睡眠，也不能从中断上下文中调用可以睡眠的函数！中断上下文有严格的时间限制，应当迅速、简洁，尽量不要处理繁重的工作，尽量把工作分离到下半部中。</p><p>曾经，中断处理程序共享所中断进程的内核栈（两页）。在 Linux 2.6 的早期版本中，内核栈减为 1 页，减轻内存的压力。每个 CPU 专门为中断处理程序分配了 1 页中断栈。虽然栈小了，但平均可用栈空间大得多。</p><h2 id="_7-7-中断处理机制的实现" tabindex="-1"><a class="header-anchor" href="#_7-7-中断处理机制的实现"><span>7.7 中断处理机制的实现</span></a></h2><p>对于每条中断线，在内核接收到中断信号后，对跳转到对应的唯一位置，在栈中保存中断号和当前寄存器的值（作为 C 函数的参数）。然后调用：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">do_IRQ</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> regs<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>该函数提取出中断号，禁止这条中断线上的所有中断。如果中断线上有一个有效的处理程序，就调用如下程序，运行这条中断线上安装的所有中断处理程序（如果是共享的话）：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token class-name">irqreturn_t</span> <span class="token function">handle_IRQ_event</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">irqaction</span> <span class="token operator">*</span>action<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">irqreturn_t</span> ret<span class="token punctuation">,</span> retval <span class="token operator">=</span> IRQ_NONE<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>action<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> IRQF_DISABLED<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token comment">// 此时已经关中断</span></span>
<span class="line">        <span class="token comment">// 若处理程序不需要关中断，则开中断</span></span>
<span class="line">        <span class="token function">local_irq_enable_in_hardirq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">do</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">trace_irq_handler_entry</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> action<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        ret <span class="token operator">=</span> action<span class="token operator">-&gt;</span><span class="token function">handler</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> action<span class="token operator">-&gt;</span>dev_id<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token function">trace_irq_handler_exit</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> action<span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">switch</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">case</span> IRQ_WAKE_THREAD<span class="token operator">:</span></span>
<span class="line">                ret <span class="token operator">=</span> IRQ_HANDLED<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>action<span class="token operator">-&gt;</span>thread_fn<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                    <span class="token function">warn_no_thread</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> action<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                    <span class="token keyword">break</span><span class="token punctuation">;</span></span>
<span class="line">                <span class="token punctuation">}</span></span>
<span class="line">                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">test_bit</span><span class="token punctuation">(</span>IRQTF_DIED<span class="token punctuation">,</span> <span class="token operator">&amp;</span>action<span class="token operator">-&gt;</span>thread_flags<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                    <span class="token function">set_bit</span><span class="token punctuation">(</span>IRQTF_RUNTHREAD<span class="token punctuation">,</span> <span class="token operator">&amp;</span>action<span class="token operator">-&gt;</span>thread_flags<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                    <span class="token function">wake_up_process</span><span class="token punctuation">(</span>action<span class="token operator">-&gt;</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">            <span class="token keyword">case</span> IRQ_HANDLED<span class="token operator">:</span></span>
<span class="line">                status <span class="token operator">|=</span> action<span class="token operator">-&gt;</span>flags<span class="token punctuation">;</span></span>
<span class="line">                <span class="token keyword">break</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">default</span><span class="token operator">:</span></span>
<span class="line">                <span class="token keyword">break</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        retval <span class="token operator">|=</span> ret<span class="token punctuation">;</span></span>
<span class="line">        action <span class="token operator">=</span> action<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">&amp;</span> IRQF_SAMPLE_RANDOM<span class="token punctuation">)</span></span>
<span class="line">        <span class="token comment">// 将中间时间间隔作为随机数生成器</span></span>
<span class="line">        <span class="token function">add_interrupt_randomness</span><span class="token punctuation">(</span>irq<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token function">local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重新关中断</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">return</span> retval<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_7-8-proc-interrupts" tabindex="-1"><a class="header-anchor" href="#_7-8-proc-interrupts"><span>7.8 /proc/interrupts</span></a></h2><h2 id="_7-9-中断控制" tabindex="-1"><a class="header-anchor" href="#_7-9-中断控制"><span>7.9 中断控制</span></a></h2><p>Linux 内核提供了一组接口，操作机器上的中断状态</p><ul><li>禁止中断系统</li><li>屏蔽整个机器上的一条中断线</li></ul><blockquote><p>不再使用全局的 <code>cli()</code>。这种方法虽然适用于所有体系结构，但完全以 x86 为中心。以前代码仅需通过全局禁止中断达到互斥，现在需要使用本地中断控制和自旋锁达到互斥。</p><p>取消 <code>cli()</code> 的优点：</p><ul><li>强制驱动程序的编写者实现真正的加锁</li><li>具有特定目的的细粒度锁比全局锁要快许多</li></ul></blockquote>`,55)]))}const o=s(t,[["render",l],["__file","Chapter 7 - 中断和中断处理.html.vue"]]),r=JSON.parse('{"path":"/linux-kernel-development-notes/Chapter%207%20-%20%E4%B8%AD%E6%96%AD%E5%92%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86.html","title":"Chapter 7 - 中断和中断处理","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"7.1 中断","slug":"_7-1-中断","link":"#_7-1-中断","children":[]},{"level":2,"title":"7.2 中断处理程序","slug":"_7-2-中断处理程序","link":"#_7-2-中断处理程序","children":[]},{"level":2,"title":"7.3 上半部与下半部的对比","slug":"_7-3-上半部与下半部的对比","link":"#_7-3-上半部与下半部的对比","children":[]},{"level":2,"title":"7.4 注册中断处理程序","slug":"_7-4-注册中断处理程序","link":"#_7-4-注册中断处理程序","children":[{"level":3,"title":"7.4.1 中断处理程序标志","slug":"_7-4-1-中断处理程序标志","link":"#_7-4-1-中断处理程序标志","children":[]},{"level":3,"title":"7.4.2 一个中断例子","slug":"_7-4-2-一个中断例子","link":"#_7-4-2-一个中断例子","children":[]},{"level":3,"title":"7.4.3 释放中断处理程序","slug":"_7-4-3-释放中断处理程序","link":"#_7-4-3-释放中断处理程序","children":[]}]},{"level":2,"title":"7.5 编写中断处理程序","slug":"_7-5-编写中断处理程序","link":"#_7-5-编写中断处理程序","children":[{"level":3,"title":"7.5.1 共享的中断处理程序","slug":"_7-5-1-共享的中断处理程序","link":"#_7-5-1-共享的中断处理程序","children":[]}]},{"level":2,"title":"7.6 中断上下文","slug":"_7-6-中断上下文","link":"#_7-6-中断上下文","children":[]},{"level":2,"title":"7.7 中断处理机制的实现","slug":"_7-7-中断处理机制的实现","link":"#_7-7-中断处理机制的实现","children":[]},{"level":2,"title":"7.8 /proc/interrupts","slug":"_7-8-proc-interrupts","link":"#_7-8-proc-interrupts","children":[]},{"level":2,"title":"7.9 中断控制","slug":"_7-9-中断控制","link":"#_7-9-中断控制","children":[]}],"git":{},"filePathRelative":"linux-kernel-development-notes/Chapter 7 - 中断和中断处理.md"}');export{o as comp,r as data};
