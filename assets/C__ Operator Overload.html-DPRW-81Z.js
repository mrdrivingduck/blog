import{_ as n,c as a,a as e,o as p}from"./app-7eKjwDat.js";const t={};function l(o,s){return p(),a("div",null,s[0]||(s[0]=[e(`<h1 id="c-operator-overload" tabindex="-1"><a class="header-anchor" href="#c-operator-overload"><span>C++ - Operator Overload</span></a></h1><p>Created by : Mr Dk.</p><p>2021 / 03 / 05 20:14</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="about" tabindex="-1"><a class="header-anchor" href="#about"><span>About</span></a></h2><p>运算符重载是一种形式的 C++ 多态，根据操作数的 <strong>数目</strong> 和 <strong>类型</strong> 来决定采用哪种操作。其一般形式为：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token function">operatorop</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中，后一个 <code>op</code> 可被替换为 C++ 中已经存在的且可以被重载的运算符，比如加法运算符 <code>+</code>：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>重载后，编译器能够对运算符进行等价的替换：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line">A <span class="token operator">=</span> B <span class="token operator">+</span> C<span class="token punctuation">;</span></span>
<span class="line">A <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>上述运算符重载方式只能由运算符左侧的操作数通过 <strong>成员函数</strong> 实现。另外可以通过 <strong>友元函数</strong> 实现运算符右侧操作数的运算符重载。</p><h2 id="limits" tabindex="-1"><a class="header-anchor" href="#limits"><span>Limits</span></a></h2><p>C++ 的运算符重载又如下限制：</p><ol><li>运算符重载至少要有一个操作数是用户定义的类型 (防止用户为原生类型重载运算符)</li><li>不能违反运算符的句法规则 (原来是双目，那就还得是双目)</li><li>不能修改运算符优先级</li><li>不能创建新的运算符</li><li>不能重载如下运算符： <ul><li><code>sizeof</code></li><li><code>.</code></li><li><code>.*</code></li><li><code>::</code></li><li><code>?:</code></li><li><code>typeid</code></li><li><code>const_cast</code></li><li><code>dynamic_cast</code></li><li><code>reinterpret_cast</code></li><li><code>static_cast</code></li></ul></li><li>某些运算符只能以成员函数的形式重载 (不能以友元函数)： <ul><li><code>=</code></li><li><code>()</code></li><li><code>[]</code></li><li><code>-&gt;</code></li></ul></li></ol><h2 id="implementation" tabindex="-1"><a class="header-anchor" href="#implementation"><span>Implementation</span></a></h2><h3 id="member-function" tabindex="-1"><a class="header-anchor" href="#member-function"><span>Member Function</span></a></h3><p>以成员函数实现运算符重载，默认了运算符左侧的操作数是当前对象，因此只需要传递一个右操作数作为参数即可。编译器负责将重载后的运算符替换为成员函数调用：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line">T<span class="token double-colon punctuation">::</span>T <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">&amp;</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line">A <span class="token operator">=</span> B <span class="token operator">*</span> <span class="token number">2.75</span><span class="token punctuation">;</span></span>
<span class="line">A <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">2.75</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>那么，这种情况怎么办呢？</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line">A <span class="token operator">=</span> <span class="token number">2.75</span> <span class="token operator">*</span> B<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="friend-function" tabindex="-1"><a class="header-anchor" href="#friend-function"><span>Friend Function</span></a></h2><p>如果说将运算符的重载不重载为成员函数，而是重载为一个普通函数，通过传入两个参数，就可以实现按照需要获取操作数顺序。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line">T <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">&amp;</span>d<span class="token punctuation">,</span> T obj<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line">A <span class="token operator">=</span> <span class="token number">2.75</span> <span class="token operator">*</span> B<span class="token punctuation">;</span></span>
<span class="line">A <span class="token operator">=</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">2.75</span><span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这时出现了一个问题：如果这个函数的实现需要访问类的 <strong>私有成员变量</strong> 该怎么办？由于非成员函数不是由对象调用，因此不能访问类内部的私有成员变量。这时候就需要类的 <strong>友元函数</strong> 出马。类的友元函数是非成员函数，但是访问权限与成员函数相同 - 可以访问类的私有成员变量。</p><p>创建友元函数的方式是将函数声明在类内，并在原型前加上 <code>friend</code> 关键字 (不需要类限定符 <code>::</code>)：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">friend</span> T <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">&amp;</span>d<span class="token punctuation">,</span> T obj<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// T.xxx;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>总结，如果要为类重载运算符，并且不是用类对象作为第一个参数，可以使用友元函数反转操作数顺序。当然，具体用不用友元取决于 <strong>是否要访问类内的私有成员变量</strong>：如果只是将对象作为一个整体使用，不用友元也一样。</p></blockquote><h2 id="example-overload" tabindex="-1"><a class="header-anchor" href="#example-overload"><span>Example: Overload &lt;&lt;</span></a></h2><p>对于一个自定义的类，用户希望能够通过 <code>cout &lt;&lt; obj</code> 直接打印对象信息。对于该运算符来说，显然用户不会去修改 <code>iostream</code> 的头文件来为 cout 对象重载 <code>&lt;&lt;</code> 运算符。所以，需要通过友元 (如果需要打印类内私有变量的值) 的方式为该类对象重载 <code>&lt;&lt;</code> 运算符。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    os <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>xxx<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于要操作 cout 对象本身，所以这里传入的参数是引用。编译器会将代码转换为：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line">cout <span class="token operator">&lt;&lt;</span> obj<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>cout<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这样还是有个问题：没法适用于连续的 <code>&lt;&lt;</code> 运算符：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line">cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Hello&quot;</span> <span class="token operator">&lt;&lt;</span> obj <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;hhh&quot;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// (cout &lt;&lt; &quot;Hello&quot;) &lt;&lt; obj &lt;&lt; &quot;hhh&quot;;</span></span>
<span class="line"><span class="token comment">// cout &lt;&lt; obj &lt;&lt; &quot;hhh&quot;;</span></span>
<span class="line"><span class="token comment">// (void) &lt;&lt; &quot;hhh&quot;;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以重载函数的返回值也应当是 <code>ostream</code> 对象，并且是一个引用：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">friend</span> ostream <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    os <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>xxx<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span> os<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就可以实现如下的效果：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line">cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Hello&quot;</span> <span class="token operator">&lt;&lt;</span> obj <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;hhh&quot;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// (cout &lt;&lt; &quot;Hello&quot;) &lt;&lt; obj &lt;&lt; &quot;hhh&quot;;</span></span>
<span class="line"><span class="token comment">// cout &lt;&lt; obj &lt;&lt; &quot;hhh&quot;;</span></span>
<span class="line"><span class="token comment">// cout &lt;&lt; &quot;hhh&quot;;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="example-stl" tabindex="-1"><a class="header-anchor" href="#example-stl"><span>Example: STL</span></a></h2><p>由于 STL 中的容器基本实现了泛型，因此用户可以将自定义类型的对象放进 STL 容器中。在对 STL 容器内元素进行排序时，算法默认使用 <code>&lt;</code> 运算符。因此，如果要对自定义类型的对象进行排序，需要为类重载 <code>&lt;</code> 运算符。函数原型如下：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>t<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里为什么要使用 <code>const</code> 呢？STL 底层的比较函数实现类似如下：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>__x<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>__y<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> __x <span class="token operator">&lt;</span> __y<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只有 <code>const</code> 函数才可以访问 <code>const</code> 对象中的数据。</p>`,48)]))}const i=n(t,[["render",l],["__file","C__ Operator Overload.html.vue"]]),r=JSON.parse('{"path":"/notes/C__/C__%20Operator%20Overload.html","title":"C++ - Operator Overload","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"About","slug":"about","link":"#about","children":[]},{"level":2,"title":"Limits","slug":"limits","link":"#limits","children":[]},{"level":2,"title":"Implementation","slug":"implementation","link":"#implementation","children":[{"level":3,"title":"Member Function","slug":"member-function","link":"#member-function","children":[]}]},{"level":2,"title":"Friend Function","slug":"friend-function","link":"#friend-function","children":[]},{"level":2,"title":"Example: Overload <<","slug":"example-overload","link":"#example-overload","children":[]},{"level":2,"title":"Example: STL","slug":"example-stl","link":"#example-stl","children":[]}],"git":{},"filePathRelative":"notes/C++/C++ Operator Overload.md"}');export{i as comp,r as data};
