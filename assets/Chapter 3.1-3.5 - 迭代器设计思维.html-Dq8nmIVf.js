import{_ as n,c as a,a as e,o as p}from"./app-BeHGwf2X.js";const t={};function l(c,s){return p(),a("div",null,s[0]||(s[0]=[e(`<h1 id="chapter-3-1-3-5-迭代器设计思维" tabindex="-1"><a class="header-anchor" href="#chapter-3-1-3-5-迭代器设计思维"><span>Chapter 3.1-3.5 - 迭代器设计思维</span></a></h1><p>Created by : Mr Dk.</p><p>2021 / 03 / 31 18:44</p><p>Nanjing, Jiangsu, China</p><hr><p><strong>迭代器 (iterator)</strong> 模式是 <em>Design Patterns</em> 中提供的 23 个设计模式之一，定义为：提供一种方法，使之能够依序巡防某个聚合物 (容器) 所含的各种元素，而又无需暴露该聚合物的内部表述方式。</p><p>STL 的中心思想在于，将 <strong>数据容器</strong> 与 <strong>算法</strong> 分开，彼此独立设计，最后再以粘合剂将它们撮合在一起。容器的泛型化可以由 C++ 的 class templates 完成；算法的泛型化可以由 C++ 的 function templates 完成；迭代器实现容器和算法的粘合。</p><p>迭代器是一种行为类似指针的对象，而指针最常用的操作是：</p><ul><li><code>operator*</code></li><li><code>operator-&gt;</code></li></ul><p>因此，迭代器最重要的工作就是对以上两个运算符进行重载。</p><p>另外，在迭代器设计时，应当尽可能不暴露迭代对象的设计细节。因此，迭代器的设计工作应当交给相应数据结构的设计者。这样可以把所有实现细节封装起来不被使用者看到。STL 中每一种容器都有专属的迭代器。</p><h2 id="_3-3-迭代器的关联类型-associated-types" tabindex="-1"><a class="header-anchor" href="#_3-3-迭代器的关联类型-associated-types"><span>3.3 迭代器的关联类型 (Associated Types)</span></a></h2><p>迭代器既然功能类似指针，那么除了迭代器自身的数据类型 <code>I</code> 以外，还应该知道自身指向数据的数据类型 <code>T</code>，及其它的相关联的数据类型。利用 C++ 函数模板的参数推导功能，可以部分解决这样的问题：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">func_impl</span><span class="token punctuation">(</span>I iter<span class="token punctuation">,</span> T t<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    T tmp<span class="token punctuation">;</span> <span class="token comment">// 迭代器指向的类型</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>I iter<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">func_impl</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> <span class="token operator">*</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">int</span> i<span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过将 <code>func()</code> 的所有逻辑都移到 <code>func_impl()</code> 中实现，然后利用类型推导，成功在 <code>func_impl()</code> 中获得了迭代器指向的类型 <code>T</code>。问题在于，用户最终调用的是 <code>func()</code>。如果希望 <code>func()</code> 返回迭代器指向的数据类型，那么 <code>func()</code> 如何能够返回迭代器指向的数据类型 <code>T</code> 呢？</p><p>通过在迭代器类内 <strong>显式声明内嵌类型</strong> 即可。比如将迭代器指向的数据类型统一命名为 <code>value_type</code>：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">MyIter</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">typedef</span> T value_type<span class="token punctuation">;</span> <span class="token comment">// 将内嵌类型显式声明为 value_type 类型</span></span>
<span class="line"></span>
<span class="line">    T <span class="token operator">*</span>ptr<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">typename</span> <span class="token class-name">I</span><span class="token double-colon punctuation">::</span>value_type <span class="token comment">// func 函数的返回值为 I 的 value_type 类型</span></span>
<span class="line"><span class="token function">func</span><span class="token punctuation">(</span>I iter<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token operator">*</span>iter<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是 STL 必须接受 C++ 原生指针作为迭代器，而原生指针并没有 <code>value_type</code> 的定义。通过 C++ 模板的 <strong>部分具体化</strong>，可以为原生指针类型单独实现一套特殊版本的模板：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">MyIter</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-4-traits-编程方法-stl-源代码的钥匙" tabindex="-1"><a class="header-anchor" href="#_3-4-traits-编程方法-stl-源代码的钥匙"><span>3.4 Traits 编程方法 - STL 源代码的钥匙</span></a></h2><p>STL 定义了一个专门用于 <strong>萃取</strong> 迭代器特性 (包含其内嵌类型) 的结构体。假设我们关注迭代器的特性只有内嵌类型 <code>value_type</code> (实际上还会有别的)，那么模板结构体的定义为：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">iterator_traits</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">I</span><span class="token double-colon punctuation">::</span>value_type value_type<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果 <code>I</code> 类型有自己的 <code>value_type</code> 定义，那么 <code>I</code> 的 <code>value_type</code> 类型就是该结构体的 <code>value_type</code> 类型。<code>func()</code> 函数可改写为：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">typename</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>I<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_type <span class="token comment">// func 的返回类型</span></span>
<span class="line"><span class="token function">func</span><span class="token punctuation">(</span>I iter<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token operator">*</span>iter<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于原生指针类型，实现一个部分具体化的结构体模板，使其内嵌类型为原生指针指向的数据类型：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">typedef</span> T value_type<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外，还有常量指针。设计另一个部分具体化的版本即可：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span><span class="token keyword">const</span> T<span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">typedef</span> T value_type<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>综上，<code>iterator_traits</code> 实现了类似 <strong>榨汁机</strong> 的功能，把迭代器相关联的数据类型给榨取出来。当然，STL 中所有的迭代器都要遵循约定，定义出迭代器所有的关联数据类型。不遵守约定的迭代器将无法兼容 STL。除了指向的数据类型 (<code>value_type</code>) 外，迭代器需要定义五种相关联的数据类型。定义如下：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">iterator_traits</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">I</span><span class="token double-colon punctuation">::</span>iterator_category iterator_category<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">I</span><span class="token double-colon punctuation">::</span>value_type        value_type<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">I</span><span class="token double-colon punctuation">::</span>difference_type   difference_type<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">I</span><span class="token double-colon punctuation">::</span>pointer           pointer<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">I</span><span class="token double-colon punctuation">::</span>reference         reference<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于原生指针、原生常量指针，需要对这个结构体模板进行部分具体化，正确表示这五个数据类型。</p><p>这些数据类型的含义如下。</p><h3 id="value-type" tabindex="-1"><a class="header-anchor" href="#value-type"><span><code>value_type</code></span></a></h3><p>迭代器所指对象的数据类型，即 <strong>内嵌类型</strong>。</p><h3 id="difference-type" tabindex="-1"><a class="header-anchor" href="#difference-type"><span><code>difference_type</code></span></a></h3><p>表示两个迭代器之间的距离。对于 C++ 原生指针和原生常量指针，需要部分具体化，使用 C++ 自带的 <code>ptrdiff_t</code> (定义在 <code>&lt;sctddef&gt;</code> 头文件中) 作为原生指针之间的距离：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">typedef</span> ptrdiff_t difference_type<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span><span class="token keyword">const</span> T<span class="token operator">*</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">typedef</span> ptrdiff_t difference_type<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="reference-type" tabindex="-1"><a class="header-anchor" href="#reference-type"><span><code>reference_type</code></span></a></h3><p>根据迭代器所指数据是否允许被改变，当函数需要返回 <strong>左值</strong> (允许被赋值) 时，应当以引用类型的方式返回。</p><h3 id="pointer-type" tabindex="-1"><a class="header-anchor" href="#pointer-type"><span><code>pointer_type</code></span></a></h3><p>指向迭代器所指数据的指针类型。同样需要对原生指针和原生常量指针进行特化。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">typedef</span> T<span class="token operator">*</span> pointer<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">typedef</span> T<span class="token operator">&amp;</span> reference<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span><span class="token keyword">const</span> T<span class="token operator">*</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">typedef</span> <span class="token keyword">const</span> T<span class="token operator">*</span> pointer<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">typedef</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> reference<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="iterator-category" tabindex="-1"><a class="header-anchor" href="#iterator-category"><span><code>iterator_category</code></span></a></h3><p>用于区分迭代器的操作类型。根据移动特性分类，迭代器可以被分为：</p><ul><li>Input Iterator：迭代器所指对象 <strong>只读</strong></li><li>Output Iterator：迭代器所指对象 <strong>只写</strong></li><li>Forward Iterator：迭代器所指区间范围内可读可写，但只能向前移动</li><li>Bidirectional Iterator：迭代器在区间上可 <strong>双向移动</strong></li><li>Random Access Iterator：涵盖指针的所有算数能力，除了双向移动，还能 <strong>跳跃移动</strong> (随机访问)</li></ul><p>这五种迭代器有着天然的从属关系：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">Input Iterator  --</span>
<span class="line">                  |--&gt; Forward Iterator --&gt; Bidirectional Iterator --&gt; Random Access Iterator</span>
<span class="line">Output Iterator --</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>显然，如果迭代器支持更高级的操作，那么使用低级的操作方式将使性能下降。比如，如果要使迭代器前进三个单位，对于 Forward Iterator 来说需要循环，而对 Random Access Iterator 来说只需要直接将指针 + 3 即可。对于算法库中的函数模板，需要根据迭代器的不同类型，分别实现不同性能的操作方式。如何判断迭代器的类型呢？使用 traits 中的 <code>iterator_category()</code> 属性作为函数的最后一个参数，使编译器根据迭代器类型选择相应的重载函数。</p><p>五种迭代器根据从属关系定义为五个结构体。结构体内没有任何成员，因为只作为标记使用：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">input_iterator_tag</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">output_iterator_tag</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">forward_iterator_tag</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">input_iterator_tag</span></span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">bidirectional_iterator_tag</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">forward_iterator_tag</span></span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">random_access_iterator_tag</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">bidirectional_iterator_tag</span></span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如，对于算法模板中的 <code>advance()</code> 来说，其入口被定义为：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>InputIterator<span class="token operator">&amp;</span> i<span class="token punctuation">,</span> Distance n<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">__advance</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>InputIterator<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">iterator_category</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码中产生了 <code>iterator_category</code> 对应的临时对象，根据对象类型，编译器选择合适的重载函数。重载的版本有以下几种，实现各不相同，并且最后一个参数只有类型没有变量名 (因为仅用于让编译器区分版本，具体实现内不需要使用)。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__advance</span><span class="token punctuation">(</span>InputIterator<span class="token operator">&amp;</span> i<span class="token punctuation">,</span> Distance n<span class="token punctuation">,</span> input_iterator_tag<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// input_iterator 版本</span></span>
<span class="line">    <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">++</span>i<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__advance</span><span class="token punctuation">(</span>ForwardIterator<span class="token operator">&amp;</span> i<span class="token punctuation">,</span> Distance n<span class="token punctuation">,</span> forward_iterator_tag<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// forward_iterator 版本</span></span>
<span class="line">    <span class="token function">__advance</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token function">input_iterator_tag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传递调用 input_iterator 版本</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BidirectionalIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__advance</span><span class="token punctuation">(</span>BidirectionalIterator<span class="token operator">&amp;</span> i<span class="token punctuation">,</span> Distance n<span class="token punctuation">,</span> bidirectional_iterator_tag<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// bidirectional_iterator 版本</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">++</span>i<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">else</span></span>
<span class="line">        <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">--</span>i<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__advance</span><span class="token punctuation">(</span>RandomAccessIterator<span class="token operator">&amp;</span> i<span class="token punctuation">,</span> Distance n<span class="token punctuation">,</span> random_access_iterator_tag<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    i <span class="token operator">+=</span> n<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，对于这个迭代器关联类型，也需要为原生指针和原生常量指针特化出一个版本。由于原生指针和原生常量指针都是随机访问的迭代器，因此直接将迭代器类型特化为 Random Access Iterator：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">typedef</span> random_access_iterator_tag iterator_category<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span><span class="token keyword">const</span> T<span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">typedef</span> random_access_iterator_tag iterator_category<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外，对于算法库中的函数模板，参数列表中的迭代器类型以它可以接受的 <strong>最低级迭代器</strong> 的类型为参数命名。比如 <code>advance()</code> 函数，能够接受 Input Iterator 以上的所有类型迭代器，因此该函数被定义为：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>InputIterator<span class="token operator">&amp;</span> i<span class="token punctuation">,</span> Distance n<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">__advance</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>InputIterator<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">iterator_category</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，低于 Input Iterator 等级的迭代器 (如果有) 将无法作为 <code>advance()</code> 的参数。</p><h2 id="_3-5-std-iterator-的保证" tabindex="-1"><a class="header-anchor" href="#_3-5-std-iterator-的保证"><span>3.5 <code>std::iterator</code> 的保证</span></a></h2><p>如果一个迭代器不提供上述五个关联数据类型，traits 机制将无法工作，导致自别于整个 STL 架构，无法与 STL 其它组件顺利搭配。STL 提供了一个类，使得如果每个新设计的迭代器都能继承自它，就可以保证符合 STL 规范：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Category</span><span class="token punctuation">,</span></span>
<span class="line">          <span class="token keyword">class</span> <span class="token class-name">_Tp</span><span class="token punctuation">,</span></span>
<span class="line">          <span class="token keyword">class</span> <span class="token class-name">_Distance</span> <span class="token operator">=</span> ptrdiff_t<span class="token punctuation">,</span></span>
<span class="line">          <span class="token keyword">class</span> <span class="token class-name">_Pointer</span> <span class="token operator">=</span> _Tp<span class="token operator">*</span><span class="token punctuation">,</span></span>
<span class="line">          <span class="token keyword">class</span> <span class="token class-name">_Reference</span> <span class="token operator">=</span> _Tp<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">iterator</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">typedef</span> _Category  iterator_category<span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">typedef</span> _Tp        value_type<span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">typedef</span> _Distance  difference_type<span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">typedef</span> _Pointer   pointer<span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">typedef</span> _Reference reference<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，后三个参数都有默认值，因此只需要提供前两个参数即可：</p><ul><li>迭代器类型</li><li>迭代器的内嵌类型</li></ul>`,64)]))}const i=n(t,[["render",l],["__file","Chapter 3.1-3.5 - 迭代器设计思维.html.vue"]]),r=JSON.parse('{"path":"/the-annotated-stl-sources-notes/Chapter%203%20-%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A6%82%E5%BF%B5%E4%B8%8E%20traits%20%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95/Chapter%203.1-3.5%20-%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%80%9D%E7%BB%B4.html","title":"Chapter 3.1-3.5 - 迭代器设计思维","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"3.3 迭代器的关联类型 (Associated Types)","slug":"_3-3-迭代器的关联类型-associated-types","link":"#_3-3-迭代器的关联类型-associated-types","children":[]},{"level":2,"title":"3.4 Traits 编程方法 - STL 源代码的钥匙","slug":"_3-4-traits-编程方法-stl-源代码的钥匙","link":"#_3-4-traits-编程方法-stl-源代码的钥匙","children":[{"level":3,"title":"value_type","slug":"value-type","link":"#value-type","children":[]},{"level":3,"title":"difference_type","slug":"difference-type","link":"#difference-type","children":[]},{"level":3,"title":"reference_type","slug":"reference-type","link":"#reference-type","children":[]},{"level":3,"title":"pointer_type","slug":"pointer-type","link":"#pointer-type","children":[]},{"level":3,"title":"iterator_category","slug":"iterator-category","link":"#iterator-category","children":[]}]},{"level":2,"title":"3.5 std::iterator 的保证","slug":"_3-5-std-iterator-的保证","link":"#_3-5-std-iterator-的保证","children":[]}],"git":{},"filePathRelative":"the-annotated-stl-sources-notes/Chapter 3 - 迭代器概念与 traits 编程方法/Chapter 3.1-3.5 - 迭代器设计思维.md"}');export{i as comp,r as data};
