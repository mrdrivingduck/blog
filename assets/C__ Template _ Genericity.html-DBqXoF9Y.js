import{_ as n,c as a,a as e,o as p}from"./app-7eKjwDat.js";const t={};function o(l,s){return p(),a("div",null,s[0]||(s[0]=[e(`<h1 id="c-template-genericity" tabindex="-1"><a class="header-anchor" href="#c-template-genericity"><span>C++ - Template &amp; Genericity</span></a></h1><p>Created by : Mr Dk.</p><p>2021 / 03 / 29 23:00</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="function-template" tabindex="-1"><a class="header-anchor" href="#function-template"><span>Function Template</span></a></h2><p>现代 C++ 编译器实现了 C++ 新增的特性：函数模板。允许 <strong>使用类型作为参数</strong> 来定义函数，使得编译器自动生成该类型的函数。这一特性也被称为 <em>参数化类型 (parameterized types)</em>。一个最经典的例子：实现一个 <code>swap()</code> 函数交换两个变量。显然，需要对不同的数据类型实现不同的函数，而函数主体中的内容完全相同：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">;</span></span>
<span class="line">    a <span class="token operator">=</span> b<span class="token punctuation">;</span></span>
<span class="line">    b <span class="token operator">=</span> temp<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">double</span> temp <span class="token operator">=</span> a<span class="token punctuation">;</span></span>
<span class="line">    a <span class="token operator">=</span> b<span class="token punctuation">;</span></span>
<span class="line">    b <span class="token operator">=</span> temp<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>模板提供了一种抽象，能够将 <strong>数据类型</strong> 作为参数。这样，只需要实现一个抽象的函数主体即可：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> T <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    T temp <span class="token operator">=</span> a<span class="token punctuation">;</span></span>
<span class="line">    a <span class="token operator">=</span> b<span class="token punctuation">;</span></span>
<span class="line">    b <span class="token operator">=</span> temp<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有了这个模板，编译器在遇到对 <code>swap()</code> 的调用时，根据其 <strong>实际参数类型</strong>，自动生成一个相应类型的函数。比如：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器发现 <code>swap()</code> 的实际参数类型为 <code>int</code>，那么就会根据 <code>swap()</code> 的模板，将类型 <code>T</code> 替换为 <code>int</code>，并产生一个 <code>int</code> 版本的 <code>swap()</code>。这个 <strong>根据模板生成函数定义</strong> 的过程由编译器自动完成，不需要开发人员介入。这个过程被称为模板的 <strong>实例化 (instantiation)</strong>。实例化特指从一个抽象的函数定义模板，产生具有实际意义的函数定义的过程。</p><p>基于上述过程可知，模板本身不会产生函数，模板仅用于告诉编译器应当如何产生函数定义。说白了，<strong>模板只是产生函数定义的方案</strong>。如果说整个程序内没有任何一处对 <code>swap()</code> 的实际调用，那么可执行文件内不会有任何实际的 <code>swap()</code> 版本。另外，模板并不能缩短可执行文件的长度：程序内使用了多少种 <code>swap()</code> 的实例化版本，可执行文件内就会有多少种 <code>swap()</code> 的函数定义。</p><p>实例化的过程可被分为：</p><ul><li>隐式实例化：编译器根据实际参数的类型，隐式获得类型参数，并根据模板产生函数的实际定义</li><li>显式实例化：编程人员直接显式指定要产生的函数定义</li></ul><p>同样以上述 <code>swap()</code> 模板为例。当编译器识别到 <code>swap(a, b)</code> 时，能够自动获知 <code>a</code> 和 <code>b</code> 的类型为 <code>int</code>。此时，不需要人为干预，编译器就可以自动生成 <code>swap(int, int)</code> 的函数定义，这就是隐式实例化。而如果代码中出现了显式指定的模板实例化：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token keyword">void</span> <span class="token generic-function"><span class="token function">swap</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>那么编译器将直接为 <code>char</code> 类型生成实际的函数定义 (哪怕该版本的函数定义从未被使用过？)。</p><blockquote><p>注意，不管是隐式 / 显式实例化，用的都是模板的函数体定义，并不需要重新实现一个函数体。</p></blockquote><h2 id="class-template" tabindex="-1"><a class="header-anchor" href="#class-template"><span>Class Template</span></a></h2><p>对于一个类来说，也可以定义模板，用于抽象具有相似功能，但是数据类型不确定的类。一个最经典的例子就是 <strong>容器</strong>。比如实现一个 <code>stack</code> 类及其最基本的入栈、出栈操作，但是栈内盛放的数据类型是不确定的。<code>int</code> 元素可以出入栈，<code>bool</code> 元素也可以。此时，可以使用模板来定义一个类，该类被称为 <strong>模板类</strong>。同样，模板类也只提供 <strong>产生一个实际类的方案</strong>，但不是一个实际的类。</p><p>在类定义上使用 <code>template</code> 来声明模板，相应的类型名称可以在类内使用。类外的成员函数定义中也要使用泛型。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">stack</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line"><span class="token keyword">private</span><span class="token operator">:</span></span>
<span class="line">    <span class="token keyword">enum</span> <span class="token punctuation">{</span> MAX <span class="token operator">=</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">    T items<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// abstract</span></span>
<span class="line">    <span class="token keyword">int</span> top<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">public</span><span class="token operator">:</span></span>
<span class="line">    <span class="token function">stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">bool</span> <span class="token function">is_empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">bool</span> <span class="token function">is_full</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">bool</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// abstract</span></span>
<span class="line">    <span class="token keyword">bool</span> <span class="token function">pop</span><span class="token punctuation">(</span>T <span class="token operator">*</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// abstract</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token class-name">stack</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">bool</span> <span class="token class-name">stack</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>item<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>top <span class="token operator">&lt;</span> MAX<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        items<span class="token punctuation">[</span>top<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// ...</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与函数模板类似，编译器在看到程序中使用了实际的类模板后，将会根据类型参数 <code>T</code> 的实际类型产生 <code>T</code> 类型的 <code>stack</code> 类。比如，程序中的 <code>stack&lt;int&gt;</code> 将会使编译器根据 <code>stack</code> 的类定义将 <code>T</code> 全部替换为 <code>int</code>，从而产生 <code>stack&lt;int&gt;</code> 的类定义。</p><p>除了抽象的类型参数外，模板也支持具体的 <strong>非类型参数</strong> 或 <strong>表达式参数</strong>：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">pair</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样也是允许的。在实际程序中，可以使用 <code>pair&lt;char, 12&gt;</code> 或 <code>pair&lt;string, 19&gt;</code>，使编译器根据模板产生相应的类定义。注意，这里将会产生两个完全不同的类，因为类定义将会因为类型参数和非类型参数而完全不同。表达式参数只支持几种类型：</p><ul><li>整形</li><li>枚举</li><li>引用</li><li>指针</li></ul><p>并且用作表达式参数的值必须是 <strong>常量表达式</strong>，模板代码内不允许对表达式参数进行修改。</p><blockquote><p>在 C++ 98 中，要求至少用一个空白字符将两个 <code>&gt;</code> 隔开，以区别 <code>&gt;&gt;</code> 运算符。比如 <code>stack&lt;array&lt;int&gt;&gt;</code> 就是错误的。C++ 11 中不要求这么做。</p><p>另外，C++ 98 中使用 <code>class</code> 关键字来声明模板类型参数：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>C++ 11 引入 <code>typename</code> 关键字完成相同的功能。但是 <code>class</code> 依旧用于向下兼容。</p></blockquote><h2 id="specialization" tabindex="-1"><a class="header-anchor" href="#specialization"><span>Specialization</span></a></h2><p>模板函数或模板类在满足了通用性的同时，也带来了一个问题：并不是所有数据类型都能完全符合模板内实现的程序语义。假设定义一个用于比较两个元素大小关系的模板，模板内使用 <code>&lt;</code> 运算符进行比较：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">bool</span> <span class="token function">compare</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> T <span class="token operator">&amp;</span>b<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> a <span class="token operator">&lt;</span> b<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 <code>int</code> 来说，实例化后的函数定义是符合语义的；对于 <code>string</code> 来说，由于其 <code>operator&lt;</code> 已经被重载为比较两个字符串大小的语义，因此也是符合的；然而，对于 <code>const char *</code> (常量字符串) 来说，其语义就变成了比较两个指针的地址大小，而不是其指向的字符串的大小。显然，我们需要对 <code>const char *</code> 类型定制一套更具体的模板定义，避免使用默认模板：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token comment">// bool compare(const char *a, const char *b) {</span></span>
<span class="line"><span class="token keyword">bool</span> <span class="token generic-function"><span class="token function">compare</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体化的类模板也是类似。上述行为被称为模板的 <strong>显式具体化 (explicit specialization)</strong>。可以看出，与 <strong>实例化</strong> 的区别在于，具体化需要提供一个新的模板函数体，实现与模板函数不同的逻辑，从而体现特殊化。当编译器发现函数或类与具体化的模板和抽象化的模板同时匹配时，将会优先选择更加具体化的模板。</p><p>C++ 还允许限制部分模板的通用性，即 <strong>部分具体化 (partial specialization)</strong>。部分具体化可以给类型参数指定具体的类型：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出，<code>template &lt;&gt;</code> 内声明了所有的抽象类型参数，而之后的 <code>&lt;&gt;</code> 声明了具体类型参数。由此可见，显式具体化其实是部分具体化的一个特殊情况。如果在部分具体化中为所有的类型参数指定了具体类型，那么就成了显式具体化，<code>template &lt;&gt;</code> 中将没有任何抽象类型参数了：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="priority" tabindex="-1"><a class="header-anchor" href="#priority"><span>Priority</span></a></h2><p>如果程序中的某个函数同时匹配多个模板，编译器将根据优先级选择相应函数。这个过程被称为 <em>重载解析 (overloading resolution)</em>。优先级为：</p><ol><li>常规函数 (非模板函数)</li><li>显式具体化模板函数</li><li>部分具体化模板函数</li><li>抽象模板函数</li></ol><p>显而易见，越具体的函数定义越会被优先匹配。</p>`,45)]))}const i=n(t,[["render",o],["__file","C__ Template _ Genericity.html.vue"]]),r=JSON.parse('{"path":"/notes/C__/C__%20Template%20_%20Genericity.html","title":"C++ - Template & Genericity","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Function Template","slug":"function-template","link":"#function-template","children":[]},{"level":2,"title":"Class Template","slug":"class-template","link":"#class-template","children":[]},{"level":2,"title":"Specialization","slug":"specialization","link":"#specialization","children":[]},{"level":2,"title":"Priority","slug":"priority","link":"#priority","children":[]}],"git":{},"filePathRelative":"notes/C++/C++ Template & Genericity.md"}');export{i as comp,r as data};
