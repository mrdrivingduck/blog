import{_ as s,c as l,a,o as n}from"./app-7eKjwDat.js";const i="/blog/assets/6-1-vXKahoHN.png",d="/blog/assets/6-2-BMuhvVC2.png",c="/blog/assets/6-6-hOfplt5G.png",o="/blog/assets/6-7-BMhmvQ1l.png",t="/blog/assets/6-11-CLfygHkW.png",p="/blog/assets/6-12-D0S03AOz.png",r={};function h(b,e){return n(),l("div",null,e[0]||(e[0]=[a('<h1 id="chapter-6-引导启动程序-boot" tabindex="-1"><a class="header-anchor" href="#chapter-6-引导启动程序-boot"><span>Chapter 6 - 引导启动程序 (boot)</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 08 / 10 22:27</p><p>Ningbo, Zhejiang, China</p><hr><p>描述 <code>boot/</code> 目录下的三个汇编文件：</p><ul><li><code>bootsect.S</code> 和 <code>setup.S</code> 是实地址模式下运行的 16-bit 代码</li><li><code>head.s</code> 运行在保护模式下</li></ul><hr><h2 id="_6-1-总体功能" tabindex="-1"><a class="header-anchor" href="#_6-1-总体功能"><span>6.1 总体功能</span></a></h2><p>PC 上电后，80X86 CPU 将进入实地址模式。执行程序的顺序如下：</p><p><img src="'+i+'" alt="6-1"></p><p>从地址 <code>0xFFFF0</code> 处开始执行代码 (shadow?)：</p><ul><li>BIOS 执行硬件检测和诊断功能</li><li>在物理地址 0 处初始化 BIOS 中断向量</li><li>将可启动设备的第一个扇区读入内存 <code>0x7C00</code> 处，并跳转到这里执行引导</li></ul><p>Linux 中的 <code>boot/bootsect.S</code> 保存在引导设备的第 1 扇区中 (512B)</p><ul><li>由 BIOS 读取至内存 <code>0x7C00</code> (31KB) 处</li><li>执行时，将自身搬运到 <code>0x90000</code> (576KB) 处</li><li>将启动盘第 2、3、4、5 四个扇区 (2KB) 的 <code>boot/setup.S</code> 读取到 <code>0x90200</code> 处</li><li>将 <code>system</code> 模块读取到内存 <code>0x10000</code> (64KB) 处</li><li>跳转到 <code>setup.S</code> 中执行</li></ul><p><code>boot/setup.S</code> 程序保存在第 1 扇区之后的四个扇区中：</p><ul><li>设备主机的某些特性，以及 VGA 卡的类型</li><li>将 <code>system</code> 模块移动到物理内存 0 处</li><li>做好保护模式的设置</li><li>进入保护模式，跳转到 <code>system</code> 模块开头的 <code>head.s</code> 中</li></ul><p><code>boot/head.s</code> (包括 system 模块) 从第 6 扇区开始存放：</p><ul><li>重新设置 IDT、GDT</li><li>检测 A20 地址线、协处理器</li><li>设置分页处理机制</li><li>将预先放置在堆栈中的 <code>/init/main.c</code> 的入口地址弹出，并跳转到该地址运行</li></ul><p><img src="'+d+`" alt="6-2"></p><blockquote><p>为什么要把各部分在内存中搬来搬去呢？</p><ol><li>为什么不把 <code>system</code> 模块直接加载到物理地址 0 处呢？在程序中，读取磁盘、配置机器参数等功能需要用到 BIOS 提供的中断向量，中断向量表位于 <code>0x0</code> 处开始的 1KB 空间内 😥，所以一开始不能覆盖；在 <code>boot/setup.S</code> 程序中，会对中断控制器进行重新设置，从而不再使用 BIOS 中断向量。</li><li>为什么之后又要把 <code>system</code> 模块加载到物理地址 0 处呢？从 0 开始对于初始化来说岂不是更方便嘛 😒。</li></ol></blockquote><p>另外，完整的 Linux 系统还需要一个 <strong>根文件系统 (Root file-system)</strong> 的支持。通常位于另一个存储介质 (分区) 上，在 <code>boot/bootsect.S</code> 中指定根文件系统所在的默认设备块号和 swap 的外部设备号。</p><div class="language-assembly line-numbers-mode" data-highlighter="prismjs" data-ext="assembly" data-title="assembly"><pre><code><span class="line"># 语句从地址 506 (0x1FA) 开始</span>
<span class="line"># swap 空间的设备号为 506、507 两字节</span>
<span class="line"># 根文件系统的设备号为 508、509 两字节</span>
<span class="line"># 第 510、511 两字节为有效引导扇区标志，由 BIOS 加载引导扇区时识别</span>
<span class="line">.org 506</span>
<span class="line">swap_dev:</span>
<span class="line">    .word SWAP_DEV</span>
<span class="line">root_dev:</span>
<span class="line">    .word ROOT_DEV</span>
<span class="line">boot_flag:</span>
<span class="line">    .word 0xAA55</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_6-2-bootsect-s-程序" tabindex="-1"><a class="header-anchor" href="#_6-2-bootsect-s-程序"><span>6.2 bootsect.S 程序</span></a></h2><h3 id="_6-2-1-功能描述" tabindex="-1"><a class="header-anchor" href="#_6-2-1-功能描述"><span>6.2.1 功能描述</span></a></h3><p><code>bootsetc.S</code> 程序驻留在磁盘的第 1 扇区中 (512B)。在 PC 加电，BIOS 自检后，BIOS 会把该扇区代码加载到 <code>0x7c00</code> 处并开始执行：</p><ul><li>在该程序中，会将自身移动到 <code>0x90000</code> 处</li><li>并将从第 2 扇区开始的 4 个扇区的 <code>setup.S</code> 加载到随后的部分 <code>0x90200</code> 处，使用 BIOS 中断 <code>0x13</code></li><li>取出磁盘参数表中当前启动引导盘的参数，使用 BIOS 中断 <code>0x13</code> 功能 8</li><li>在屏幕上显示 <code>Loading system...</code> 字符串，使用 BIOS <code>INT 0x10</code> 的功能 <code>0x03</code> 和 <code>0x13</code></li><li>将磁盘上 <code>setup.S</code> 之后的 <code>system</code> 模块加载到内存 <code>0x10000</code> 处 (64KB 位置)</li><li>确定根文件系统的设备号，取 508、509 字节并判断是否被定义</li><li>长跳转到 <code>setup</code> 程序的入口处</li></ul><h3 id="_6-2-2-代码注释" tabindex="-1"><a class="header-anchor" href="#_6-2-2-代码注释"><span>6.2.2 代码注释</span></a></h3><blockquote><p>汇编不太有意思。。。 😑</p></blockquote><h3 id="_6-2-3-其它信息" tabindex="-1"><a class="header-anchor" href="#_6-2-3-其它信息"><span>6.2.3 其它信息</span></a></h3><h4 id="_6-2-3-1-linux-0-12-硬盘设备号" tabindex="-1"><a class="header-anchor" href="#_6-2-3-1-linux-0-12-硬盘设备号"><span>6.2.3.1 Linux 0.12 硬盘设备号</span></a></h4><p>Linux 系统中通过设备号来使用各种设备。设备号包含两个字节：</p><ul><li>第一字节为主设备号，指定了设备种类</li><li>第二字节为次设备号，指定了具体的设备对象</li></ul><table><thead><tr><th>主设备号</th><th>设备种类</th></tr></thead><tbody><tr><td>1</td><td>内存</td></tr><tr><td>2</td><td>磁盘</td></tr><tr><td>3</td><td>硬盘</td></tr><tr><td>4</td><td>ttyx</td></tr><tr><td>5</td><td>tty</td></tr><tr><td>6</td><td>并行接口</td></tr><tr><td>7</td><td>非命名管道</td></tr></tbody></table><h4 id="_6-2-3-2-从硬盘启动系统" tabindex="-1"><a class="header-anchor" href="#_6-2-3-2-从硬盘启动系统"><span>6.2.3.2 从硬盘启动系统</span></a></h4><p>如果想从硬盘启动，则需要使用多 OS 引导程序来引导加载系统：</p><ul><li>Shoelace</li><li>LILO</li><li>Grub</li><li>...</li></ul><p>此时，<code>bootsect.S</code> 所执行的操作将由这些程序完成，该文件就不会被执行了。通常，内核映像文件 image 会存放在硬盘某个活动分区的根文件系统中。因此引导扇区程序需要能够 <strong>识别</strong> 并 <strong>访问</strong> 根文件系统，从中读取 image。过程：</p><ol><li>可启动硬盘的第 1 扇区 (主引导记录 MBR) 被 BIOS 加载到 <code>0x7c00</code> 并执行</li><li>该程序将自己移动到 <code>0x600</code> 处，并根据 MBR 中的分区表指明的活动分区中的 第 1 扇区 (引导扇区) 加载到 <code>0x7c00</code> 处，然后开始执行</li></ol><hr><h2 id="_6-3-setup-s-程序" tabindex="-1"><a class="header-anchor" href="#_6-3-setup-s-程序"><span>6.3 setup.S 程序</span></a></h2><h3 id="_6-3-1-功能描述" tabindex="-1"><a class="header-anchor" href="#_6-3-1-功能描述"><span>6.3.1 功能描述</span></a></h3><p>首先，利用 BIOS 的中断读取系统数据，并将这些数据保存到从 <code>0x90000</code> 开始的位置。覆盖掉 bootsect 程序所在的地方，这些参数将被内核中的相关程序使用。接下来，将 <code>system</code> 模块从 <code>0x10000-0x8ffff</code> 整块向下移动到 <code>0x00000</code> 处，再加载 IDTR 和 GDTR。</p><blockquote><p>GDT 是临时的？</p></blockquote><p>开启 A20 地址线，为了能够访问 1M 以上的地址空间。重新设置两个中断控制芯片 8259A，放置在 Intel 的保留中断之后，即 <code>INT 0x20 - 0x2f</code>。最后设置 CPU 的 CR0 寄存器，进入 32-bit 保护模式，跳转到 <code>system</code> 模块最前面的 <code>head.s</code> 继续运行 (<code>0x00000</code>)。</p><blockquote><p>进入保护模式之前，不对任何寄存器进行设置，只是简单地跳转到绝对地址 0x00000 处。</p></blockquote><h3 id="_6-3-2-代码注释" tabindex="-1"><a class="header-anchor" href="#_6-3-2-代码注释"><span>6.3.2 代码注释</span></a></h3><h3 id="_6-3-3-其它信息" tabindex="-1"><a class="header-anchor" href="#_6-3-3-其它信息"><span>6.3.3 其它信息</span></a></h3><h4 id="_6-3-3-1-当前内存映像" tabindex="-1"><a class="header-anchor" href="#_6-3-3-1-当前内存映像"><span>6.3.3.1 当前内存映像</span></a></h4><p><img src="`+c+`" alt="6-6"></p><p>此时临时的 GDT 表总有三个描述符：</p><ul><li>第一个描述符为 NULL</li><li>另外两个分别是代码段描述符和数据段描述符，指向 <code>system</code> 模块起始处</li></ul><p>因此，在进入保护模式后：</p><div class="language-assembly line-numbers-mode" data-highlighter="prismjs" data-ext="assembly" data-title="assembly"><pre><code><span class="line">mov ax, 0x0001 # 保护模式 PE 位</span>
<span class="line">lmsw ax</span>
<span class="line">jmpi 0, 8</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>段选择符 8 - 0b 0000, 0000, 0000, 1000。使用 GDT 中的第二个段描述符，偏移为 0，即指向 <code>0x00000</code>。</p><h4 id="_6-3-3-2-bios-视频中断-0x10" tabindex="-1"><a class="header-anchor" href="#_6-3-3-2-bios-视频中断-0x10"><span>6.3.3.2 BIOS 视频中断 0x10</span></a></h4><h4 id="_6-3-3-3-硬盘基本参数表-int-0x41" tabindex="-1"><a class="header-anchor" href="#_6-3-3-3-硬盘基本参数表-int-0x41"><span>6.3.3.3 硬盘基本参数表 (INT 0x41)</span></a></h4><h4 id="_6-3-3-4-a20-地址线问题" tabindex="-1"><a class="header-anchor" href="#_6-3-3-4-a20-地址线问题"><span>6.3.3.4 A20 地址线问题</span></a></h4><p>一开始的 8088 CPU 只有 20 位地址线 (A0 - A19)，CPU 最多可寻址 1MB 的内存范围。最高可寻址处是 <code>0xffff:0xffff</code>，即 <code>0x10ffef</code>。对于其中超出 1MB 的内存地址，默认环绕寻址 <code>0x00000 - 0x0ffef</code>。</p><p>新的 CPU 有了更多的地址线，但部分程序已经被设计成利用这种环绕寻址来进行工作。为了兼容，IBM 使用一个开关来开启或禁止环绕寻址，即 A20 信号：若 A20 为 0，则 20-bit 以上的地址都被清除，实现兼容；默认条件下 A20 是禁止的。因此，32-bit 机器的 OS 必须设法启用它。</p><h4 id="_6-3-3-5-8259a-中断控制器的编程方法" tabindex="-1"><a class="header-anchor" href="#_6-3-3-5-8259a-中断控制器的编程方法"><span>6.3.3.5 8259A 中断控制器的编程方法</span></a></h4><p><img src="`+o+`" alt="6-7"></p><p>中断请求寄存器 IRR 用于保存所有引脚的中断请求，共 8-bit；中断屏蔽寄存器 IMR 用于屏蔽对应的中断位，也是 8-bit。优先级解析器 PR 选通 IRR 中最高优先级的中断请求到正在服务寄存器 ISR，ISR 中保存正在接受服务的中断请求。</p><p>控制逻辑用于接受 CPU 产生的两类命令：</p><ul><li>初始化命令字 ICW</li><li>写入操作命令字 OCW：随时管理和控制 8259A 的工作方式</li></ul><p>工作过程：</p><ol><li>在选出最高优先级的中断请求后，向 CPU 发出 INT 信号</li><li>CPU 执行完当前的最后一条指令后，向 8259A 返回 INTA 响应中断信号</li><li>8259A 接收到 INTA 后，将中断保存在 ISR 中，IRR 中对应 bit 被复位</li><li>CPU 向 8259A 发送第二个 INTA 信号，8259A 将中断号发送到数据总线上</li><li>如果 8259A 使用的是自动结束中断 AEOI (Automatic End of Interrupt) 方式，那么第 2 个 INTA 信号结束后，ISR 中的 bit 位被复位；否则，中断服务程序结束后，CPU 发送 EOI 命令表示中断结束，复位 ISR 中的 bit 位</li></ol><hr><h2 id="_6-4-head-s-程序" tabindex="-1"><a class="header-anchor" href="#_6-4-head-s-程序"><span>6.4 head.s 程序</span></a></h2><h3 id="_6-4-1-功能描述" tabindex="-1"><a class="header-anchor" href="#_6-4-1-功能描述"><span>6.4.1 功能描述</span></a></h3><p><code>head.s</code> 被编译成目标文件后，与内核其它程序一起被链接为 <code>system</code> 模块，并位于 <code>system</code> 模块的最前面开始的部分。从此程序开始，内核完全运行在了保护模式下。</p><p>这段程序位于内存 <code>0x00000</code> 处，首先加载各个数据段寄存器，重新设置了 IDT 表，共 256 项，使每个项均指向一个哑中断子程序 <code>ignore_int</code> (初始化)。如果发生了一个没有重新设置过的中断，就会显示 <code>Unknown interrupt</code>。内核会在接下来的初始化过程中，陆续重新设置需要使用到的中断描述符。</p><p>重新设置了 GDT 表，将 GDT 表放在内存内核代码中比较合理的地方。检测 A20 地址线是否已开启，检测 PC 中是否含有数学协处理器芯片，设置分页管理机制：在 <code>0x00000</code> 处放置页目录表 (覆盖已经执行的 head.s)，紧随其后放置可寻址 16MB 的 4 个页表。</p><p>最后，利用 RET 指令将预先放置在堆栈中的 <code>init/main.c</code> 程序的入口地址弹出，相当于模拟 <code>main.c</code> 调用了一个子函数，因此返回到 <code>main.c</code> 的地址被保存在堆栈中。执行 RET 后，该返回地址被弹出 - 返回地址是 <code>main.c</code> 的第一条指令。</p><p>开始执行 <code>main()</code> 程序。</p><h3 id="_6-4-2-代码注释" tabindex="-1"><a class="header-anchor" href="#_6-4-2-代码注释"><span>6.4.2 代码注释</span></a></h3><p>分页准备部分：</p><div class="language-assembly line-numbers-mode" data-highlighter="prismjs" data-ext="assembly" data-title="assembly"><pre><code><span class="line"># 在物理地址 0x0 处开始放置页目录表和页表，共 5 页</span>
<span class="line"># 4 页页表为内核专用，一一映射线性地址起始 16MB 空间范围到物理地址上</span>
<span class="line">.align 2</span>
<span class="line">setup_paging:</span>
<span class="line">    movl $1024*5, %ecx # 对 5 页内存清零</span>
<span class="line">    xorl %eax, %eax</span>
<span class="line">    xorl %edi, %edi</span>
<span class="line">    cld;rep;stosl</span>
<span class="line">    </span>
<span class="line"># 设置页目录表中的项</span>
<span class="line"># 4 个页表，因此只需要设置 4 个页目录项，4B 一项</span>
<span class="line">    movl $pg0+7, _pg_dir</span>
<span class="line">    movl $pg1+7, _pg_dir+4</span>
<span class="line">    movl $pg2+7, _pg_dir+8</span>
<span class="line">    movl $pg3+7, _pg_dir+12</span>
<span class="line">    </span>
<span class="line"># 填写 4 个页表中所有项的内容，共 4096 项</span>
<span class="line"># 即映射物理内存 4096 × 4KB = 16MB</span>
<span class="line"># 从最后一个页表的最后一项开始倒退顺序填写</span>
<span class="line">    movl $pg3+4092, %edi # 最后一页最后一项</span>
<span class="line">    movl $0xfff007, %eax</span>
<span class="line">    std</span>
<span class="line">1:  stosl</span>
<span class="line">    subl $0x1000, %eax</span>
<span class="line">    jge 1b # 小于 0 则填写完毕</span>
<span class="line">    </span>
<span class="line"># 设置页目录表基地址寄存器 CR3，指向页目录表</span>
<span class="line"># 设置 CR0 中的 PG 标志，开启分页处理</span>
<span class="line">    xorl %eax, %eax</span>
<span class="line">    movl %eax, %cr3</span>
<span class="line">    movl %cr0, %eax</span>
<span class="line">    orl $0x80000000, %eax</span>
<span class="line">    movl %eax, %cr0</span>
<span class="line">    ret</span>
<span class="line"># 改变 PG 标志后需要使用转移指令刷新指令预取队列</span>
<span class="line"># 同时弹出 main() 的地址，并跳转到 main() 中运行</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-4-3-其它信息" tabindex="-1"><a class="header-anchor" href="#_6-4-3-其它信息"><span>6.4.3 其它信息</span></a></h3><h4 id="_6-4-3-1-程序执行结束后的内存映像" tabindex="-1"><a class="header-anchor" href="#_6-4-3-1-程序执行结束后的内存映像"><span>6.4.3.1 程序执行结束后的内存映像</span></a></h4><p><img src="`+t+'" alt="6-11"></p><h4 id="_6-4-3-2-intel-32-位保护运行机制" tabindex="-1"><a class="header-anchor" href="#_6-4-3-2-intel-32-位保护运行机制"><span>6.4.3.2 Intel 32 位保护运行机制</span></a></h4><p>32 位保护模式下的内存寻址方式需要拐个弯，使用描述符表中的描述符和内存页管理来确定。当 CPU 运行在保护模式下，某时刻 GDT 和 IDT 分别只能有一个，LDT 的个数由 GDT 表中的未用项数和所设计的具体系统确定。LDT 由 GDT 中的一个描述符来指定，内核对于每个任务使用一个 LDT。</p><p>每个任务在 GDT 中占有两个描述符项：</p><ul><li>LDT 的描述符 - 每个 LDT 中含有三个描述符： <ul><li>第一个不用</li><li>第二个是任务代码段描述符</li><li>第三个是任务数据段和堆栈段的描述符</li></ul></li><li>TSS 的描述符</li></ul><p>寻址时的具体过程如图：</p><p><img src="'+p+'" alt="6-12"></p><ul><li>由 GDTR 找到 GDT，根据偏移量找到 LDT 描述符，将 LDT 基地址载入 LDTR (并缓存)</li><li>LDTR 指向 LDT 表对应的段，其中 CS 段寄存器指向其中的任务代码段描述符，DS 段寄存器指向其中的任务数据 &amp; 堆栈段描述符</li><li>访问数据时，根据 LDT 中的段描述符找到对应的段基址，加上偏移量后形成最终的线性地址</li></ul><h4 id="_6-4-3-3-伪指令-align" tabindex="-1"><a class="header-anchor" href="#_6-4-3-3-伪指令-align"><span>6.4.3.3 伪指令 align</span></a></h4><p>在编译时指示编译器填充位置计数器 (指令计数器) 到一个指定的内存边界处。</p>',91)]))}const v=s(r,[["render",h],["__file","Chapter 6 - 引导启动程序 (boot).html.vue"]]),m=JSON.parse('{"path":"/linux-kernel-comments-notes/Chapter%206%20-%20%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%20(boot)/Chapter%206%20-%20%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%20(boot).html","title":"Chapter 6 - 引导启动程序 (boot)","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"6.1 总体功能","slug":"_6-1-总体功能","link":"#_6-1-总体功能","children":[]},{"level":2,"title":"6.2 bootsect.S 程序","slug":"_6-2-bootsect-s-程序","link":"#_6-2-bootsect-s-程序","children":[{"level":3,"title":"6.2.1 功能描述","slug":"_6-2-1-功能描述","link":"#_6-2-1-功能描述","children":[]},{"level":3,"title":"6.2.2 代码注释","slug":"_6-2-2-代码注释","link":"#_6-2-2-代码注释","children":[]},{"level":3,"title":"6.2.3 其它信息","slug":"_6-2-3-其它信息","link":"#_6-2-3-其它信息","children":[]}]},{"level":2,"title":"6.3 setup.S 程序","slug":"_6-3-setup-s-程序","link":"#_6-3-setup-s-程序","children":[{"level":3,"title":"6.3.1 功能描述","slug":"_6-3-1-功能描述","link":"#_6-3-1-功能描述","children":[]},{"level":3,"title":"6.3.2 代码注释","slug":"_6-3-2-代码注释","link":"#_6-3-2-代码注释","children":[]},{"level":3,"title":"6.3.3 其它信息","slug":"_6-3-3-其它信息","link":"#_6-3-3-其它信息","children":[]}]},{"level":2,"title":"6.4 head.s 程序","slug":"_6-4-head-s-程序","link":"#_6-4-head-s-程序","children":[{"level":3,"title":"6.4.1 功能描述","slug":"_6-4-1-功能描述","link":"#_6-4-1-功能描述","children":[]},{"level":3,"title":"6.4.2 代码注释","slug":"_6-4-2-代码注释","link":"#_6-4-2-代码注释","children":[]},{"level":3,"title":"6.4.3 其它信息","slug":"_6-4-3-其它信息","link":"#_6-4-3-其它信息","children":[]}]}],"git":{},"filePathRelative":"linux-kernel-comments-notes/Chapter 6 - 引导启动程序 (boot)/Chapter 6 - 引导启动程序 (boot).md"}');export{v as comp,m as data};
