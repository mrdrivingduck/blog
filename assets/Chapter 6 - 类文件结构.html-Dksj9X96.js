import{_ as l,c as a,a as i,o as n}from"./app-BeHGwf2X.js";const s={};function c(o,e){return n(),a("div",null,e[0]||(e[0]=[i(`<h1 id="chapter-6-类文件结构" tabindex="-1"><a class="header-anchor" href="#chapter-6-类文件结构"><span>Chapter 6 - 类文件结构</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 01 / 28 16:57 🧨🧧</p><p>Ningbo, Zhejiang, China</p><hr><h2 id="_6-2-无关性的基石" tabindex="-1"><a class="header-anchor" href="#_6-2-无关性的基石"><span>6.2 无关性的基石</span></a></h2><p>Java 的口号：<em>Write Once, Run Anywhere.</em>。</p><p>Java 平台无关性的基石：</p><ul><li>各种不同平台的 JVM</li><li>所有平台统一支持的程序存储格式 - 字节码 (Byte Code)</li></ul><p>在 Java 技术发展之初，设计者们考虑并实现了让其它语言运行在 JVM 之上的可能性，Java 的规范被拆分为：</p><ul><li>Java 语言规范</li><li>Java 虚拟机规范</li></ul><p>目前，除 Java 外，发展出了大批运行在 JVM 上的语言</p><ul><li>Kotlin</li><li>Clojure</li><li>Groovy</li><li>JRuby</li><li>JPython</li><li>Scala</li></ul><p>任何语言都可以把 JVM 作为语言的运行基础，以 Class 文件作为语言执行的交付媒介。JVM 不关心 Class 文件的来源是什么语言。Java 语言中的各种语法、关键字等语义最终都会由多条字节码指令组合来表达。</p><hr><h2 id="_6-3-class-类文件的结构" tabindex="-1"><a class="header-anchor" href="#_6-3-class-类文件的结构"><span>6.3 Class 类文件的结构</span></a></h2><p>Class 文件结构相当稳定，基本上只会在原有结构基础上新增内容、扩充功能。以 8 个字节为基础单位的二进制流，中间没有任何分隔符，只有两种数据类型：</p><ul><li>无符号数 - <code>u1</code> <code>u2</code> <code>u4</code> <code>u8</code></li><li>表 - 由多个无符号数或表构成</li></ul><p>当需要描述同一类型但数量不定的多个数据时，前置一个容量计数器，后面紧跟多个数据项。</p><p>文件结构：</p><ol><li>magic - 魔数</li><li>minor_version - 文件次版本</li><li>major_version - 文件主版本</li><li>constant_pool_count - 常量池计数值</li><li>constant_pool - 常量池</li><li>access_flags - 访问标志</li><li>this_class - 类索引</li><li>super_class - 父类索引</li><li>interfaces_count - 接口索引计数值</li><li>interfaces - 接口索引</li><li>fields_count - 字段表计数值</li><li>fields - 字段表</li><li>methods_count - 方法表计数值</li><li>methods - 方法表</li><li>attributes_count - 属性表计数值</li><li>attributes - 属性表</li></ol><h3 id="_6-3-1-魔数与-class-文件的版本" tabindex="-1"><a class="header-anchor" href="#_6-3-1-魔数与-class-文件的版本"><span>6.3.1 魔数与 Class 文件的版本</span></a></h3><p>魔数占头四个字节 - <code>0xCAFEBABE</code>，紧接的四个字节是版本号：</p><ul><li>前两个字节是次版本号</li><li>后两个字节是主版本号 (从 <code>45</code> (JDK 1.1) 开始)</li></ul><h3 id="_6-3-2-常量池" tabindex="-1"><a class="header-anchor" href="#_6-3-2-常量池"><span>6.3.2 常量池</span></a></h3><p>是 Class 文件中的资源仓库，与 Class 文件结构中其它项目关联最多的数据。其数量不固定，因此放置了一个 <code>u2</code> 类型的常量池计数值。</p><p>常量池的计数是从 <code>1</code> 开始的 (如 22)，那么常量池中有 1 - 21 项常量。第 <code>0</code> 项代表不引用任何常量池项目。</p><p>常量池存放两类常量：</p><ul><li>字面量 (Literal)</li><li>符号引用 (Symbolic References) <ul><li>包 (Package)</li><li>类和接口的全限定名 (Fully Qualified Name)</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li><li>方法句柄和方法类型</li><li>动态调用点和动态常量</li></ul></li></ul><p>常量池中的每一项常量都是一个表。表结构的起始第一位是一个 <code>u1</code> 类型的标志，代表常量的类型。之后是常量的具体内容。不同的常量类型有着不同的结构：</p><ul><li><code>CONSTANT_Utf8_info</code></li><li><code>CONSTANT_Interger_info</code></li><li><code>CONSTANT_Float_info</code></li><li>...</li></ul><blockquote><p>Oracle 提供了 <code>javap</code> 工具用于分析字节码内容。</p></blockquote><h3 id="_6-3-3-访问标志" tabindex="-1"><a class="header-anchor" href="#_6-3-3-访问标志"><span>6.3.3 访问标志</span></a></h3><p>识别类或接口层次的信息：</p><ul><li>是类还是接口？</li><li>是否为 <code>public</code></li><li>是否为 <code>abstract</code></li><li>是否被声明为 <code>final</code></li><li>...</li></ul><h3 id="_6-3-4-类索引、父类索引与接口索引集合" tabindex="-1"><a class="header-anchor" href="#_6-3-4-类索引、父类索引与接口索引集合"><span>6.3.4 类索引、父类索引与接口索引集合</span></a></h3><p>Class 文件通过这三项数据确定该类型的继承关系：</p><ul><li>类索引确定该类的全限定名</li><li>父类索引确定该类父类的全限定名 (Java 不允许多继承)</li></ul><p>除了 <code>java.lang.Object</code> 外，父类索引都不为 <code>0</code>。</p><p>接口索引描述该类实现了哪些接口，按 <code>implement</code> 关键字后的接口顺序从左到右排列在接口索引集合中。实现的接口数量不定，所以存在接口索引集合开头有一个计数器。索引指向常量池中的类描述符常量。</p><h3 id="_6-3-5-字段表集合" tabindex="-1"><a class="header-anchor" href="#_6-3-5-字段表集合"><span>6.3.5 字段表集合</span></a></h3><p>描述接口或类中声明的变量：</p><ul><li>类级变量</li><li>实例级变量</li></ul><p>字段的结构体定义为：</p><ul><li><code>access_flags</code><ul><li>作用域 <code>public</code> <code>private</code> <code>protected</code></li><li>是实例变量还是类变量 <code>static</code></li><li>可变性 <code>final</code></li><li>并发可见性 <code>volatile</code> (是否强制从主内存读写)</li><li>是否可被序列化 <code>transient</code></li><li>...</li></ul></li><li><code>name_index</code><ul><li>指向常量池中的字段简单名称 (没有类型和参数修饰的字段名称)</li></ul></li><li><code>descriptor_index</code><ul><li>指向常量池中的描述符</li></ul></li><li><code>attributes_count</code> (属性表，可选)</li><li><code>attributes</code></li></ul><p>字段表集合不会列出从父类继承而来的字段。</p><h3 id="_6-3-6-方法表集合" tabindex="-1"><a class="header-anchor" href="#_6-3-6-方法表集合"><span>6.3.6 方法表集合</span></a></h3><p>描述类或接口中定义的函数：</p><ul><li><code>access_flags</code><ul><li>作用域 <code>public</code> <code>private</code> <code>protected</code></li><li>是实例变量还是类变量 <code>static</code></li><li>可变性 <code>final</code></li><li><code>synchronized</code> <code>native</code> <code>strictfp</code> <code>abstract</code></li></ul></li><li><code>name_index</code><ul><li>指向常量池中的函数简单名称 (没有类型和参数修饰的字段名称)</li></ul></li><li><code>descriptor_index</code><ul><li>指向常量池中的描述符</li></ul></li><li><code>attributes_count</code> (属性表，可选)</li><li><code>attributes</code></li></ul><p>函数中的 Java 代码经过 <code>javac</code> 编译为字节码后，存放在方法属性表的 <code>Code</code> 属性下。如果父类方法在子类中没有被 override，方法表中就不会出现来自父类的方法信息。另外，在 Java 中，如果要重载一个函数，需要满足：</p><ul><li>与原方法具有相同的简单名称</li><li>要与原方法有不同的 <strong>特征签名</strong><ul><li>指一个方法中各个参数在常量池中的字段符号引用的集合</li><li>返回值不包含在特征签名中</li></ul></li></ul><p>因此 Java 无法只通过返回值来对一个已有的方法进行重载。</p><h3 id="_6-3-7-属性表集合" tabindex="-1"><a class="header-anchor" href="#_6-3-7-属性表集合"><span>6.3.7 属性表集合</span></a></h3><p>每个属性项的结构：</p><ul><li>attribute_name_index <ul><li>属性名称</li><li>从常量池中引用一个 <code>CONSTANT_Utf8_info</code> 类型的常量</li></ul></li><li>attribute_length <ul><li>属性值的长度</li></ul></li><li>info <ul><li>属性值</li><li>结构可以完全自定义</li></ul></li></ul><p>使用这些属性项的位置也不同。有些在方法表中使用，有些在字段表中使用...</p><h4 id="_6-3-7-1-code-属性" tabindex="-1"><a class="header-anchor" href="#_6-3-7-1-code-属性"><span>6.3.7.1 Code 属性</span></a></h4><p>并非所有的方法都有该属性 (比如接口或抽象类)</p><ul><li><code>attribute_name_index</code><ul><li>指向 <code>CONSTANT_Utf8-info</code> 型常量索引 (固定为 <code>Code</code>)</li></ul></li><li><code>attribute_length</code> - 属性值长度</li><li><code>max_stack</code><ul><li>操作数栈深度的最大值</li></ul></li><li><code>max_locals</code><ul><li>局部变量表所需的存储空间</li><li>单位是变量槽 (JVM 为局部变量分配内存所使用的最小单位)</li></ul></li><li><code>code_length</code></li><li><code>code</code> - 字节码</li><li><code>exception_table_length</code></li><li><code>exception_table</code> - 显式异常处理表</li><li><code>attributes_count</code></li><li><code>attributes</code></li></ul><p>其中的异常表用于处理 <code>try-catch-finally</code>。异常表的结构为：</p><ul><li><code>start_pc</code></li><li><code>end_pc</code></li><li><code>handler_pc</code></li><li><code>catch_type</code></li></ul><p>含义为，当字节码 <code>start_pc</code> 到 <code>end_pc</code> 之间出现 <code>catch_type</code> 或其子类的异常，则转到 <code>handler_pc</code> 行处理；当 <code>catch_type</code> 的值为 0 时，任意异常情况都要转到 <code>handler_pc</code> 处理。</p><p>一个例子：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">int</span> x<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">        x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">return</span> x<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">return</span> x<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span></span>
<span class="line">        x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>如果程序正常运行，执行 <code>x = 1;</code> 后保存在返回值的变量槽中 <ul><li>执行 <code>x = 3;</code> 后，将返回值变量槽中的 <code>1</code> 读入操作栈顶并返回</li></ul></li><li>如果程序异常 <ul><li>转入 <code>x = 2;</code> 后保存在返回值的变量槽中</li><li>执行 <code>x = 3;</code> 后，将返回值变量槽中的 <code>2</code> 读入操作栈顶并返回</li></ul></li></ul><h4 id="_6-3-7-2-exceptions-属性" tabindex="-1"><a class="header-anchor" href="#_6-3-7-2-exceptions-属性"><span>6.3.7.2 Exceptions 属性</span></a></h4><p>与 Code 属性中的异常表不同，作用是列举出函数中可能抛出的受查异常 (Checked Exceptions)，也就是函数描述时 <code>throws</code> 关键字后面列举的异常。</p><h4 id="_6-3-7-3-linenumbertable-属性" tabindex="-1"><a class="header-anchor" href="#_6-3-7-3-linenumbertable-属性"><span>6.3.7.3 LineNumberTable 属性</span></a></h4><p>描述 Java 源码行号与字节码行号之间的对应关系，用于在抛出异常时，显示在 Java 程序中的出错行号。</p><h4 id="_6-3-7-4-localvariabletable-及-localvariabletypetable-属性" tabindex="-1"><a class="header-anchor" href="#_6-3-7-4-localvariabletable-及-localvariabletypetable-属性"><span>6.3.7.4 LocalVariableTable 及 LocalVariableTypeTable 属性</span></a></h4><p>描述栈帧中局部变量表中的变量与 Java 源代码中定义变量之间的关系。如果没有这个属性，当别人引用这个方法时，所有的参数名称将会丢失：比如 IDE 中自动填充的 <code>arg0</code> <code>arg1</code>。</p><h4 id="_6-3-7-5-sourcefile-及-sourcedebugextension-属性" tabindex="-1"><a class="header-anchor" href="#_6-3-7-5-sourcefile-及-sourcedebugextension-属性"><span>6.3.7.5 SourceFile 及 SourceDebugExtension 属性</span></a></h4><p>记录生成这个 Class 文件的源码文件名称。如果没有这个属性，抛出异常时，堆栈中将不会显示出错代码所属的文件名。</p><h4 id="_6-3-7-6-constantvalue-属性" tabindex="-1"><a class="header-anchor" href="#_6-3-7-6-constantvalue-属性"><span>6.3.7.6 ConstantValue 属性</span></a></h4><p>通知虚拟机自动为静态变量赋值，只有被 <code>static</code> 关键字修饰的变量才能用这种属性。</p><h4 id="_6-3-7-7-innerclasses-属性" tabindex="-1"><a class="header-anchor" href="#_6-3-7-7-innerclasses-属性"><span>6.3.7.7 InnerClasses 属性</span></a></h4><p>记录内部类与宿主类之前的关联。属性的结构：</p><ul><li><code>attribute_name_index</code> - 对应常量池中的 <code>InnerClasses</code></li><li><code>attribute_length</code></li><li><code>number_of_classes</code></li><li><code>inner_classes</code></li></ul><p>每个内部类属性值的结构如下：</p><ul><li><code>inner_class_info_index</code><ul><li>指向常量池中的 <code>CONSTANT_Class_info</code> 类型常量的索引</li><li>代表内部类</li></ul></li><li><code>outer_class_info_index</code><ul><li>同上</li><li>代表宿主类</li></ul></li><li><code>inner_name_index</code><ul><li>指向常量池中 <code>CONSTANT_Utf8_info</code> 类型常量的索引</li><li>如果是匿名内部类，值为 <code>0</code></li></ul></li><li><code>inner_class_access_flags</code><ul><li>内部类的访问标志</li></ul></li></ul><h4 id="_6-3-7-8-deprecated-及-synthetic-属性" tabindex="-1"><a class="header-anchor" href="#_6-3-7-8-deprecated-及-synthetic-属性"><span>6.3.7.8 Deprecated 及 Synthetic 属性</span></a></h4><h4 id="_6-3-7-9-stackmaptable-属性" tabindex="-1"><a class="header-anchor" href="#_6-3-7-9-stackmaptable-属性"><span>6.3.7.9 StackMapTable 属性</span></a></h4><h4 id="_6-3-7-10-signature-属性" tabindex="-1"><a class="header-anchor" href="#_6-3-7-10-signature-属性"><span>6.3.7.10 Signature 属性</span></a></h4><h4 id="_6-3-7-11-bootstrapmethods-属性" tabindex="-1"><a class="header-anchor" href="#_6-3-7-11-bootstrapmethods-属性"><span>6.3.7.11 BootstrapMethods 属性</span></a></h4><h4 id="_6-3-7-12-methodparameters-属性" tabindex="-1"><a class="header-anchor" href="#_6-3-7-12-methodparameters-属性"><span>6.3.7.12 MethodParameters 属性</span></a></h4><p>记录方法的各个形参名称和信息。之前的 LocalVariableTable 属性是 Code 属性的子属性，这意味着没有方法体就没有局部属性表。而对于接口或抽象方法来说，是可以不存在方法体的，该属性可以将方法中的参数信息保存下来。</p><hr><h2 id="_6-4-字节码指令简介" tabindex="-1"><a class="header-anchor" href="#_6-4-字节码指令简介"><span>6.4 字节码指令简介</span></a></h2><p>JVM 的指令由一个字节长度的操作码，以及跟随其后的 0 或多个操作数构成。大多数指令都不包含操作数，只有一个操作码。JVM 采用 <strong>面向操作数栈</strong> 而不是面向寄存器的架构，指令参数都放在操作数栈中。由于限制了操作码为 1 字节，因此操作码总数不能超过 256 条。</p><h3 id="_6-4-1-字节码与数据类型" tabindex="-1"><a class="header-anchor" href="#_6-4-1-字节码与数据类型"><span>6.4.1 字节码与数据类型</span></a></h3><p>大多数指令都包含操作对应的数据类型信息，比如 <code>iload</code> <code>fload</code> <code>dload</code>。但是由于操作码的长度有限，不可能为每条指令都提供不同数据类型的版本。因此 JVM 针对特定的操作只提供了有限数据类型的指令，这种特性称为 <em>Not Orthogonal</em>。编译器会在编译器或运行期作如下转换：</p><ul><li><code>byte</code> 和 <code>short</code> 类型的数据带符号扩展为 <code>int</code></li><li><code>boolean</code> 和 <code>char</code> 类型的数据零扩展为 <code>int</code></li><li>然后统一使用 <code>int</code> 版本的指令来操作</li></ul><h3 id="_6-4-2-加载和存储指令" tabindex="-1"><a class="header-anchor" href="#_6-4-2-加载和存储指令"><span>6.4.2 加载和存储指令</span></a></h3><p>用于将数据在栈帧中的 <strong>局部变量表</strong> 和 <strong>操作数栈</strong> 之间来回传输。</p><h3 id="_6-4-3-运算指令" tabindex="-1"><a class="header-anchor" href="#_6-4-3-运算指令"><span>6.4.3 运算指令</span></a></h3><p>对两个操作数栈上的值进行某种特定运算，并将结果重新存入到操作栈顶。</p><h3 id="_6-4-4-类型转换指令" tabindex="-1"><a class="header-anchor" href="#_6-4-4-类型转换指令"><span>6.4.4 类型转换指令</span></a></h3><p>用于用户代码中的显式类型转换。JVM 直接支持小范围类型向大范围类型的安全转换。转换指令用于处理窄化类型转换：</p><ul><li>可能产生不同正负号</li><li>可能导致精度丢失</li></ul><h3 id="_6-4-5-对象创建与访问指令" tabindex="-1"><a class="header-anchor" href="#_6-4-5-对象创建与访问指令"><span>6.4.5 对象创建与访问指令</span></a></h3><p>类实例和数组都是对象，但是创建与操作使用了不同的字节码指令。</p><h3 id="_6-4-6-操作数栈管理指令" tabindex="-1"><a class="header-anchor" href="#_6-4-6-操作数栈管理指令"><span>6.4.6 操作数栈管理指令</span></a></h3><p>JVM 提供用于直接操作操作数栈的指令。</p><h3 id="_6-4-7-控制转移指令" tabindex="-1"><a class="header-anchor" href="#_6-4-7-控制转移指令"><span>6.4.7 控制转移指令</span></a></h3><p>对于 <code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code> 类型的条件分支操作，都使用 <code>int</code> 类型的分支指令完成。对于 <code>long</code>、<code>float</code>、<code>double</code> 类型的条件分支比较，则先执行相应类型的分支比较指令，指令返回一个 <code>int</code> 型到操作数栈中，随后再执行 <code>int</code> 型的条件分支比较完成分支跳转。</p><p>JVM 提供的 <code>int</code> 型的条件分支指令是最为丰富、强大的。</p><h3 id="_6-4-8-方法调用和返回指令" tabindex="-1"><a class="header-anchor" href="#_6-4-8-方法调用和返回指令"><span>6.4.8 方法调用和返回指令</span></a></h3><ul><li>invokevirtual 指令 - 调用对象的实例方法</li><li>invokeinterface 指令 - 调用接口方法</li><li>invokespecial 指令 - 调用需要特殊处理的实例方法 (初始化方法、私有方法、父类方法)</li><li>invokestatic 指令 - 调用类静态方法</li><li>invokedynamic 指令</li></ul><p>方法调用指令与数据类型无关，方法返回指令根据返回值的类型区分。</p><h3 id="_6-4-9-异常处理指令" tabindex="-1"><a class="header-anchor" href="#_6-4-9-异常处理指令"><span>6.4.9 异常处理指令</span></a></h3><p>用于在 Java 程序中用 <code>throw</code> 显式抛出异常。其它异常是自动抛出的。在 JVM 中，处理异常不是使用字节码指令实现的，而是采用异常表来完成。</p><h3 id="_6-4-10-同步指令" tabindex="-1"><a class="header-anchor" href="#_6-4-10-同步指令"><span>6.4.10 同步指令</span></a></h3><p>JVM 支持方法级的同步和方法内部一段指令序列的同步。方法级同步是隐式的，无需通过字节码指令控制，通过 <strong>管程 (Monitor)</strong> 实现：</p><ul><li>函数调用时，调用指令检查函数的 <code>ACC_SYNCHRONIZED</code> 访问标志</li><li>如果设置了该标志，执行线程就需要先成功持有管程，然后才能执行函数</li><li>函数完成后释放管程 (不管是正常完成还是非正常完成)</li><li>其它任何线程都无法再获取到同一个管程</li></ul><p>同步一段指令集序列由 <code>synchronized</code> 语句块表示。JVM 提供 <code>monitorenter</code> 和 <code>monitorexit</code> 两条指令支持该语义，两条指令必须相互对应。</p><hr><h2 id="_6-5-公有设计-私有实现" tabindex="-1"><a class="header-anchor" href="#_6-5-公有设计-私有实现"><span>6.5 公有设计，私有实现</span></a></h2><p>Class 文件格式以及字节码指令集都是 <em>Java 虚拟机规范</em> 中规定好的。满足该规定的约束下，对 JVM 的具体实现做出修改和优化是完全可行的，<em>Java 虚拟机规范</em> 中明确鼓励实现者这样去做。只要优化以后的 JVM 依旧可以正确读取 Class 文件，并且包含在其中的语义能得到完整保持，JVM 在后台如何处理 Class 文件完全是实现者自己的事情。</p>`,118)]))}const t=l(s,[["render",c],["__file","Chapter 6 - 类文件结构.html.vue"]]),p=JSON.parse('{"path":"/understanding-the-jvm-notes/Part%203%20-%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/Chapter%206%20-%20%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html","title":"Chapter 6 - 类文件结构","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"6.2 无关性的基石","slug":"_6-2-无关性的基石","link":"#_6-2-无关性的基石","children":[]},{"level":2,"title":"6.3 Class 类文件的结构","slug":"_6-3-class-类文件的结构","link":"#_6-3-class-类文件的结构","children":[{"level":3,"title":"6.3.1 魔数与 Class 文件的版本","slug":"_6-3-1-魔数与-class-文件的版本","link":"#_6-3-1-魔数与-class-文件的版本","children":[]},{"level":3,"title":"6.3.2 常量池","slug":"_6-3-2-常量池","link":"#_6-3-2-常量池","children":[]},{"level":3,"title":"6.3.3 访问标志","slug":"_6-3-3-访问标志","link":"#_6-3-3-访问标志","children":[]},{"level":3,"title":"6.3.4 类索引、父类索引与接口索引集合","slug":"_6-3-4-类索引、父类索引与接口索引集合","link":"#_6-3-4-类索引、父类索引与接口索引集合","children":[]},{"level":3,"title":"6.3.5 字段表集合","slug":"_6-3-5-字段表集合","link":"#_6-3-5-字段表集合","children":[]},{"level":3,"title":"6.3.6 方法表集合","slug":"_6-3-6-方法表集合","link":"#_6-3-6-方法表集合","children":[]},{"level":3,"title":"6.3.7 属性表集合","slug":"_6-3-7-属性表集合","link":"#_6-3-7-属性表集合","children":[]}]},{"level":2,"title":"6.4 字节码指令简介","slug":"_6-4-字节码指令简介","link":"#_6-4-字节码指令简介","children":[{"level":3,"title":"6.4.1 字节码与数据类型","slug":"_6-4-1-字节码与数据类型","link":"#_6-4-1-字节码与数据类型","children":[]},{"level":3,"title":"6.4.2 加载和存储指令","slug":"_6-4-2-加载和存储指令","link":"#_6-4-2-加载和存储指令","children":[]},{"level":3,"title":"6.4.3 运算指令","slug":"_6-4-3-运算指令","link":"#_6-4-3-运算指令","children":[]},{"level":3,"title":"6.4.4 类型转换指令","slug":"_6-4-4-类型转换指令","link":"#_6-4-4-类型转换指令","children":[]},{"level":3,"title":"6.4.5 对象创建与访问指令","slug":"_6-4-5-对象创建与访问指令","link":"#_6-4-5-对象创建与访问指令","children":[]},{"level":3,"title":"6.4.6 操作数栈管理指令","slug":"_6-4-6-操作数栈管理指令","link":"#_6-4-6-操作数栈管理指令","children":[]},{"level":3,"title":"6.4.7 控制转移指令","slug":"_6-4-7-控制转移指令","link":"#_6-4-7-控制转移指令","children":[]},{"level":3,"title":"6.4.8 方法调用和返回指令","slug":"_6-4-8-方法调用和返回指令","link":"#_6-4-8-方法调用和返回指令","children":[]},{"level":3,"title":"6.4.9 异常处理指令","slug":"_6-4-9-异常处理指令","link":"#_6-4-9-异常处理指令","children":[]},{"level":3,"title":"6.4.10 同步指令","slug":"_6-4-10-同步指令","link":"#_6-4-10-同步指令","children":[]}]},{"level":2,"title":"6.5 公有设计，私有实现","slug":"_6-5-公有设计-私有实现","link":"#_6-5-公有设计-私有实现","children":[]}],"git":{},"filePathRelative":"understanding-the-jvm-notes/Part 3 - 虚拟机执行子系统/Chapter 6 - 类文件结构.md"}');export{t as comp,p as data};
