import{_ as e,c as a,a as s,o as i}from"./app-7eKjwDat.js";const t={};function l(p,n){return i(),a("div",null,n[0]||(n[0]=[s(`<h1 id="os-static-linking" tabindex="-1"><a class="header-anchor" href="#os-static-linking"><span>OS - Static Linking</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 06 / 27 16:28</p><p>Nanjing, Jiangsu, China</p><hr><blockquote><p>本文内容来自于 <em>程序员的自我修养 - 链接、装载与库，俞甲子 石凡 潘爱民著</em>。</p></blockquote><hr><h2 id="two-pass-linking" tabindex="-1"><a class="header-anchor" href="#two-pass-linking"><span>Two-pass Linking</span></a></h2><p>链接的目标是，将几个目标文件加工后合并为一个目标文件。整个过程将分为两步：</p><ol><li>空间和地址分配 - 同时将输入目标文件符号表中的所有符号定义、符号引用收集起来，统一放到一个全局符号表中</li><li>符号解析与重定位 - 读取每个目标文件的重定位信息，调整代码中的地址</li></ol><h2 id="空间与地址分配" tabindex="-1"><a class="header-anchor" href="#空间与地址分配"><span>空间与地址分配</span></a></h2><p>空间与地址的含义有两点：</p><ol><li>在输出的可执行文件中的空间</li><li>被 OS 装载后的虚拟地址空间</li></ol><p>链接器会将 <strong>相同性质</strong> 的段合并到一起 - 比如将所有目标文件的 <code>.text</code> 合并在一起。而 <code>.bss</code> 段在文件中不占用空间，但是在装载后会占用地址空间，所以链接器也会将每个目标文件的 <code>.bss</code> 合并并分配空间。</p><p>链接后的程序中使用的地址已经是程序在进程中的虚拟地址 (Virtual Memory Address, VMA)。链接前，目标文件中所有段的 VMA 都是 0，即从 0 地址开始分配起始地址，说明虚拟地址空间还没有被分配。在链接后，各目标文件的虚拟地址才被确定下来。在 Linux 下，ELF 文件默认从 <code>0x08048000</code> 开始分配地址。</p><p>当地址空间分配完毕后，各个段在链接后的虚拟地址已经确定。此时，可以将全局符号表中的符号地址全部更新为分配完毕的虚拟地址 (原先符号表中的地址为本目标文件中的地址)。这一步完成之后，所有符号的地址可以被确定，下一步就要把程序中引用符号的地方替换为符号对应的虚拟地址。</p><h2 id="符号解析与重定位" tabindex="-1"><a class="header-anchor" href="#符号解析与重定位"><span>符号解析与重定位</span></a></h2><p>在链接之前，已经被编译完毕的目标文件是如何引用外部符号的？编译器会在指令中使用临时的假地址，因为编译器并不知道引用外部函数的真正地址。链接器在完成地址和空间分配之后，就可以对每个需要重定位的指令进行地址修正。</p><h3 id="重定位表" tabindex="-1"><a class="header-anchor" href="#重定位表"><span>重定位表</span></a></h3><p>链接器如何知道哪些指令需要被修正？指令的哪些部分要被修正？怎么修正？这是由 ELF 文件中的 <strong>重定位表 (Relocation Table)</strong> 指示的。在 ELF 文件中，重定位表也是一个段，一个重定位表一般对应于 ELF 中的一个段，比如 <code>.rel.text</code> 对应 <code>.text</code>。表中记录的每一个需要被重定位的地方被称为 Relocation Entry：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">  Elf64_Addr	r_offset<span class="token punctuation">;</span>		<span class="token comment">/* Address */</span></span>
<span class="line">  Elf64_Xword	r_info<span class="token punctuation">;</span>			<span class="token comment">/* Relocation type and symbol index */</span></span>
<span class="line"><span class="token punctuation">}</span> Elf64_Rel<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，<code>r_offset</code> 表示重定位位置的第一个 byte 在段中的偏移量；<code>r_info</code> 表示重定位位置的类型，以及符号在符号表中的下标。每种处理器都有不同的重定位结构体，以上是 Intel x86 架构的重定位结构。</p><p>每一个重定位结构都是一个对当前目标文件中未定义的符号的引用。链接器会到全局符号表中负责查找符号对应的地址。如果链接正确，应当能够在全局符号表中找到，否则链接器就会报符号未定义错误。</p><p>接下来，对指令中的地址修正分为两类：</p><ol><li>绝对地址修正 - 将地址修正为符号的实际地址</li><li>相对地址修正 - 将地址修正为符号与被修正位置的地址差</li></ol><hr><h2 id="静态库链接" tabindex="-1"><a class="header-anchor" href="#静态库链接"><span>静态库链接</span></a></h2><p>静态库可以看成是一组目标文件的集合，经过压缩打包后形成的文件。其中包含了很多与系统功能相关的函数，对 OS 的 API 进行了封装。在库中，每个系统函数都对应一个目标文件，函数之间还存在依赖关系 - 这是为了防止把一些没有用到的函数也一起链接到输出结果中。链接器会自动寻找所有需要的符号，以及符号所在的目标文件，从库中解压出来，最终链接在一起。</p><hr>`,29)]))}const c=e(t,[["render",l],["__file","OS Static Linking.html.vue"]]),r=JSON.parse('{"path":"/notes/Operating%20System/OS%20Static%20Linking.html","title":"OS - Static Linking","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Two-pass Linking","slug":"two-pass-linking","link":"#two-pass-linking","children":[]},{"level":2,"title":"空间与地址分配","slug":"空间与地址分配","link":"#空间与地址分配","children":[]},{"level":2,"title":"符号解析与重定位","slug":"符号解析与重定位","link":"#符号解析与重定位","children":[{"level":3,"title":"重定位表","slug":"重定位表","link":"#重定位表","children":[]}]},{"level":2,"title":"静态库链接","slug":"静态库链接","link":"#静态库链接","children":[]}],"git":{},"filePathRelative":"notes/Operating System/OS Static Linking.md"}');export{c as comp,r as data};
