import{_ as n,c as a,a as p,o as e}from"./app-BeHGwf2X.js";const l={};function t(c,s){return e(),a("div",null,s[0]||(s[0]=[p(`<h1 id="chapter-16-slab-共享内存" tabindex="-1"><a class="header-anchor" href="#chapter-16-slab-共享内存"><span>Chapter 16 - slab 共享内存</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 08 / 08 21:18</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="_16-1-操作-slab-共享内存的方法" tabindex="-1"><a class="header-anchor" href="#_16-1-操作-slab-共享内存的方法"><span>16.1 操作 slab 共享内存的方法</span></a></h2><ul><li><code>void ngx_slab_init(ngx_slab_pool_t *pool);</code> - 初始化共享内存 (由 Nginx 框架自动调用)</li><li><code>void *ngx_slab_alloc(ngx_slab_pool_t *pool, size_t size);</code> - 加锁保护的内存分配函数</li><li><code>void *ngx_slab_alloc_locked(ngx_slab_pool_t *pool, size_t size);</code> - 不加锁保护的内存分配函数</li><li><code>void ngx_slab_free(ngx_slab_pool_t *pool, void *p);</code> - 加锁保护的内存释放函数</li><li><code>void ngx_slab_free_locked(ngx_slab_pool_t *pool, void *p);</code> 不加锁保护的内存释放函数</li></ul><p>由于 slab 大部分时间都要跨进程通信，因此不加锁的分配、释放函数较少使用。</p><p>Slab 内存池在解析配置文件时被初始化。当执行 <code>-s reload</code> 时，Nginx 会重新加载配置文件，再次初始化 slab 共享内存池。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ngx_shm_zone_s</span>  <span class="token class-name">ngx_shm_zone_t</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">typedef</span> <span class="token class-name">ngx_int_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>ngx_shm_zone_init_pt<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">ngx_shm_zone_t</span> <span class="token operator">*</span>zone<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">ngx_shm_zone_s</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">void</span>                     <span class="token operator">*</span>data<span class="token punctuation">;</span> <span class="token comment">// 回调函数的参数</span></span>
<span class="line">    <span class="token class-name">ngx_shm_t</span>                 shm<span class="token punctuation">;</span> <span class="token comment">// 描述共享内存的结构体</span></span>
<span class="line">    ngx_shm_zone_init_pt      init<span class="token punctuation">;</span> <span class="token comment">// slab 内存池创建成功后回调</span></span>
<span class="line">    <span class="token keyword">void</span>                     <span class="token operator">*</span>tag<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">void</span>                     <span class="token operator">*</span>sync<span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">ngx_uint_t</span>                noreuse<span class="token punctuation">;</span>  <span class="token comment">/* unsigned  noreuse:1; */</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_16-3-slab-内存管理的实现原理" tabindex="-1"><a class="header-anchor" href="#_16-3-slab-内存管理的实现原理"><span>16.3 slab 内存管理的实现原理</span></a></h2><p>动态管理内存面对的主要问题：</p><ul><li>时间上，使用者随时可能分配内存、释放内存</li><li>空间上，每次申请分配内存的大小随机</li></ul><p>这两个问题使得内存中会产生碎片，从而导致内存的浪费。常见内存分配算法的两种设计方向：</p><ul><li>First-fit - 首次适应，从头遍历空闲内存块链表，找到第一个符合需求的内存块 (快，但可能产生碎片)</li><li>Best-fit - 找到与所需分配的内存最为匹配的内存块 (遍历慢些，但是产生碎片的概率小)</li></ul><p>Nginx 基于 best-fit 的思路分配内存，但是需要以更快的速度找到合适大小的内存。Nginx 假定所有需要使用 slab 内存的模块请求分配的内存都不超过 4KB。基于这个假设，Nginx 中的内存块分配方法如下：</p><ol><li>把整块内存按 4KB 分页，每页存放 <strong>固定大小</strong> 的内存块，页首存放 bitmap (通过 bitmap 遍历空闲内存块)</li><li>Slab 内存分配器把请求分配的内存大小简化为有限几种 (2 字节的倍数)</li><li>让有限的几种大小相同的页面构成链表，按内存块大小排序保存在一个数组中</li><li>页面中分为空闲页、半满页、全满页，全满页脱离链表，分配内存时不再访问</li><li>对于大于 4KB 页的内存分配需求，寻找地址连续的几个空闲页来分配</li></ol><h3 id="_16-3-1-内存结构布局" tabindex="-1"><a class="header-anchor" href="#_16-3-1-内存结构布局"><span>16.3.1 内存结构布局</span></a></h3><p>每一个 slab 内存池对应着一块共享内存。内存首地址开始的地方保存的是 slab 管理结构，之后才是分配给使用者的内存：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">ngx_shmtx_sh_t</span>    lock<span class="token punctuation">;</span> <span class="token comment">// 使用信号量进行进程同步时会用到</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">size_t</span>            min_size<span class="token punctuation">;</span> <span class="token comment">// 最小内存块长度</span></span>
<span class="line">    <span class="token class-name">size_t</span>            min_shift<span class="token punctuation">;</span> <span class="token comment">// 最小内存块长度的偏移 (1 &lt;&lt; ?)</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">ngx_slab_page_t</span>  <span class="token operator">*</span>pages<span class="token punctuation">;</span> <span class="token comment">// 所有的内存页</span></span>
<span class="line">    <span class="token class-name">ngx_slab_page_t</span>  <span class="token operator">*</span>last<span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">ngx_slab_page_t</span>   free<span class="token punctuation">;</span> <span class="token comment">// 所有的空闲页链表</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">ngx_slab_stat_t</span>  <span class="token operator">*</span>stats<span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">ngx_uint_t</span>        pfree<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    u_char           <span class="token operator">*</span>start<span class="token punctuation">;</span> <span class="token comment">// 所有的实际页面的首地址</span></span>
<span class="line">    u_char           <span class="token operator">*</span>end<span class="token punctuation">;</span> <span class="token comment">// 共享内存尾部</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">ngx_shmtx_t</span>       mutex<span class="token punctuation">;</span> <span class="token comment">// 互斥锁</span></span>
<span class="line"></span>
<span class="line">    u_char           <span class="token operator">*</span>log_ctx<span class="token punctuation">;</span> <span class="token comment">// slab 操作失败时用于记录日志</span></span>
<span class="line">    u_char            zero<span class="token punctuation">;</span> <span class="token comment">// &#39;\\0&#39;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">unsigned</span>          log_nomem<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">void</span>             <span class="token operator">*</span>data<span class="token punctuation">;</span> <span class="token comment">// 由使用 slab 的模块自由使用</span></span>
<span class="line">    <span class="token keyword">void</span>             <span class="token operator">*</span>addr<span class="token punctuation">;</span> <span class="token comment">// 执行所属 ngx_shm_t 中的 addr 成员</span></span>
<span class="line"><span class="token punctuation">}</span> <span class="token class-name">ngx_slab_pool_t</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了描述每一个内存页，都要使用一个 <code>ngx_slab_page_t</code> 结构体：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ngx_slab_page_s</span>  <span class="token class-name">ngx_slab_page_t</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">ngx_slab_page_s</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">uintptr_t</span>         slab<span class="token punctuation">;</span> <span class="token comment">// (多用途)</span></span>
<span class="line">    <span class="token class-name">ngx_slab_page_t</span>  <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 下一页</span></span>
<span class="line">    <span class="token class-name">uintptr_t</span>         prev<span class="token punctuation">;</span> <span class="token comment">// (多用途)，同时指向双向链表的前一页</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所有内存页可被分为全满页、半满页、空闲页。全满页不在任何链表中，因此其中的 <code>next</code> 和 <code>prev</code> 没有任何链表的功能。</p><p>所有的空闲页则构成一个双向链表，由 <code>free</code> 指针指向这个链表 - 但 <strong>并不是每个空闲页都是链表中的元素</strong>。首页面的 <code>slab</code> 成员大于 1 时表示其后有相邻的页面，这些相邻页面作为一个链表元素而存在。由于内存的分配与回收时机不同，可能出现相邻的内存块各占一个链表元素的情况。当 slab 内存池刚刚初始化完毕时，<code>free</code> 链表中只有一个元素 - 就是第一个页面，<code>slab</code> 的值为总页数。</p><p>对于半满页，存放相同大小内存块的页面会构成双向链表，存放在 <code>slot</code> 数组的相应位置上。</p><h3 id="_16-3-2-分配内存流程" tabindex="-1"><a class="header-anchor" href="#_16-3-2-分配内存流程"><span>16.3.2 分配内存流程</span></a></h3><p>首先需要判断用户申请的内存是否大于 <code>ngx_slab_max_size</code> - 如果大于这个值，说明要按照页面来分配内存；否则只用一个页面中的内存块就可以实现分配。如果要按页来分配内存，那么首先需要计算分配多少个页面才能存放用户申请的内存字节数 (不足一页时按一页计算)。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token class-name">ngx_uint_t</span> pages <span class="token operator">=</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;&gt;</span> ngx_pagesize_shift<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">%</span> ngx_pagesize<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在计算出页数后，需要遍历 <code>free</code> 空闲页链表，找出能够容纳用户申请的字节数的 <strong>连续内存</strong>：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">static</span> <span class="token class-name">ngx_slab_page_t</span> <span class="token operator">*</span></span>
<span class="line"><span class="token function">ngx_slab_alloc_pages</span><span class="token punctuation">(</span><span class="token class-name">ngx_slab_pool_t</span> <span class="token operator">*</span>pool<span class="token punctuation">,</span> <span class="token class-name">ngx_uint_t</span> pages<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">ngx_slab_page_t</span>  <span class="token operator">*</span>page<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 遍历 free 链表</span></span>
<span class="line">    <span class="token keyword">for</span> <span class="token punctuation">(</span>page <span class="token operator">=</span> pool<span class="token operator">-&gt;</span>free<span class="token punctuation">.</span>next<span class="token punctuation">;</span> page <span class="token operator">!=</span> <span class="token operator">&amp;</span>pool<span class="token operator">-&gt;</span>free<span class="token punctuation">;</span> page <span class="token operator">=</span> page<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 链表元素的 slab 数量已经达到所需要分配的页数</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token operator">-&gt;</span>slab <span class="token operator">&gt;=</span> pages<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">            <span class="token comment">// slab 在分配后还会有空闲页</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token operator">-&gt;</span>slab <span class="token operator">&gt;</span> pages<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                page<span class="token punctuation">[</span>page<span class="token operator">-&gt;</span>slab <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>page<span class="token punctuation">[</span>pages<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">                <span class="token comment">// slab 中第一个不会被分配的空闲页</span></span>
<span class="line">                <span class="token comment">// 修改其指针，使其作为链表元素</span></span>
<span class="line">                page<span class="token punctuation">[</span>pages<span class="token punctuation">]</span><span class="token punctuation">.</span>slab <span class="token operator">=</span> page<span class="token operator">-&gt;</span>slab <span class="token operator">-</span> pages<span class="token punctuation">;</span></span>
<span class="line">                page<span class="token punctuation">[</span>pages<span class="token punctuation">]</span><span class="token punctuation">.</span>next <span class="token operator">=</span> page<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span></span>
<span class="line">                page<span class="token punctuation">[</span>pages<span class="token punctuation">]</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> page<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">                <span class="token comment">// 修改链表前后结点的指针</span></span>
<span class="line">                p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ngx_slab_page_t</span> <span class="token operator">*</span><span class="token punctuation">)</span> page<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span></span>
<span class="line">                p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>page<span class="token punctuation">[</span>pages<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">                page<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>page<span class="token punctuation">[</span>pages<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token comment">// slab 中的页被完全分配了</span></span>
<span class="line">                <span class="token comment">// 直接将这个元素移出链表</span></span>
<span class="line">                p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ngx_slab_page_t</span> <span class="token operator">*</span><span class="token punctuation">)</span> page<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span></span>
<span class="line">                p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> page<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span></span>
<span class="line">                page<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> page<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">            <span class="token comment">// 设置被分配内存的属性</span></span>
<span class="line">            page<span class="token operator">-&gt;</span>slab <span class="token operator">=</span> pages <span class="token operator">|</span> NGX_SLAB_PAGE_START<span class="token punctuation">;</span></span>
<span class="line">            page<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></span>
<span class="line">            page<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> NGX_SLAB_PAGE<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">            <span class="token comment">// 内存池中的空闲页数减少</span></span>
<span class="line">            pool<span class="token operator">-&gt;</span>pfree <span class="token operator">-=</span> pages<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">            <span class="token comment">// 如果只分配了一个页，那么可以直接返回了</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>pages <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token keyword">return</span> page<span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">            <span class="token comment">// 如果不止分配了一个页，那么设置后续内存页的属性</span></span>
<span class="line">            <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> page <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> pages<span class="token punctuation">;</span> pages<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                p<span class="token operator">-&gt;</span>slab <span class="token operator">=</span> NGX_SLAB_PAGE_BUSY<span class="token punctuation">;</span></span>
<span class="line">                p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></span>
<span class="line">                p<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> NGX_SLAB_PAGE<span class="token punctuation">;</span></span>
<span class="line">                p<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">            <span class="token keyword">return</span> page<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 没有找到符合要求的内存页面</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>pool<span class="token operator">-&gt;</span>log_nomem<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">ngx_slab_error</span><span class="token punctuation">(</span>pool<span class="token punctuation">,</span> NGX_LOG_CRIT<span class="token punctuation">,</span></span>
<span class="line">                       <span class="token string">&quot;ngx_slab_alloc() failed: no memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果被分配的内存大小在一页以内，那么就要计算符合这个内存大小的最小内存块了。Slab 页面上允许存放的内存块以 8 字节起步，以 2 为倍数递增。此时先要根据 best-fit 原则找到最适合的内存块大小 (比如 64B)。然后取出半满页的链表，取得相应块大小的内存页链表 (全是 64B 内存块的半满页)。遍历内存页链表，如果没有找到半满页，那么分配一个新的页用于存放这个大小的内存块。</p><p>在每个半满页中，根据页大小和内存块大小，可以计算出 bitmap 的长度。然后找到 bitmap 中的第一个空闲块；如果没有空闲块，那这就不是一个半满页了，因此需要把它从链表中移走，然后遍历下一个半满页。如果找了到空闲块，在记录该块被使用以后，还要判断这是不是当前页的最后一个空闲页，如果是，那么也要将其移出链表。</p><p>如果分配了新页用于存放内存块，那么还要计算出 bitmap 后，将 bitmap 本身占用的内存块标记为已使用。新页面由空闲页变为半满页，因此会被插入到半满页链表相应内存块大小的链表的首部。</p><h3 id="_16-3-3-释放内存流程" tabindex="-1"><a class="header-anchor" href="#_16-3-3-释放内存流程"><span>16.3.3 释放内存流程</span></a></h3><p>首先判断内存块地址是否合法，然后得到内存块所属页的页描述结构体，判断出页面是整页内存还是内存块页面。如果是内存块页面，那么还要计算出 bitmap 的长度。将 bitmap 中相应的位置为空闲，如果该页是一个全满页，在释放后将变为半满页，那么还要将其插入半满页链表中。另外，还要检测 bitmap 中是否还有 0 的位，如果没有，那么说明变为空闲页，还要插入回 <code>free</code> 链表中。</p><hr><p>在内存分配和释放的过程中，Nginx 大量使用了位操作来提高性能。</p>`,37)]))}const i=n(l,[["render",t],["__file","Chapter 16 - slab 共享内存.html.vue"]]),r=JSON.parse('{"path":"/understanding-nginx-notes/Part%203%20-%20%E6%B7%B1%E5%85%A5%20Nginx/Chapter%2016%20-%20slab%20%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.html","title":"Chapter 16 - slab 共享内存","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"16.1 操作 slab 共享内存的方法","slug":"_16-1-操作-slab-共享内存的方法","link":"#_16-1-操作-slab-共享内存的方法","children":[]},{"level":2,"title":"16.3 slab 内存管理的实现原理","slug":"_16-3-slab-内存管理的实现原理","link":"#_16-3-slab-内存管理的实现原理","children":[{"level":3,"title":"16.3.1 内存结构布局","slug":"_16-3-1-内存结构布局","link":"#_16-3-1-内存结构布局","children":[]},{"level":3,"title":"16.3.2 分配内存流程","slug":"_16-3-2-分配内存流程","link":"#_16-3-2-分配内存流程","children":[]},{"level":3,"title":"16.3.3 释放内存流程","slug":"_16-3-3-释放内存流程","link":"#_16-3-3-释放内存流程","children":[]}]}],"git":{},"filePathRelative":"understanding-nginx-notes/Part 3 - 深入 Nginx/Chapter 16 - slab 共享内存.md"}');export{i as comp,r as data};
