import{_ as e,c as i,a,o as t}from"./app-BeHGwf2X.js";const s="/blog/assets/4-41-97vyxxgx.png",o="/blog/assets/4-42-Bo20HjjW.png",p={};function n(h,l){return t(),i("div",null,l[0]||(l[0]=[a('<h1 id="chapter-4-9-一个简单的多任务内核实例" tabindex="-1"><a class="header-anchor" href="#chapter-4-9-一个简单的多任务内核实例"><span>Chapter 4.9 - 一个简单的多任务内核实例</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 08 / 01 21:54</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="_4-9-一个简单的多任务内核实例" tabindex="-1"><a class="header-anchor" href="#_4-9-一个简单的多任务内核实例"><span>4.9 一个简单的多任务内核实例</span></a></h2><h3 id="_4-9-1-多任务程序结构和工作原理" tabindex="-1"><a class="header-anchor" href="#_4-9-1-多任务程序结构和工作原理"><span>4.9.1 多任务程序结构和工作原理</span></a></h3><p>内核实例由两个程序构成：</p><ul><li>引导启动程序 <code>boot.s</code>：系统上电时，从启动盘上把内核代码加载到内存中</li><li>内核程序 <code>head.s</code><ul><li>两个在特权级 3 上运行的任务</li><li>在屏幕上显示字符的系统调用</li></ul></li></ul><p><code>boot.s</code> 编译出的代码共 512B，存盘在软盘映像文件的第一个扇区中。ROM BIOS 会将启动盘第一扇区加载到物理内存 <code>0x7c00</code> 处，把执行权转移到此处，开始运行 boot 程序代码。</p><p>boot 程序的主要功能：</p><ul><li><p>利用 ROM BIOS 中断 int 0x13 将 head 代码读入内存 <code>0x10000</code> (64KB) 处</p></li><li><p>将这段代码移动到内存 0 处</p><blockquote><p>不能直接将 head 代码读到内存 0 处，因为加载操作需要用到 ROM BIOS 的中断，而中断向量表正好位于内存 0 处，且内存 1KB 开始处是 BIOS 程序使用的数据区。</p></blockquote></li><li><p>设置好临时 GDT 表，设置 CR0 PE 进入保护模式</p></li><li><p>跳转到内存 0 处开始执行 head 代码</p></li></ul><p>head 程序运行在 32-bit 保护模式下，包含：</p><ul><li>初始化代码 <ul><li>重新设置 GDT</li><li>设置系统定时器芯片</li><li>重新设置 IDT 表，并设置时钟和系统调用的中断门</li><li>跳转到任务 A 中</li></ul></li><li>时钟中断 int 0x08 的处理程序</li><li>系统调用中断 int 0x80 的处理程序</li><li>任务 A 和任务 B 的代码数据</li></ul><p>虚拟地址空间分配：</p><p><img src="'+s+'" alt="4-41"></p><p>最终的映像文件组织方式：</p><p><img src="'+o+'" alt="4-42"></p><p>在初始化结束后，利用 <code>IRET</code> 指令来启动运行第一个任务。因为控制权不能从特权级 0 的代码直接转移到特权级 3 的代码中。在初始堆栈中人工设置一个返回环境</p><ul><li>将任务 0 的 TSS 段选择符加载到 TR，LDT 段选择符加载到 LDTR 中</li><li>将任务 0 的用户栈指针、代码指针、EFLAGS 压入栈中</li><li>执行 IRET</li><li>弹出堆栈上的堆栈指针作为任务 0 的用户栈指针</li><li>恢复任务 0 的 EFLAGS</li><li>弹出 CS:EIP 从而开始执行任务 0 的代码</li></ul><p>为了每隔 10ms 切换正在运行的任务：</p><ul><li>将 8253 的通道 0 设置为每经过 10ms 向 8259 发送时钟中断信号</li><li>ROM BIOS 开机时已经在 8259 中将时钟中断请求号设置为 8</li><li>在中断 8 的处理函数中执行任务切换操作</li><li>查看 current 变量中的任务号，如果是 0，就利用任务 1 的 TSS 选择符远跳转到任务 1；反之亦然</li><li>每个任务中，将字符的 ASCII 放入寄存器 AL，调用系统调用中断 int 0x80</li><li>中断处理程序调用一个字符写屏子程序，将 AL 中的字符显示在屏幕上，同时记录字符显示的下一个位置</li><li>使用循环语句延迟一段时间，继续循环执行，直到 10ms 时间片用尽</li></ul><p>任务 0 的字符始终为 <code>A</code>，任务 1 的字符始终为 <code>B</code></p><hr><h3 id="_4-9-2-引导启动程序-boot-s" tabindex="-1"><a class="header-anchor" href="#_4-9-2-引导启动程序-boot-s"><span>4.9.2 引导启动程序 boot.s</span></a></h3><h3 id="_4-9-3-多任务内核程序-head-s" tabindex="-1"><a class="header-anchor" href="#_4-9-3-多任务内核程序-head-s"><span>4.9.3 多任务内核程序 head.s</span></a></h3>',26)]))}const c=e(p,[["render",n],["__file","Chapter 4.9 - 一个简单的多任务内核实例.html.vue"]]),d=JSON.parse('{"path":"/linux-kernel-comments-notes/Chapter%204%20-%2080X86%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B6%E7%BC%96%E7%A8%8B/Chapter%204.9%20-%20%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%86%85%E6%A0%B8%E5%AE%9E%E4%BE%8B.html","title":"Chapter 4.9 - 一个简单的多任务内核实例","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"4.9 一个简单的多任务内核实例","slug":"_4-9-一个简单的多任务内核实例","link":"#_4-9-一个简单的多任务内核实例","children":[{"level":3,"title":"4.9.1 多任务程序结构和工作原理","slug":"_4-9-1-多任务程序结构和工作原理","link":"#_4-9-1-多任务程序结构和工作原理","children":[]},{"level":3,"title":"4.9.2 引导启动程序 boot.s","slug":"_4-9-2-引导启动程序-boot-s","link":"#_4-9-2-引导启动程序-boot-s","children":[]},{"level":3,"title":"4.9.3 多任务内核程序 head.s","slug":"_4-9-3-多任务内核程序-head-s","link":"#_4-9-3-多任务内核程序-head-s","children":[]}]}],"git":{},"filePathRelative":"linux-kernel-comments-notes/Chapter 4 - 80X86 保护模式及其编程/Chapter 4.9 - 一个简单的多任务内核实例.md"}');export{c as comp,d as data};
