import{_ as l,c as i,a as o,o as n}from"./app-7eKjwDat.js";const a={};function c(d,e){return n(),i("div",null,e[0]||(e[0]=[o('<h1 id="os-compile-and-link" tabindex="-1"><a class="header-anchor" href="#os-compile-and-link"><span>OS - Compile and Link</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 06 / 25 16:42</p><p>Nanjing, Jiangsu, China</p><hr><blockquote><p>内容来自于 <em>程序员的自我修养 - 链接、装载与库，俞甲子 石凡 潘爱民著</em>。</p></blockquote><hr><h2 id="whole-procedure" tabindex="-1"><a class="header-anchor" href="#whole-procedure"><span>Whole Procedure</span></a></h2><p>IDE 将编译、链接的过程一步完成。这种编译和链接合并到一起的过程称为 <strong>构建 (Build)</strong>。而实际上，被 IDE 隐藏的过程是非常多的：</p><h3 id="预编译" tabindex="-1"><a class="header-anchor" href="#预编译"><span>预编译</span></a></h3><p>预编译由 <strong>预编译器 (cpp)</strong> 完成，将 C/C++ 源代码预编译为 <code>.i</code> / <code>.ii</code> 文件。这一过程主要处理源代码中以 <code>#</code> 为开头的预编译指令：</p><ul><li>展开 <code>#define</code> 宏定义</li><li>处理条件编译指令 <code>#ifdef</code> <code>#if</code> 等</li><li>处理 <code>#include</code> 递归地将将被包含的文件插入到该指令的位置</li><li>删除所有注释</li><li>添加行号和文件名标识 (方便编译器产生警告或错误提示)</li><li>保留 <code>#progma</code> 编译器指令 (编译器需要使用)</li></ul><h3 id="编译" tabindex="-1"><a class="header-anchor" href="#编译"><span>编译</span></a></h3><p>编译器完成词法分析、语法分析、语义分析、优化，产生汇编代码文件 <code>.s</code>。GCC 命令使用 <code>cc1</code> 程序完成预编译和编译两个步骤。此外，<code>gcc</code> 命令只是后台各个部件的封装，会根据不同的参数去调用不同的后台部件：</p><ul><li><code>cc1</code> - 预编译、编译程序</li><li><code>as</code> - 汇编器</li><li><code>ld</code> - 链接器</li></ul><h3 id="汇编" tabindex="-1"><a class="header-anchor" href="#汇编"><span>汇编</span></a></h3><p>将汇编代码转换为机器可以执行的指令。基本上每一个汇编语句都对应一条机器指令，所以这个过程实际上就是一个查表翻译的过程，比较简单。由此，生成了目标文件 <code>.o</code>。</p><h3 id="链接" tabindex="-1"><a class="header-anchor" href="#链接"><span>链接</span></a></h3><blockquote><p>需要将一大堆目标文件链接在一起，才能生成可执行文件。</p></blockquote><hr><h2 id="compiler" tabindex="-1"><a class="header-anchor" href="#compiler"><span>Compiler</span></a></h2><p>编译器所做的工作只是上述完整流程中的一部分。编译本身分为六步：</p><ul><li>词法分析 - 通过状态机将字符序列切分为 token，将标识符、数字常量、字符串常量等放到对应的表中</li><li>语法分析 - 产生 AST</li><li>语义分析 - 分析静态语义：声明和类型的匹配、类型转换</li><li>源代码优化 - 将代码转换为中间代码 (IR) 并进行优化</li><li>代码生成 - 依赖目标机器</li><li>目标代码优化 - 合适的寻址方式等</li></ul><p>在生成的目标代码中，有一些引用外部的绝对地址没有被确定。如果目标代码想要成为真正能被运行的指令，这些地址应该从哪里获得？</p><hr><h2 id="static-linking" tabindex="-1"><a class="header-anchor" href="#static-linking"><span>Static Linking</span></a></h2><p>汇编语言的出现解决了两个问题：</p><ol><li>用指令助记符替代了指令对应的二进制代码</li><li>用标号替代了会因插入或删除行而反复变化的绝对地址</li></ol><p>由于程序设计的模块化，人们把每个源代码模块独立地编译，再按要求组装起来。这个组装模块的过程就是链接。主要工作是把一些指令对其它 <strong>符号地址</strong> 的引用加以修正。链接过程包括：</p><ol><li>地址、空间分配 (Address and Storage Allocation)</li><li>符号决议 (Symbol Resolution)</li><li>重定位 (Relocation)</li></ol><p>目标文件与库文件一起链接，称为可执行文件。</p><p>由于每个模块都是单独编译的，假设源文件中引用了一个库函数中的文件，而在编译时并不知道这个库函数的地址。那么就暂时把这个函数的目标地址搁置，等链接是由链接器负责将这个地址修正。</p><p>使用链接器，我们就可以直接引用其它模块的函数和全局变量，不用管它们的具体地址。由链接器根据引用的符号去相应模块查找真正的地址，再修正当前模块中的地址 - 这一过程被称为 <strong>重定位</strong>，每个需要被修正的地方被称为重定位入口。以上是静态链接的基本过程和作用。</p><hr>',34)]))}const t=l(a,[["render",c],["__file","OS Compile and Link.html.vue"]]),p=JSON.parse('{"path":"/notes/Operating%20System/OS%20Compile%20and%20Link.html","title":"OS - Compile and Link","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Whole Procedure","slug":"whole-procedure","link":"#whole-procedure","children":[{"level":3,"title":"预编译","slug":"预编译","link":"#预编译","children":[]},{"level":3,"title":"编译","slug":"编译","link":"#编译","children":[]},{"level":3,"title":"汇编","slug":"汇编","link":"#汇编","children":[]},{"level":3,"title":"链接","slug":"链接","link":"#链接","children":[]}]},{"level":2,"title":"Compiler","slug":"compiler","link":"#compiler","children":[]},{"level":2,"title":"Static Linking","slug":"static-linking","link":"#static-linking","children":[]}],"git":{},"filePathRelative":"notes/Operating System/OS Compile and Link.md"}');export{t as comp,p as data};
