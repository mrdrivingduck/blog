import{_ as i,c as e,a as t,o as n}from"./app-7eKjwDat.js";const a="/blog/assets/4-9-CLRocTxp.png",s="/blog/assets/4-8-CGkeBtFe.png",r="/blog/assets/4-12-CLZiHt_s.png",p={};function o(c,l){return n(),e("div",null,l[0]||(l[0]=[t('<h1 id="chapter-4-3-分段机制" tabindex="-1"><a class="header-anchor" href="#chapter-4-3-分段机制"><span>Chapter 4.3 - 分段机制</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 07 / 24 21:47</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="_4-3-分段机制" tabindex="-1"><a class="header-anchor" href="#_4-3-分段机制"><span>4.3 分段机制</span></a></h2><h3 id="_4-3-1-段的定义" tabindex="-1"><a class="header-anchor" href="#_4-3-1-段的定义"><span>4.3.1 段的定义</span></a></h3><p>线性地址空间 - CPU 可寻址的地址空间。32-bit 对应 4GB 线性地址空间 - <code>0x00000000 - 0xffffffff</code>，这些空间被映射到 RAM、ROM、I/O 上。</p><p>每个段由三个参数定义：</p><ol><li>段基地址 - 段在 <strong>线性地址空间</strong> 中的起始地址</li><li>段长度 - 虚拟地址空间中，段内最大可用偏移</li><li>段属性 - 段是否可读、可写；段的特权级等</li></ol><p>可能导致的异常：</p><ul><li>偏移量大于段长度</li><li>访问段的特权级不够</li></ul><p>多个段映射到线性地址中的范围可以部分重叠或覆盖，甚至完全重叠。</p><blockquote><p>这句话我至今似懂非懂 🤔</p></blockquote><p>段的以上三个参数定义在 <strong>段描述符 (Segment Descriptor)</strong> 中。段描述符保存在 <strong>段描述符表</strong> 中：一个包含段描述符的数组。段选择符通过制定表中的某个描述符来指定对应的段。</p><p>线性地址转换过程：</p><ol><li>段选择符中的 14-bit 索引在 GDT 或 LDT 中找到对应的段描述符</li><li>校验段描述符中的访问权限和访问范围，确保段可访问，且偏移量位于段内</li><li>在段描述符表中取得段基地址，与偏移量相加，形成线性地址</li></ol><h3 id="_4-3-2-段描述符表" tabindex="-1"><a class="header-anchor" href="#_4-3-2-段描述符表"><span>4.3.2 段描述符表</span></a></h3><p>段选择符中：</p><ul><li>TI 位用于选择访问 GDT 还是 LDT</li><li>高 13 位用于选择对应段描述符表中的描述符偏移个数，因此段描述符最多可以包含 <code>2^13</code> 个 8 B 的段描述符</li></ul><p>描述符表存储在由 OS 维护的特殊数据结构中，由 OS 保护在仅能由 OS 访问的内存区域中，由 CPU 的内存管理硬件引用。虚拟地址空间 ( <code>2^14</code> 个段 ) 被切分为大小相等的两半：</p><ul><li><code>2^13</code> 个段是由 GDT 映射的全局虚拟地址空间</li><li><code>2^13</code> 个段是由 LDT 映射的局部虚拟地址空间</li></ul><p>发生任务切换时，LDT 会被切换为新任务的 LDT，而 GDT 不会改变。因此，GDT 映射的部分是各个任务共有的。LDT 所映射的部分会随任务切换而改变，LDT 段也由 GDT 来映射。</p><p>书中给出的这张图太好了：</p><p><img src="'+a+'" alt="4-9"></p><p>GDT 的基地址位于 GDTR 中，并在内存中 8B 对齐。GDT 的长度应当总是 <code>8N - 1</code>，因为段描述符总是 8B。CPU 不使用 GDT 的第一个描述符 - 空描述符。若使用了空描述符访问内存对触发保护性异常。</p><p><img src="'+s+'" alt="4-8"></p><p>LDT 表存放在 LDT 类型的系统段中，每个 LDT 的 <strong>段选择符</strong> 和 <strong>段描述符</strong> 都必须在 GDT 中，访问 LDT 也需要段选择符。为了减少访问 LDT 时的地址转换次数，将 GDT 中 LDT 的段选择符、基地址、段长度、访问权限缓存在 LDTR 中。</p><h3 id="_4-3-3-段选择符" tabindex="-1"><a class="header-anchor" href="#_4-3-3-段选择符"><span>4.3.3 段选择符</span></a></h3><p>段选择符 (段选择子) 是一个 16-bit 标识符：</p><ul><li>高 13-bit：段在描述符表中的 index</li><li>TI：GDT / LDT</li><li>RPL (Requested Privilege Level)：请求特权级，提供段保护信息</li></ul><p>对于应用程序来说，段选择符是指针的一部分，但选择符的值通常由链接加载程序修改。CPU 提供存放 6 个段选择符的寄存器，即段寄存器：最多同时有 6 个段可供立即访问，若要访问其它段，就需要加载段选择符。</p><p>为避免每次访问内存都使用 <strong>段选择符</strong> 去查找 <strong>段描述符表</strong> 中的 <strong>段描述符</strong>。每个段寄存器包含可见部分 + 隐藏部分 (描述符缓冲 / 影子寄存器)</p><ul><li>当段选择符被加载到段寄存器中时，自动加载对应段描述符中的基地址、段长度、权限等信息到隐藏部分</li><li>即 <strong>影子寄存器中含有对应段描述符信息的一个拷贝</strong></li><li>OS 需要确保对段描述符的改动反应在影子寄存器中,一旦段描述符被修改，立刻重新加载六个段寄存器</li></ul><p><img src="'+r+'" alt="4-12"></p><h3 id="_4-3-4-段描述符" tabindex="-1"><a class="header-anchor" href="#_4-3-4-段描述符"><span>4.3.4 段描述符</span></a></h3><p>段描述符是 GDT 和 LDT 中的一个数据结构项，8 字节长。包含段基地址、段长度、段属性三个主要字段。段描述符由编译器、链接器、加载器或 OS 创建</p><ul><li>LIMIT - Segment Limit Field <ul><li>20-bit 段长度</li><li>由 G 为来指定粒度 - 1B / 4KB</li></ul></li><li>BASE - Base Address Field <ul><li>32-bit 段基地址</li><li>最好对齐 16 B 边界</li></ul></li><li>TYPE - Type Field <ul><li>段或门类型</li><li>段的访问种类和扩展方向</li></ul></li><li>S - Descriptor Type Flag <ul><li>描述符类型 - 系统段描述符 / 应用 (代码/数据) 段描述符</li></ul></li><li>DPL - Descriptor Privilege Level <ul><li>描述符特权级，控制对段的访问</li></ul></li><li>P - Segment Present <ul><li>段是否在内存中</li></ul></li><li>G - Granularity <ul><li>颗粒度标志 - 确定 LIMIT 值得单位 - 1B / 4KB</li></ul></li></ul><h3 id="_4-3-5-代码和数据段描述符类型" tabindex="-1"><a class="header-anchor" href="#_4-3-5-代码和数据段描述符类型"><span>4.3.5 代码和数据段描述符类型</span></a></h3><h3 id="_4-3-6-系统描述符类型" tabindex="-1"><a class="header-anchor" href="#_4-3-6-系统描述符类型"><span>4.3.6 系统描述符类型</span></a></h3><ul><li>局部描述符表 LDT 段描述符</li><li>任务状态段 TSS 段描述符</li><li>调用门描述符</li><li>中断门描述符</li><li>陷阱门描述符</li><li>任务门描述符</li></ul><p>分为两大类：</p><ol><li>系统段描述符：指向系统段</li><li>门描述符：含有对应段的 <strong>段选择符</strong> 和 <strong>段中程序入口点指针</strong></li></ol>',43)]))}const d=i(p,[["render",o],["__file","Chapter 4.3 - 分段机制.html.vue"]]),_=JSON.parse('{"path":"/linux-kernel-comments-notes/Chapter%204%20-%2080X86%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B6%E7%BC%96%E7%A8%8B/Chapter%204.3%20-%20%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6.html","title":"Chapter 4.3 - 分段机制","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"4.3 分段机制","slug":"_4-3-分段机制","link":"#_4-3-分段机制","children":[{"level":3,"title":"4.3.1 段的定义","slug":"_4-3-1-段的定义","link":"#_4-3-1-段的定义","children":[]},{"level":3,"title":"4.3.2 段描述符表","slug":"_4-3-2-段描述符表","link":"#_4-3-2-段描述符表","children":[]},{"level":3,"title":"4.3.3 段选择符","slug":"_4-3-3-段选择符","link":"#_4-3-3-段选择符","children":[]},{"level":3,"title":"4.3.4 段描述符","slug":"_4-3-4-段描述符","link":"#_4-3-4-段描述符","children":[]},{"level":3,"title":"4.3.5 代码和数据段描述符类型","slug":"_4-3-5-代码和数据段描述符类型","link":"#_4-3-5-代码和数据段描述符类型","children":[]},{"level":3,"title":"4.3.6 系统描述符类型","slug":"_4-3-6-系统描述符类型","link":"#_4-3-6-系统描述符类型","children":[]}]}],"git":{},"filePathRelative":"linux-kernel-comments-notes/Chapter 4 - 80X86 保护模式及其编程/Chapter 4.3 - 分段机制.md"}');export{d as comp,_ as data};
