import{_ as a,c as n,a as r,o as s}from"./app-BeHGwf2X.js";const l={};function i(t,e){return s(),n("div",null,e[0]||(e[0]=[r('<h1 id="chapter-1-the-big-picture" tabindex="-1"><a class="header-anchor" href="#chapter-1-the-big-picture"><span>Chapter 1 - The Big Picture</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 06 / 05 0:28</p><p>@Nanjing, Jiangsu, China</p><hr><h2 id="_1-1-levels-and-layers-of-abstraction-in-a-linux-system" tabindex="-1"><a class="header-anchor" href="#_1-1-levels-and-layers-of-abstraction-in-a-linux-system"><span>1.1 Levels and Layers of Abstraction in a Linux System</span></a></h2><p>Linux 系统分为三个等级：</p><ul><li>Hardware - 主存、CPU、设备</li><li>Kernel - 操作系统核心</li><li>User Processes - 内核管理的运行程序</li></ul><p>内核运行于 kernel mode，访问主存和 CPU 不受约束，强大且危险。内核进程可能使整个系统崩溃。用户进程运行于 user mode，受限访问一部分内存和安全的 CPU 操作，内核会清理用户进程的错误。</p><h2 id="_1-2-hardware-understanding-main-memory" tabindex="-1"><a class="header-anchor" href="#_1-2-hardware-understanding-main-memory"><span>1.2 Hardware: Understanding Main Memory</span></a></h2><p>主存是一个存储 0 或 1 的巨大存储区。<em>state</em> 经常被用于形容内存、进程或内核，其实就是特定排列的 bit 序列。</p><p>注意：</p><ul><li><em>state</em> 通常被用于形容 bits 的抽象排列</li><li><em>image</em> 通常被用于形容 bits 的物理排列</li></ul><h2 id="_1-3-the-kernel" tabindex="-1"><a class="header-anchor" href="#_1-3-the-kernel"><span>1.3 The Kernel</span></a></h2><p>内核做的几乎所有事情都和主存有关。内核主要负责四个主要的管理工作：</p><ul><li>进程管理 - 决定哪个进程可以使用 CPU</li><li>存储器管理 - 追踪所有的存储器，哪些被使用，哪些被共享，哪些被回收</li><li>设备驱动管理 - 硬件和进程的接口</li><li>系统调用和支持</li></ul><h3 id="_1-3-1-process-management" tabindex="-1"><a class="header-anchor" href="#_1-3-1-process-management"><span>1.3.1 Process Management</span></a></h3><p>进程管理主要包含了进程的创建、暂停、继续、终结。在任何现代操作系统中，进程 <strong>同时</strong> 运行，但实际上不是在相同的时刻被运行。想象一个单核 CPU，一次只能有一个进程使用 CPU，每个进程使用 CPU 一小段时间。进程将 CPU 控制权交给另一个进程的过程称为 <strong>上下文切换 context switch</strong>。</p><p>每个时间片 (time slice)：给定进程的 CPU 使用时间，通常足够进程完成其目前的工作。然而，由于这个时间片非常小，人类难以察觉出来，从而产生了多个程序正被同时运行的错觉。由内核负责上下文切换：</p><ol><li>CPU 根据内部计时器中断目前的进程，切换到内核模式，将控制权交给内核</li><li>内核记录目前的 CPU 和内存状态 - 用于之后的恢复</li><li>内核处理上一时间片期间发生的 I/O 操作等</li><li>内核就绪，分析进程的 ready list，并选择一个执行</li><li>内核准备新进程的内存空间和 CPU</li><li>内核告诉 CPU 该进程的时间片</li><li>内核将 CPU 切换到 user mode，将 CPU 控制权交给进程</li></ol><p>内核在两个时间片之间的时间内运行。</p><h3 id="_1-3-2-memory-management" tabindex="-1"><a class="header-anchor" href="#_1-3-2-memory-management"><span>1.3.2 Memory Management</span></a></h3><p>内核的存储器管理极为复杂，必须拥有用户空间不可访问的私有空间，每个用户进程需要有自己的内存区域，每个用户进程不能访问其它进程的私有内存。用户进程可以共享内存，部分内存只读。系统可以通过硬盘空间对换，使用比物理空间更多的内存。</p><p>现代 CPU 通过 memory management unit (MMU) 引入了 virtual memory。使用虚存时，进程不直接访问物理内存，内核使每个进程感觉自己正在使用整个内存空间一样。MMU 将虚拟地址映射到实际的物理地址上，内核必须初始化并连续追踪内存映射的变化。内存映射表的实现叫做 page table - 页表。</p><h3 id="_1-3-3-device-drivers-and-management" tabindex="-1"><a class="header-anchor" href="#_1-3-3-device-drivers-and-management"><span>1.3.3 Device Drivers and Management</span></a></h3><p>设备只能在 kernel mode 被访问，设备驱动属于内核的一部分，向用户进程提供统一的接口。</p><h3 id="_1-3-4-system-calls-and-support" tabindex="-1"><a class="header-anchor" href="#_1-3-4-system-calls-and-support"><span>1.3.4 System Calls and Support</span></a></h3><p>两个重要的系统调用：</p><ul><li><code>fork()</code> - 内核创建一个与源进程几乎相同的拷贝</li><li><code>exec()</code> - 内核执行程序，替换现有进程</li></ul><p>shell 的实现流程。</p><h2 id="_1-4-user-space" tabindex="-1"><a class="header-anchor" href="#_1-4-user-space"><span>1.4 User Space</span></a></h2><p>内核分配给用户进程的主存空间成为用户空间，也叫 userland。</p><h2 id="_1-5-user" tabindex="-1"><a class="header-anchor" href="#_1-5-user"><span>1.5 User</span></a></h2><p>用户是运行进程和拥有文件的实体。每个用户关联一个 username，但内核通过唯一的 userids 识别用户。用户的存在主要为了权限和边界管理 - 每个用户空间进程都有一个 owner，进程被 run as owner。用户可以终结或修改自己拥有的进程行为，但不能干涉其它用户进程。root 用户 - superuser：</p><ul><li>终结或修改任意进程</li><li>读取任意文件</li></ul><p>Groups 是 user 的集合，允许一个用户与组中其它用户共享文件访问权限。</p>',36)]))}const p=a(l,[["render",i],["__file","Chapter 1 - The Big Picture.html.vue"]]),h=JSON.parse('{"path":"/how-linux-works-notes/Chapter%201%20-%20The%20Big%20Picture.html","title":"Chapter 1 - The Big Picture","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"1.1 Levels and Layers of Abstraction in a Linux System","slug":"_1-1-levels-and-layers-of-abstraction-in-a-linux-system","link":"#_1-1-levels-and-layers-of-abstraction-in-a-linux-system","children":[]},{"level":2,"title":"1.2 Hardware: Understanding Main Memory","slug":"_1-2-hardware-understanding-main-memory","link":"#_1-2-hardware-understanding-main-memory","children":[]},{"level":2,"title":"1.3 The Kernel","slug":"_1-3-the-kernel","link":"#_1-3-the-kernel","children":[{"level":3,"title":"1.3.1 Process Management","slug":"_1-3-1-process-management","link":"#_1-3-1-process-management","children":[]},{"level":3,"title":"1.3.2 Memory Management","slug":"_1-3-2-memory-management","link":"#_1-3-2-memory-management","children":[]},{"level":3,"title":"1.3.3 Device Drivers and Management","slug":"_1-3-3-device-drivers-and-management","link":"#_1-3-3-device-drivers-and-management","children":[]},{"level":3,"title":"1.3.4 System Calls and Support","slug":"_1-3-4-system-calls-and-support","link":"#_1-3-4-system-calls-and-support","children":[]}]},{"level":2,"title":"1.4 User Space","slug":"_1-4-user-space","link":"#_1-4-user-space","children":[]},{"level":2,"title":"1.5 User","slug":"_1-5-user","link":"#_1-5-user","children":[]}],"git":{},"filePathRelative":"how-linux-works-notes/Chapter 1 - The Big Picture.md"}');export{p as comp,h as data};
