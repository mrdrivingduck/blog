import{_ as a,c as n,a as e,o as l}from"./app-7eKjwDat.js";const c="/blog/assets/3-4-DdU1-L3q.png",i={};function p(t,s){return l(),n("div",null,s[0]||(s[0]=[e(`<h1 id="chapter-3-内核编程语言和环境" tabindex="-1"><a class="header-anchor" href="#chapter-3-内核编程语言和环境"><span>Chapter 3 - 内核编程语言和环境</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 07 / 18 15:53</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="_3-1-as86-汇编器" tabindex="-1"><a class="header-anchor" href="#_3-1-as86-汇编器"><span>3.1 as86 汇编器</span></a></h2><p>Linux 0.1x 系统中使用了两种汇编器：</p><ul><li>产生 16 位代码的 as86 汇编器，配套 ld86 链接器</li><li>GNU 汇编器 gas (as)，配套 GNU ld 链接器</li></ul><p>Linux 仅用 as86 创建两个程序：</p><ul><li>启动引导扇区程序 <code>boot/bootsect.s</code></li><li>实模式下初始设置程序 <code>boot/setup.s</code></li></ul><p>使用了 Intel 汇编语法。</p><h3 id="_3-1-1-as86-汇编语言语法" tabindex="-1"><a class="header-anchor" href="#_3-1-1-as86-汇编语言语法"><span>3.1.1 as86 汇编语言语法</span></a></h3><p>一条汇编语句的组成：</p><ol><li>标号 (可选) - 编译时由汇编器用当前位置计数器赋值</li><li>指令助记符 (指令名)</li><li>操作数</li></ol><p>汇编器产生的目标文件起码包含三个 section：</p><ol><li><code>.text</code> - 正文段 - 包含程序代码和只读数据</li><li><code>.data</code> - 数据段 - 已初始化后的段，包含可读写数据</li><li><code>.bss</code> - 未初始化数据段</li></ol><hr><h2 id="_3-2-gnu-as-汇编" tabindex="-1"><a class="header-anchor" href="#_3-2-gnu-as-汇编"><span>3.2 GNU as 汇编</span></a></h2><p>除了上述提到的两个文件，内核中其余所有汇编程序 (包括 C 语言产生的汇编程序) 均用 gas 编译，并与 C 语言编译产生的模块链接。OS 中的部分关键代码需要很高的执行效率，这部分代码由汇编完成，通常占 10% 左右。</p><h3 id="_3-2-1-编译-as-汇编语言程序" tabindex="-1"><a class="header-anchor" href="#_3-2-1-编译-as-汇编语言程序"><span>3.2.1 编译 as 汇编语言程序</span></a></h3><h3 id="_3-2-2-as-汇编语法" tabindex="-1"><a class="header-anchor" href="#_3-2-2-as-汇编语法"><span>3.2.2 as 汇编语法</span></a></h3><p>为了维持与 gcc 输出汇编程序的兼容性，as 汇编器使用 AT&amp;T 系统 V 的汇编语法。</p><h3 id="_3-2-4-区与重定位" tabindex="-1"><a class="header-anchor" href="#_3-2-4-区与重定位"><span>3.2.4 区与重定位</span></a></h3><p>as 汇编器输出一个目标文件时，目标文件中的代码被默认设置成从地址 0 开始。ld 会在链接过程中为不同目标文件中的各部分分配不同的最终地址。这些部分是以块作为固定单元进行移动的，长度和字节次序都不会改变，这种固定的块被称为 section。为 section 分配运行时刻地址的操作被称为重定位 (Relocation)。</p><hr><h2 id="_3-3-c-语言程序" tabindex="-1"><a class="header-anchor" href="#_3-3-c-语言程序"><span>3.3 C 语言程序</span></a></h2><h3 id="_3-3-1-c-程序编译和链接" tabindex="-1"><a class="header-anchor" href="#_3-3-1-c-程序编译和链接"><span>3.3.1 C 程序编译和链接</span></a></h3><p>C 程序 → 预处理 → 纯 C 程序 → 编译器 → 汇编程序 <code>.s</code> → 汇编器 → 目标文件 <code>.o</code> → 链接器 → 可执行文件</p><h3 id="_3-3-2-嵌入汇编" tabindex="-1"><a class="header-anchor" href="#_3-3-2-嵌入汇编"><span>3.3.2 嵌入汇编</span></a></h3><p>在 C 程序中内联汇编语言</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">&quot;汇编语句&quot;</span></span>
<span class="line">    <span class="token operator">:</span> 输出寄存器</span>
<span class="line">    <span class="token operator">:</span> 输入寄存器</span>
<span class="line">    <span class="token operator">:</span> 会被修改的寄存器</span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例子：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">get_seg_byte</span><span class="token expression"><span class="token punctuation">(</span>seg<span class="token punctuation">,</span> addr<span class="token punctuation">)</span> </span><span class="token punctuation">\\</span></span>
<span class="line"><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span> </span><span class="token punctuation">\\</span></span>
<span class="line"><span class="token expression"><span class="token keyword">register</span> <span class="token keyword">char</span> __res<span class="token punctuation">;</span> </span><span class="token punctuation">\\</span></span>
<span class="line"><span class="token expression"><span class="token function">__asm__</span><span class="token punctuation">(</span></span><span class="token string">&quot;push %%fs; \\</span>
<span class="line">         mov %%ax, %%fs; \\</span>
<span class="line">         movb %%fs:%2, %%a1; \\</span>
<span class="line">         pop %%fs&quot;</span> <span class="token punctuation">\\</span></span>
<span class="line">         <span class="token expression"><span class="token operator">:</span></span><span class="token string">&quot;=a&quot;</span> <span class="token expression"><span class="token punctuation">(</span>__res<span class="token punctuation">)</span> </span><span class="token punctuation">\\</span></span>
<span class="line">         <span class="token expression"><span class="token operator">:</span></span><span class="token string">&quot;0&quot;</span> <span class="token expression"><span class="token punctuation">(</span>seg<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token string">&quot;m&quot;</span> <span class="token expression"><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span> </span><span class="token punctuation">\\</span></span>
<span class="line">       <span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\\</span></span>
<span class="line">       <span class="token expression">__res<span class="token punctuation">;</span> </span><span class="token punctuation">\\</span></span>
<span class="line"><span class="token expression"><span class="token punctuation">}</span><span class="token punctuation">)</span></span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>宏语句需要执行在一行上，因此使用 <code>\\</code> 续行</li><li><code>({})</code> 作为一个表达式使用，最后的 <code>__res</code> 作为表达式的输出值</li><li>用 <code>register</code> 定义一个寄存器变量，该变量将被保存在寄存器中</li><li><code>=a</code> 中的 <code>a</code> 称为加载代码，<code>=</code> 表示这是输出寄存器</li><li>将 <code>eax</code> 寄存器中的内容输出到 <code>__res</code> 中</li></ul><p>功能：从某段的某地址处取一个字节。在执行代码时，如果不希望汇编被 gcc 优化修改，在 asm 符号后添加关键词 volatile：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line">__asm__ <span class="token function">__volatile__</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>该关键词也可以放在函数名前用于修饰函数，通知 gcc 编译器该函数不会返回 - 便于使 gcc 产生更好的代码。</p><h3 id="_3-3-3-圆括号中的组合语句" tabindex="-1"><a class="header-anchor" href="#_3-3-3-圆括号中的组合语句"><span>3.3.3 圆括号中的组合语句</span></a></h3><p>形如 <code>({...})</code> 的语句，可以在 GNU C 中用作一个表达式使用。其中最后一条语句必须是一个以 <code>;</code> 结尾的 <strong>表达式</strong>，作为该组合语句的返回值。如果不是表达式，则整个表达式就是 <code>void</code> 类型。这种语句通常用于定义宏。</p><h3 id="_3-3-4-寄存器变量" tabindex="-1"><a class="header-anchor" href="#_3-3-4-寄存器变量"><span>3.3.4 寄存器变量</span></a></h3><p>GNU 对 C 的另一个扩充 - 允许把变量放到 CPU 寄存器中：</p><ul><li>全局寄存器变量 - 在程序运行过程中保留寄存器专门用于存放全局变量</li><li>局部寄存器变量 - 不会保留指定的寄存器，仅在内联汇编输入输出时使用专门的寄存器</li></ul><p>gcc 编译器的数据流分析有能力确定寄存器何时含有正在使用的值。Linux 内核中通常只使用局部寄存器变量。</p><h3 id="_3-3-5-内联函数" tabindex="-1"><a class="header-anchor" href="#_3-3-5-内联函数"><span>3.3.5 内联函数</span></a></h3><p>让 gcc 把函数代码集成到调用该函数的代码中去，省掉了函数调用时进入 / 退出的时间开销。内联函数是一种优化操作，只有在编译时指定 <code>-O</code> 选项才执行代码嵌入处理。函数中的某些语句用法可能会使得内联函数的替换无法进行，或不适合进行：可变参数、内存分配函数、可变长度数据类型、递归函数。</p><hr><h2 id="_3-4-c-与汇编程序的相互调用" tabindex="-1"><a class="header-anchor" href="#_3-4-c-与汇编程序的相互调用"><span>3.4 C 与汇编程序的相互调用</span></a></h2><h3 id="_3-4-1-c-函数调用机制" tabindex="-1"><a class="header-anchor" href="#_3-4-1-c-函数调用机制"><span>3.4.1 C 函数调用机制</span></a></h3><p>函数调用包含代码块之间的 <strong>双向数据传递</strong> 和 <strong>执行控制转移</strong>。数据传递通过函数参数和返回值进行，进入函数后，还需要为局部变量分配空间；退出函数时，需要回收空间。CPU 提供了简单的指令进行控制转移。</p><h4 id="_3-4-1-1-栈帧结构和控制转移方式" tabindex="-1"><a class="header-anchor" href="#_3-4-1-1-栈帧结构和控制转移方式"><span>3.4.1.1 栈帧结构和控制转移方式</span></a></h4><p><strong>栈</strong> 被用于传递函数参数、存储返回信息、临时保存寄存器现场、存储局部数据。单个函数调用操作使用的栈部分 - <em>栈帧，Stack Frame</em>。栈帧结构的两端由两个指针决定：</p><ul><li><code>ebp</code> 寄存器作为帧指针 (frame pointer) - 地址较高，作为一个栈帧的固定端</li><li><code>esp</code> 寄存器作为栈指针 (strack pointer) - 地址较低，作为一个栈帧的活动端</li><li>栈指针会随着数据入栈出栈而移动，因此数据访问基于固定的帧指针进行</li></ul><p><code>A()</code> 调用 <code>B()</code> 时：</p><ul><li><code>B()</code> 返回后 <code>A()</code> 中的下一条指令地址被压入栈中 (返回地址)</li><li>随后部分是 <code>B()</code> 的栈帧 <ul><li>在 <code>esp</code> 指向的位置 (<code>B()</code> 栈帧的底部) 存放 <code>ebp</code> 的地址 (<code>A()</code> 的帧指针位置)</li><li>将 <code>ebp</code> 赋值为 <code>esp</code> 地址，此时帧指针指向 <code>B()</code> 栈帧的底部</li><li>栈指针开始活动</li><li>函数结束后，将 <code>ebp</code> 恢复为 <code>ebp</code> 指向的单元中保存在 <code>A()</code> 的帧指针位置，此时 <code>ebp</code> 指向了 <code>A()</code> 栈帧的底部</li><li>从栈中弹出保存的返回地址，跳转，继续执行 <code>A()</code></li></ul></li></ul><p><img src="`+c+'" alt="3-4"></p><ul><li><code>CALL</code> 指令保存 <code>CALL</code> 之后的指令地址并跳转到子函数入口</li><li><code>RET</code> 指令弹出返回地址，并跳转到返回地址</li></ul><h3 id="_3-4-2-在汇编程序中调用-c-函数" tabindex="-1"><a class="header-anchor" href="#_3-4-2-在汇编程序中调用-c-函数"><span>3.4.2 在汇编程序中调用 C 函数</span></a></h3><p>程序首先需要按照参数列表逆向顺序将参数压入栈中，然后执行 <code>CALL</code> 指令去执行被调用的函数。函数返回后，程序需要把之前入栈的参数清除。如果调用涉及到代码特权级变化，CPU 会进行堆栈切换，将必要参数压入新堆栈中。</p><p>汇编中调用 C 较为自由，如果没有专门为调用函数压入参数，之前栈中的值也会被作为参数使用。<code>fork()</code> 的实现就用了这一特性。</p><h3 id="_3-4-3-在-c-程序中调用汇编函数" tabindex="-1"><a class="header-anchor" href="#_3-4-3-在-c-程序中调用汇编函数"><span>3.4.3 在 C 程序中调用汇编函数</span></a></h3><p>Linux 内核中不常使用。</p><hr><h2 id="_3-5-linux-0-12-目标文件格式" tabindex="-1"><a class="header-anchor" href="#_3-5-linux-0-12-目标文件格式"><span>3.5 Linux 0.12 目标文件格式</span></a></h2><p>目标文件和可执行文件都用了 UNIX 传统的 <code>a.out</code> 格式：汇编与链接输出格式 (<em>Assembly &amp; Linker editor output</em>)。分为七个区：</p><ul><li>执行头部分 (exec header) - 目标文件的整体结构信息</li><li>代码区 (text segment)</li><li>数据区 (data segment)</li><li>代码重定位部分 (text relocations)</li><li>数据重定位部分 (data relocations)</li><li>符号表部分 (symbol table) - 供链接程序使用</li><li>字符串表部分 (string table) - 用于调试目标代码，与链接过程无关</li></ul>',65)]))}const d=a(i,[["render",p],["__file","Chapter 3 - 内核编程语言和环境.html.vue"]]),r=JSON.parse('{"path":"/linux-kernel-comments-notes/Chapter%203%20-%20%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%8E%AF%E5%A2%83/Chapter%203%20-%20%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%8E%AF%E5%A2%83.html","title":"Chapter 3 - 内核编程语言和环境","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"3.1 as86 汇编器","slug":"_3-1-as86-汇编器","link":"#_3-1-as86-汇编器","children":[{"level":3,"title":"3.1.1 as86 汇编语言语法","slug":"_3-1-1-as86-汇编语言语法","link":"#_3-1-1-as86-汇编语言语法","children":[]}]},{"level":2,"title":"3.2 GNU as 汇编","slug":"_3-2-gnu-as-汇编","link":"#_3-2-gnu-as-汇编","children":[{"level":3,"title":"3.2.1 编译 as 汇编语言程序","slug":"_3-2-1-编译-as-汇编语言程序","link":"#_3-2-1-编译-as-汇编语言程序","children":[]},{"level":3,"title":"3.2.2 as 汇编语法","slug":"_3-2-2-as-汇编语法","link":"#_3-2-2-as-汇编语法","children":[]},{"level":3,"title":"3.2.4 区与重定位","slug":"_3-2-4-区与重定位","link":"#_3-2-4-区与重定位","children":[]}]},{"level":2,"title":"3.3 C 语言程序","slug":"_3-3-c-语言程序","link":"#_3-3-c-语言程序","children":[{"level":3,"title":"3.3.1 C 程序编译和链接","slug":"_3-3-1-c-程序编译和链接","link":"#_3-3-1-c-程序编译和链接","children":[]},{"level":3,"title":"3.3.2 嵌入汇编","slug":"_3-3-2-嵌入汇编","link":"#_3-3-2-嵌入汇编","children":[]},{"level":3,"title":"3.3.3 圆括号中的组合语句","slug":"_3-3-3-圆括号中的组合语句","link":"#_3-3-3-圆括号中的组合语句","children":[]},{"level":3,"title":"3.3.4 寄存器变量","slug":"_3-3-4-寄存器变量","link":"#_3-3-4-寄存器变量","children":[]},{"level":3,"title":"3.3.5 内联函数","slug":"_3-3-5-内联函数","link":"#_3-3-5-内联函数","children":[]}]},{"level":2,"title":"3.4 C 与汇编程序的相互调用","slug":"_3-4-c-与汇编程序的相互调用","link":"#_3-4-c-与汇编程序的相互调用","children":[{"level":3,"title":"3.4.1 C 函数调用机制","slug":"_3-4-1-c-函数调用机制","link":"#_3-4-1-c-函数调用机制","children":[]},{"level":3,"title":"3.4.2 在汇编程序中调用 C 函数","slug":"_3-4-2-在汇编程序中调用-c-函数","link":"#_3-4-2-在汇编程序中调用-c-函数","children":[]},{"level":3,"title":"3.4.3 在 C 程序中调用汇编函数","slug":"_3-4-3-在-c-程序中调用汇编函数","link":"#_3-4-3-在-c-程序中调用汇编函数","children":[]}]},{"level":2,"title":"3.5 Linux 0.12 目标文件格式","slug":"_3-5-linux-0-12-目标文件格式","link":"#_3-5-linux-0-12-目标文件格式","children":[]}],"git":{},"filePathRelative":"linux-kernel-comments-notes/Chapter 3 - 内核编程语言和环境/Chapter 3 - 内核编程语言和环境.md"}');export{d as comp,r as data};
