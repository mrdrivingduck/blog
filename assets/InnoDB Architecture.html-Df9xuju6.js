import{_ as r,c as a,a as n,o as t}from"./app-7eKjwDat.js";const l={};function i(h,e){return t(),a("div",null,e[0]||(e[0]=[n('<h1 id="innodb-architecture" tabindex="-1"><a class="header-anchor" href="#innodb-architecture"><span>InnoDB - Architecture</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 10 / 09 11:18</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction"><span>Introduction</span></a></h2><p>InnoDB 从 MySQL 5.5 开始是默认的表存储引擎。该存储引擎支持事务，并且是第一个完整支持 ACID 事务的 MySQL 存储引擎。特点是：</p><ul><li>行锁设计</li><li>支持 <em>多版本并发控制 (MVCC)</em></li><li>支持外键、一致性非锁定读</li><li>高效利用内存和 CPU</li></ul><p>创始人为 <em>Teikki Tuuri</em>，毕业于芬兰 <em>赫尔辛基大学</em>。</p><p>InnoDB 是一个高性能、高可用、高可扩展的存储引擎，设计目标面向 OLTP 场景。</p><blockquote><p>OLTP (On-Line Transaction Processing)，联机事务处理 / OLAP (On-Line Analytical Processing) 联机分析处理</p></blockquote><h2 id="architecture" tabindex="-1"><a class="header-anchor" href="#architecture"><span>Architecture</span></a></h2><p>InnoDB 存储引擎中有一个大的内存池，包含大量的 <strong>内存块</strong>。这些内存块的功能如下：</p><ul><li>维护进程 / 线程的数据结构</li><li>缓存磁盘数据 (读 / 写)</li><li>Redo 日志的 buffer</li></ul><p>MySQL 表现为单进程多线程架构。多个后台线程负责刷新内存池中的数据，并将内存池中已被修改的数据刷新到磁盘上的文件中，保证数据库发生异常的情况下 InnoDB 能恢复到正常运行的状态。</p><h2 id="threads" tabindex="-1"><a class="header-anchor" href="#threads"><span>Threads</span></a></h2><h3 id="master-thread" tabindex="-1"><a class="header-anchor" href="#master-thread"><span>Master Thread</span></a></h3><p>核心后台线程，负责将内存池中的数据异步刷新到磁盘，保证数据的一致性。</p><h3 id="i-o-thread" tabindex="-1"><a class="header-anchor" href="#i-o-thread"><span>I/O Thread</span></a></h3><p>使用 <em>AIO (Async I/O)</em> 来处理写 I/O，以极大提升数据库性能。这个线程就是异步 I/O 的 call back。包含不同类型的 I/O 线程：</p><ul><li>Write I/O thread</li><li>Read I/O thread</li><li>Insert buffer I/O thread</li><li>Log I/O thread</li></ul><p>线程的个数可以进行调整。</p><h3 id="purge-thread" tabindex="-1"><a class="header-anchor" href="#purge-thread"><span>Purge Thread</span></a></h3><p>事务在被提交后，回滚需要用到的 undo 日志不再需要，由该线程回收已经分配并使用的 undo 页面。该线程要做的事情原先由 master thread 完成，现在独立到了单独的线程中，从而提高 CPU 利用率。多个 purge thread 离散地读取多个 undo 页可以进一步利用磁盘的随机读取性能。</p><h3 id="page-cleaner-thread" tabindex="-1"><a class="header-anchor" href="#page-cleaner-thread"><span>Page Cleaner Thread</span></a></h3><p>将 master thread 中原先的脏页刷新工作独立到这个单独的线程中，减轻 master thread 对用户查询线程的阻塞。</p><h2 id="memory" tabindex="-1"><a class="header-anchor" href="#memory"><span>Memory</span></a></h2><h3 id="缓冲池管理" tabindex="-1"><a class="header-anchor" href="#缓冲池管理"><span>缓冲池管理</span></a></h3><p>InnoDB 存储引擎是基于磁盘存储的，其中的记录以 <strong>页</strong> 为单位进行管理，是一个 <em>Disk-base Database</em>。这类 DBMS 通常使用缓冲池技术来提升整体性能。</p><p>当对数据库进行页读取操作时，首先将磁盘读到的页 <em>FIX</em> 到缓冲池中，下次读取相同页时，如果该页在缓冲池中，就可以被直接读取 (磁盘操作变为内存操作)。</p><p>对于页面的修改操作，直接修改内存缓冲池中的页，再以一定的频率写回磁盘。写回磁盘的策略并不是每修改一个页就触发，而是以 Checkpoint 机制作为触发时机。</p><p>缓冲池的大小直接影响数据库的整体性能，通过参数可配置。另外，InnoDB 还允许有多个缓冲池实例，每个页根据哈希映射到不同的缓冲池实例上，以减少数据库内部的资源竞争，增加数据库的并发处理能力。</p><p>缓冲池中缓存的页类型：</p><ul><li>索引页 + 数据页 (占大头)</li><li>Undo 页</li><li>Insert buffer 页</li><li>自适应哈希索引页</li><li>InnoDB 锁信息页</li><li>数据字典页</li><li>...</li></ul><p>上述的内存缓冲池 (不包括后几种内存页) 是通过 LRU (Least Recently Used) 算法来进行管理的 - 最频繁使用的页位于 LRU 列表的前端，最少使用的页位于 LRU 列表尾部。当缓冲池中的页不够用时，优先淘汰处于 LRU 列表尾部的页。InnoDB 默认页大小为 16KB。</p><p>InnoDB 对朴素的 LRU 算法进行了改进，引入了一个所谓 <strong>midpoint</strong> 的位置。一个新读取的页，虽然是被最新访问的，但并不是放到 LRU 列表的首部，而是放入 LRU 列表的 midpoint 位置。这个位置默认位于 <strong>LRU 列表长度的 5/8 处</strong>，也就是尾端 37% 的位置，可以用参数进行配置。在 InnoDB 中，midpoint 之后的列表称为 old 列表，之前的列表称为 new 列表，显而易见 new 列表中的数据都是最为活跃的热点数据 (让我联想到了 JVM 中的新生代和老生代)。</p><p>这种改进的用意何在？某些 SQL 操作会大量扫描页 (甚至扫描所有的页)，比如索引或数据扫描，但是这些页只会在这次查询中被用到。如果这些页直接进入 LRU 首部，那么大量热点数据将会被挤出 LRU，从而引发额外的 I/O 操作。为了解决这个问题，InnoDB 引入另一个参数 <code>innodb_old_blocks_time</code> 来管理 LRU 列表，表示一个页在进入 old 列表多久之后可以进入 LRU 的 new 列表。DBA 可以预估自己的热点数据比例调整参数 (甚至可以在执行某条 SQL 语句前)，减少热点页可能被刷出的概率。</p><p>数据库启动时，LRU 列表是空的，所有的页都位于 Free 列表中。需要缓冲页时，首先从 Free 列表中查找是否有可用的空闲页，若有，则从 Free 列表中删除并加入 LRU 列表中。否则，根据 LRU 算法淘汰 LRU 列表末尾的策略。页从 LRU 列表的 old 部分加入的 new 部分的操作称为 <em>Page Made Young</em>。另外 InnoDB 还会维护一些缓冲池运行状态的变量，DBA 可以根据这些变量判断缓冲池的运行状态 - 比如，缓冲池命中率不应当低于 95%。</p><p>InnoDB 支持 <strong>压缩页</strong> 的功能，即原先的 16KB 页压缩为 1KB、2KB、4KB 和 8KB。非 16KB 页由一个单独的列表进行管理。由于每个页的压缩比例不同，该列表通过 <em>伙伴算法</em> 对不同大小的页进行管理。</p><blockquote><p><a href="https://www.jianshu.com/p/d0c51cc592bf" target="_blank" rel="noopener noreferrer"><em>伙伴算法</em></a> 在 Linux 内存管理中也有运用。大致思想是维护多个不同块大小的链表，根据申请分配的内存大小，按需分配，以解决内存碎片的问题，主要面向大块内存的分配。小块内存的分配由 slab 内存分配器负责。</p></blockquote><p>当 LRU 列表中的页被写操作修改后，就会成为所谓的 dirty page，需要通过 checkpoint 机制将这些页写回磁盘中。Flush 列表中的页就是所有脏页。脏页同时存在于 LRU 列表和 flush 列表中，两个列表分工不同，互不影响。</p><h3 id="redo-日志缓冲" tabindex="-1"><a class="header-anchor" href="#redo-日志缓冲"><span>Redo 日志缓冲</span></a></h3><p>InnoDB 存储引擎首先将 redo log 存放在这个缓冲区中，然后以一定频率写回到 redo log 文件。写回的发生时机有：</p><ul><li>Master thread 的每秒刷新</li><li>每个事务提交时的刷新</li><li>Redo log buffer 剩余空间低于 1/2</li></ul><h3 id="额外内存池" tabindex="-1"><a class="header-anchor" href="#额外内存池"><span>额外内存池</span></a></h3><p>缓冲池本身以外的数据结构，比如 LRU、锁等信息，会在额外的内存池中申请。当缓冲池的容量增加时，DBA 也需要考虑酌情增加额外内存池的值。</p><hr>',47)]))}const o=r(l,[["render",i],["__file","InnoDB Architecture.html.vue"]]),s=JSON.parse('{"path":"/notes/MySQL/InnoDB%20Architecture.html","title":"InnoDB - Architecture","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Introduction","slug":"introduction","link":"#introduction","children":[]},{"level":2,"title":"Architecture","slug":"architecture","link":"#architecture","children":[]},{"level":2,"title":"Threads","slug":"threads","link":"#threads","children":[{"level":3,"title":"Master Thread","slug":"master-thread","link":"#master-thread","children":[]},{"level":3,"title":"I/O Thread","slug":"i-o-thread","link":"#i-o-thread","children":[]},{"level":3,"title":"Purge Thread","slug":"purge-thread","link":"#purge-thread","children":[]},{"level":3,"title":"Page Cleaner Thread","slug":"page-cleaner-thread","link":"#page-cleaner-thread","children":[]}]},{"level":2,"title":"Memory","slug":"memory","link":"#memory","children":[{"level":3,"title":"缓冲池管理","slug":"缓冲池管理","link":"#缓冲池管理","children":[]},{"level":3,"title":"Redo 日志缓冲","slug":"redo-日志缓冲","link":"#redo-日志缓冲","children":[]},{"level":3,"title":"额外内存池","slug":"额外内存池","link":"#额外内存池","children":[]}]}],"git":{},"filePathRelative":"notes/MySQL/InnoDB Architecture.md"}');export{o as comp,s as data};
