import{_ as n,c as a,a as e,o as l}from"./app-BeHGwf2X.js";const t={};function c(p,s){return l(),a("div",null,s[0]||(s[0]=[e(`<h1 id="chapter-17-集群" tabindex="-1"><a class="header-anchor" href="#chapter-17-集群"><span>Chapter 17 - 集群</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 06 / 15 16:15</p><p>Nanjing, Jiangsu, China</p><hr><p>Redis 集群是 Redis 提供的分布式数据解决方案。集群通过分片 (sharding) 来进行数据共享。</p><blockquote><p>大致思想与 HDFS 有些类似。</p></blockquote><h2 id="node" tabindex="-1"><a class="header-anchor" href="#node"><span>Node</span></a></h2><p>一个 Redis 集群由多个结点组成。需要将多个独立的结点连接起来，构成一个包含多个结点的集群。一个结点就是一个运行在 <strong>集群模式</strong> 下的 Redis 服务器，在该模式下，结点会继续使用单机模式中使用的服务器组件：</p><ul><li>文件事件处理器</li><li>时间时间处理器</li><li>数据库</li><li>RDB、AOF 持久化</li><li>发布/订阅模块</li><li>结点复制模块</li><li>Lua 脚本环境</li></ul><p>每个结点会为自身状态建立一个 <code>clusterNode</code> 结构体；也会为集群中的其它结点建立该结构体，用来记录其它结点的状态：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">mstime_t</span> ctime<span class="token punctuation">;</span> <span class="token comment">// 结点创建时间</span></span>
<span class="line">    <span class="token keyword">char</span> name<span class="token punctuation">[</span>REDIS_CLUSTER_NAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 结点名称</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">int</span> flags<span class="token punctuation">;</span> <span class="token comment">// 结点标识</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name">uint64_t</span> configEpoch<span class="token punctuation">;</span> <span class="token comment">// 结点当前配置纪元</span></span>
<span class="line">    <span class="token keyword">char</span> ip<span class="token punctuation">[</span>REDIS_IP_STR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 结点 IP 地址</span></span>
<span class="line">    <span class="token keyword">int</span> port<span class="token punctuation">;</span> <span class="token comment">// 结点端口号</span></span>
<span class="line"></span>
<span class="line">    clusterLink <span class="token operator">*</span>link<span class="token punctuation">;</span> <span class="token comment">// 连接结点的相关信息</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，<code>clusterLink</code> 结构保存了结点连接的相关信息：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterLink</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">mstime_t</span> ctime<span class="token punctuation">;</span> <span class="token comment">// 连接的创建时间</span></span>
<span class="line">    <span class="token keyword">int</span> fd<span class="token punctuation">;</span> <span class="token comment">// TCP socket 描述符</span></span>
<span class="line">    sds sndbuf<span class="token punctuation">;</span> <span class="token comment">// 输出缓冲区 (等待发送给其它结点的信息)</span></span>
<span class="line">    sds rcvbuf<span class="token punctuation">;</span> <span class="token comment">// 输入缓冲区 (从其它结点接收到的信息)</span></span>
<span class="line"><span class="token punctuation">}</span> clusterLink<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个结点还保存了一个 <code>clusterState</code> 结构，记录了当前结点视角下的集群状态：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterState</span> <span class="token punctuation">{</span></span>
<span class="line">    clusterNode <span class="token operator">*</span>myself<span class="token punctuation">;</span> <span class="token comment">// 指向当前结点</span></span>
<span class="line">    <span class="token class-name">uint64_t</span> currentEpoch<span class="token punctuation">;</span> <span class="token comment">// 集群当前配置纪元</span></span>
<span class="line">    <span class="token keyword">int</span> state<span class="token punctuation">;</span> <span class="token comment">// 集群状态 (上线 / 下线)</span></span>
<span class="line">    <span class="token keyword">int</span> size<span class="token punctuation">;</span> <span class="token comment">// 集群中至少处理着一个 slot 的结点数量</span></span>
<span class="line">    dict <span class="token operator">*</span>nodes<span class="token punctuation">;</span> <span class="token comment">// 集群结点名单 (key 为结点名字，value 为结点 clusterState 结构体)</span></span>
<span class="line"><span class="token punctuation">}</span> clusterState<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将结点添加到集群中使用 <code>CLUSTER MEET</code> 命令。收到命令的集群结点 A 与待加入结点 B 进行握手，以确认彼此的存在。</p><ul><li>结点 A 为结点 B 创建一个 <code>clusterNode</code> 结构，并添加到自己的 <code>clusterState.nodes</code> 字典中</li><li>结点 A 向结点 B 的 IP + 端口号，向结点 B 发送一条 <code>MEET</code> 消息</li><li>结点 B 也同样创建 <code>clusterNode</code> 维护结点 A 的元信息，返回结点 A <code>PONG</code> 信息</li><li>结点 A 接收到 <code>PONG</code> 信息后，知道结点 B 已经接收了自己的信息，再返回结点 B <code>PING</code> 信息</li><li>结点 B 接收到 <code>PING</code> 信息后，直到结点 A 已经接收了自己的信息，握手完成</li></ul><h2 id="slot-dispatch" tabindex="-1"><a class="header-anchor" href="#slot-dispatch"><span>Slot Dispatch</span></a></h2><p>Redis 通过分片的方式保存数据库中的键值对。通俗来说就是把部分的 key 放在一个结点上，把另一部分的 key 放在另一个结点上。key 的整体空间被称为 <strong>槽 (slot)</strong>，整个数据库被分为 16384 个 slot，每一个 key 都可以映射到其中的一个 slot 上。一个上线状态的集群，应当共同负责处理 16384 slot 中的所有 slot。如果有一个 slot 没有被任何结点负责，那么集群就处于下线状态 (fail)。</p><p>结点 <code>clusterNode</code> 结构中记录了结点负责处理哪些 slot：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">int</span> numslots<span class="token punctuation">;</span> <span class="token comment">// 结点负责处理的 slot 数量</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中的 <code>slots</code> 显然又是一个 bitmap，如果某一 bit 为 1，说明结点正在负责处理这个 slot。</p><p>结点会不断通过消息通知其它结点自己负责的 slot 有哪些，接收到消息的结点更新 <code>clusterNode</code> 中记录的信息。在每个结点的集群状态 <code>clusterState</code> 结构体中记录了整个集群 16384 个 slot 的指派信息，每个 slot 都对应一个指向 <code>clusterNode</code> 的指针：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterState</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line">    clusterNode <span class="token operator">*</span>slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述设计可以高效地进行双向查询：</p><ul><li>已知 slot，查询其被指派到的结点</li><li>已知结点，查询其负责的 slots</li></ul><p>通过 <code>CLUSTER ADDSLOTS</code> 命令对结点负责的 slot 进行修改。显然，在命令的实现中，需要修改结点维护的上述结构体。</p><h2 id="execute-commands-in-cluster" tabindex="-1"><a class="header-anchor" href="#execute-commands-in-cluster"><span>Execute Commands in Cluster</span></a></h2><p>在数据库的 16384 个 slot 都有结点负责后，集群就开始进入上线状态，客户端可以向集群中的结点发送数据命令。接收命令的结点根据 key 计算出 key 所在的 slot 被哪个结点负责：</p><ul><li>如果 key 对应的 slot 刚好被自身结点负责，那么结点直接执行这个命令</li><li>如果 key 对应的 slot 被其它结点负责，则向客户端返回一个 <code>MOVED</code> 错误，指引客户端重定向到正确的结点</li></ul><p>结点计算 key 对应 slot 的算法 (计算 CRC16 校验和)：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">return CRC16(key) &amp; 16383;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>然后判断 <code>clusterState</code> 结构体中，负责这个 slot 的结点指针是否指向自己。如果不是，则在 <code>MOVED</code> 错误中向客户端返回负责这个 slot 的结点的 IP 和端口号。在集群模式的 redis-cli 客户端中，<code>MOVED</code> 错误实际上会被隐藏，自动进行结点重定向。</p><p>结点还会使用跳跃表来保存集群中 slot 和 key 之间的关系。跳跃表的 score 是 slot 编号，member 是数据库中的 key：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterState</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line">    zskiplist <span class="token operator">*</span>slots_to_keys<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="重新分片" tabindex="-1"><a class="header-anchor" href="#重新分片"><span>重新分片</span></a></h2><p>Redis 集群的重新分片操作可以将任意数量的已指派 slot 改为指派到另一个结点，相应的数据也会随即转移。重新分片操作可以在线进行。Redis 的集群管理软件 <em>redis-trib</em> 负责重新分片操作：</p><ul><li>让目标结点准备好被导入的 slot</li><li>让源结点准备好 slot 的迁移</li><li>从源结点获取最多 count 个属于 slot 的 key</li><li>对于上述每个 key，将 key 原子地迁移到目标结点</li><li>直到 slot 对应的所有 key 都被迁移成功</li></ul><h2 id="ask-error" tabindex="-1"><a class="header-anchor" href="#ask-error"><span>ASK Error</span></a></h2><p>在迁移 slot 的过程中，如果有客户端的数据请求怎么办？</p><ul><li>源结点首先在自己的数据库中查找，如果能够找到，就直接返回客户端</li><li>源结点没能在自己的数据库里找到 key，则向客户端返回 ASK 错误，指引客户端重定向到目标结点再次执行命令</li></ul><p>源结点检查集群状态的 <code>clusterState.migrating_slots_to[i]</code>，查看 key 对应的 slot i 是否正在进行迁移。如果正在迁移，则返回 ASK 错误。假设此时迁移正在进行，slot i 还没有正式由目标结点负责。此时，如果 key 已经被迁移到了目标结点上，那么对目标结点的访问将会导致 <code>MOVED</code> 错误。因为目标结点的 <code>clusterState.importing_slots_from[i]</code> 显示结点正在导入一个 slot。如果客户端在发送命令之前，提前发送一个 <code>ASKING</code> 命令，会打开客户端的 <code>REDIS_ASKING</code> 标识，目标结点将破例执行之后的命令一次。<code>ASKING</code> 命令带来的效果是 <strong>一次性的</strong>。</p><p>因此，在客户端接收到 <code>ASK</code> 错误时，需要先向目标结点发送一个 <code>ASKING</code> 命令，再重新发送想要执行的命令。</p><h2 id="复制与故障转移" tabindex="-1"><a class="header-anchor" href="#复制与故障转移"><span>复制与故障转移</span></a></h2><p>Redis 集群中的结点也是分主从的。主结点用于负责 slot，从结点用于复制某个主结点。为一个主结点设置从结点后，主从结点分别会维护对方的信息，这些信息也会被传播到集群中。最终，集群中的所有结点都会知道某个从结点正在复制某个主结点。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token operator">*</span>slaveof<span class="token punctuation">;</span> <span class="token comment">// 从结点指向主结点</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line">    <span class="token keyword">int</span> numslaves<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token operator">*</span><span class="token operator">*</span>slaves<span class="token punctuation">;</span> <span class="token comment">// 主结点指向其所有从结点</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>集群中的每个结点会定期地向集群中的其它结点发送 <code>PING</code> 信息，以检测对方是否在线。如果结点没有在规定的时间内返回 <code>PONG</code>，那么结点就被视为进入 <strong>疑似下线状态</strong>，疑似下线的结点会被添加到 <code>clusterNode</code> 结构的 <code>fail_reports</code> 链表中：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line">    list <span class="token operator">*</span>fail_reports<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token class-name">clusterNodeFailReport</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token operator">*</span>node<span class="token punctuation">;</span> <span class="token comment">// 已下线结点</span></span>
<span class="line">    <span class="token class-name">mstime_t</span> time<span class="token punctuation">;</span> <span class="token comment">// 最后一次从结点收到下线报告的时间</span></span>
<span class="line"><span class="token punctuation">}</span> <span class="token keyword">typedef</span> clusterNodeFailReport<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果集群中半数以上主结点都判断某个主结点进入疑似下线状态，那么该结点将会被标记为已下线，并被集群广播，开始进行故障转移：</p><ol><li>下线主结点的所有从结点里，选出一个</li><li>被选出的从结点成为新的主结点</li><li>新的主结点撤销所有对原主结点的 slot 指派，并将这些 slot 全部指派给自己</li><li>新的主结点向集群广播 <code>PONG</code>，通知集群自己已接管了原主结点负责的 slot</li><li>故障转移完成，新的主结点开始接收对自己负责处理的 slot 的命令请求</li></ol><p>新的主结点是通过选举产生的。下线主结点的从服务器发现其主服务器下线后，开始向所有其它主服务器拉票。投票的具体方式与 Sentinel 非常相似，基于配置纪元，进行一轮一轮的投票，直到某个从结点得到了多余半数主结点的投票。</p>`,53)]))}const o=n(t,[["render",c],["__file","Chapter 17 - 集群.html.vue"]]),d=JSON.parse('{"path":"/redis-implementation-notes/Part%203%20-%20%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/Chapter%2017%20-%20%E9%9B%86%E7%BE%A4.html","title":"Chapter 17 - 集群","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Node","slug":"node","link":"#node","children":[]},{"level":2,"title":"Slot Dispatch","slug":"slot-dispatch","link":"#slot-dispatch","children":[]},{"level":2,"title":"Execute Commands in Cluster","slug":"execute-commands-in-cluster","link":"#execute-commands-in-cluster","children":[]},{"level":2,"title":"重新分片","slug":"重新分片","link":"#重新分片","children":[]},{"level":2,"title":"ASK Error","slug":"ask-error","link":"#ask-error","children":[]},{"level":2,"title":"复制与故障转移","slug":"复制与故障转移","link":"#复制与故障转移","children":[]}],"git":{},"filePathRelative":"redis-implementation-notes/Part 3 - 多机数据库的实现/Chapter 17 - 集群.md"}');export{o as comp,d as data};
