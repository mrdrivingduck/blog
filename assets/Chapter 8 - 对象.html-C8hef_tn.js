import{_ as n,c as s,a,o as i}from"./app-7eKjwDat.js";const l={};function c(o,e){return i(),s("div",null,e[0]||(e[0]=[a(`<h1 id="chapter-8-对象" tabindex="-1"><a class="header-anchor" href="#chapter-8-对象"><span>Chapter 8 - 对象</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 06 / 01 19:03</p><p>Nanjing, Jiangsu, China</p><hr><p>Redis 利用之前章节中的数据结构实现了一个类型系统，并在命令执行前，根据对象的类型来判断对象能否执行该命令。另外，可以针对不同的使用场景，为对象设置不同的底层数据结构，从而优化不同场景下的使用效率。</p><h2 id="object-type-and-encoding" tabindex="-1"><a class="header-anchor" href="#object-type-and-encoding"><span>Object Type and Encoding</span></a></h2><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span> <span class="token comment">// 指向底层数据结构</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span> robj<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对象类型有：</p><ul><li><code>REDIS_STRING</code> - 字符串对象</li><li><code>REDIS_LIST</code> - 列表对象</li><li><code>REDIS_HASH</code> - 哈希对象</li><li><code>REDIS_SET</code> - 集合对象</li><li><code>REDIS_ZSET</code> - 有序集合对象</li></ul><p>而 <code>encoding</code> 属性记录了底层数据结构 <code>ptr</code> 具体由什么数据结构实现。Encoding 可以有：</p><ul><li><code>REDIS_ENCODING_INT</code></li><li><code>REDIS_ENCODING_EMBSTR</code> - embstr 编码的 SDS 字符串</li><li><code>REDIS_ENCODING_RAW</code> - SDS 字符串</li><li><code>REDIS_ENCODING_HT</code> - 字典</li><li><code>REDIS_ENCODING_LINKEDLIST</code> - 双向链表</li><li><code>REDIS_ENCODING_ZIPLIST</code> - 压缩列表</li><li><code>REDIS_ENCODING_INTSET</code> - 整数集合</li><li><code>REDIS_ENCODING_SKIPLIST</code> - 跳跃表和字段</li></ul><p>每种对象类型都至少使用了两种不同的编码实现。Redis 可以根据不同的使用场景来为对象设置不同的编码，极大提升了灵活性和效率。</p><p>Redis 中所有的 key 都是字符串对象，而 value 可以是任意对象。当称呼一个数据库键为 XX 键时，实际上指的是 value 对应 XX 类型的对象。</p><h2 id="redis-string" tabindex="-1"><a class="header-anchor" href="#redis-string"><span>Redis String</span></a></h2><p>字符串对象的编码有三种：</p><ul><li>int</li><li>raw</li><li>embstr</li></ul><p>其中，int 对应一个可以表示为数字的字符串。那么直接将这个数字存储在 <code>ptr</code> 所占用的空间中 (不当指针用了)；如果字符串的长度 &gt; 39B，那么使用 SDS 来保存，编码类型为 raw。</p><p>如果字符串的长度 &lt; 39B，使用专门用于优化短字符串的 embstr 编码方式。这种编码方式下，redisObject 的内存空间与其中 <code>ptr</code> 指针指向的 SDS 内存空间将通过一次内存分配直接分配完毕：</p><ul><li>只需要一次内存分配</li><li>只需要一次内存回收</li><li>对象和字符串值保存在连续的内存中，可以利用缓存带来的性能优势</li></ul><h3 id="encoding-conversion" tabindex="-1"><a class="header-anchor" href="#encoding-conversion"><span>Encoding Conversion</span></a></h3><p>三种类型编码的字符串，在经过字符串修改之后，可能必须要进行编码转换。比如，当一个 int 编码的字符串被 append 了一些字母，或是 embstr 被 append (embstr 编码的字符串是只读的)，字符串的编码都会转换为 raw。</p><h2 id="list-object" tabindex="-1"><a class="header-anchor" href="#list-object"><span>List Object</span></a></h2><p>列表对象的编码可以为：</p><ul><li>ziplist</li><li>linkedlist</li></ul><h3 id="encoding-conversion-1" tabindex="-1"><a class="header-anchor" href="#encoding-conversion-1"><span>Encoding Conversion</span></a></h3><ul><li>列表中所有字符串元素的长度都 &lt; 64B</li><li>列表中保存的元素数量 &lt; 512 个</li></ul><p>当这两个条件无法被满足时，就只能使用双向链表编码。这两个阈值可以在配置中修改。</p><h2 id="hash-object" tabindex="-1"><a class="header-anchor" href="#hash-object"><span>Hash Object</span></a></h2><p>哈希对象的编码方式可以为 ziplist 或 hash table。</p><p>如果使用 ziplist 编码，那么 key 和 value 将会作为紧挨着的两个结点加入到压缩列表的表尾。</p><p>如果使用 hash table，那么 key 对象将会被存放在 hash table 数组中，value 对象将会被 hash table 结点的指针引用。</p><h3 id="encoding-conversion-2" tabindex="-1"><a class="header-anchor" href="#encoding-conversion-2"><span>Encoding Conversion</span></a></h3><ul><li>所有 key 和 value 的字符串长度都 &lt; 64B</li><li>键值对数量 &lt; 512</li></ul><p>当这两个条件无法被满足时，就只能使用 hash table 编码。这两个阈值可以在配置中修改。</p><h2 id="collection-object" tabindex="-1"><a class="header-anchor" href="#collection-object"><span>Collection Object</span></a></h2><p>集合对象的编码为 intset 或 hash table。</p><h3 id="encoding-conversion-3" tabindex="-1"><a class="header-anchor" href="#encoding-conversion-3"><span>Encoding Conversion</span></a></h3><ul><li>集合中所有元素都是整数值</li><li>集合中保存的元素数量不超过 512 个</li></ul><p>不能满足以上条件的集合只能使用 hash table 编码。</p><h2 id="ordered-collection-object" tabindex="-1"><a class="header-anchor" href="#ordered-collection-object"><span>Ordered Collection Object</span></a></h2><p>有序集合对象的编码只能使用 ziplist 或 skiplist。</p><p>当使用 ziplist 保存时，两个紧挨着的结点分别用于保存元素的 member 和 score。集合元素按 score 从小到大进行排序，score 较大的元素靠近表尾。</p><p>而 skiplist 编码使用以下结构作为底层实现：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zset</span> <span class="token punctuation">{</span></span>
<span class="line">    zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">;</span></span>
<span class="line">    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span> zset<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，<code>zsl</code> 跳跃表结构按照 score 从小到大保存了所有集合元素 - 跳跃表结点的 <code>obj</code> 属性保存 member，<code>score</code> 属性保存分值；另外，<code>dict</code> 结构以 key-value pair 的形式保存了每一个集合元素：</p><ul><li>key 对应元素 member</li><li>value 对应元素 score</li></ul><p>这样可以以 O(1) 的时间复杂度查找 member 的 score。</p><p>另外，这两个数据结构通过指针共享相同的元素内存，而不是引用不同的副本。</p><blockquote><p>理论上，这种复合实现方式的性能会比任意一种单独实现的方式要好。跳跃表保证了 <strong>有序性</strong> 以及 <strong>范围查询</strong> 的性能；而字典则保证了能以 O(1) 的时间复杂度查询 score，否则跳跃表就只能以 O(n * log(n)) 来查询元素的 score。</p></blockquote><h3 id="encoding-conversion-4" tabindex="-1"><a class="header-anchor" href="#encoding-conversion-4"><span>Encoding Conversion</span></a></h3><ul><li>有序集合保存的元素个数 &lt; 128</li><li>有序集合保存的元素 member 的长度都 &lt; 64B</li></ul><p>如果不能满足这两个条件，那么有序集合对象只能使用 skiplist 编码。</p><hr><h2 id="type-check" tabindex="-1"><a class="header-anchor" href="#type-check"><span>Type Check</span></a></h2><p>为了保证只有指定类型的值可以执行某些特定命令，Redis 首先会检查输入的类型是否正确 - 由检查 <code>redisObject</code> 结构体的 <code>type</code> 属性实现。</p><h2 id="polymorphism" tabindex="-1"><a class="header-anchor" href="#polymorphism"><span>Polymorphism</span></a></h2><p>Redis 根据对象的编码方式，来选择一个操作的具体实现方式。比如说，对于字符串对象，int 编码和 SDS 编码的字符串，取得其长度的方式显然不同。所以可以认为一些命令是 <strong>多态</strong> 的 - 根据编码方式的不同，相同的对象操作将有不同的行为。</p><h2 id="reference-counting" tabindex="-1"><a class="header-anchor" href="#reference-counting"><span>Reference Counting</span></a></h2><p>Redis 在每个对象的结构体中保存了引用计数：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line">    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span> robj<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>创建新对象时，引用计数被初始化为 1</li><li>++</li></ul><hr><ul><li>引用计数为 0 时，对象占用的内存将被释放</li></ul><h2 id="object-sharing" tabindex="-1"><a class="header-anchor" href="#object-sharing"><span>Object Sharing</span></a></h2><p>对于可以共享的对象，比如两个 key 指向了相同的 value，共享内存可以有效节约内存。在共享前，需要将被共享对象的引用计数 +1。</p><p>目前，Redis 在初始化服务器时，会创建 <code>0</code> - <code>9999</code> 的字符串对象。当服务器需要使用这些对象时，将使用共享对象，而不再重新创建对象。Redis 只对包含整数值的字符串变量进行共享 (因为验证其它字符串是否相等的开销太大)。</p><blockquote><p>此处多么像 Java Integer 类中的 IntegerCache。</p></blockquote><h2 id="lru" tabindex="-1"><a class="header-anchor" href="#lru"><span>LRU</span></a></h2><p>在对象的结构体中还记录了对象最后一次被程序访问的时间：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line">    <span class="token keyword">unsigned</span> lru<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 Redis 中的一些特定选项被打开，如果服务器占用的内存数超过阈值，那么 LRU 值较高的对象将优先被服务器释放，从而回收内存。</p>`,72)]))}const p=n(l,[["render",c],["__file","Chapter 8 - 对象.html.vue"]]),d=JSON.parse('{"path":"/redis-implementation-notes/Part%201%20-%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/Chapter%208%20-%20%E5%AF%B9%E8%B1%A1.html","title":"Chapter 8 - 对象","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Object Type and Encoding","slug":"object-type-and-encoding","link":"#object-type-and-encoding","children":[]},{"level":2,"title":"Redis String","slug":"redis-string","link":"#redis-string","children":[{"level":3,"title":"Encoding Conversion","slug":"encoding-conversion","link":"#encoding-conversion","children":[]}]},{"level":2,"title":"List Object","slug":"list-object","link":"#list-object","children":[{"level":3,"title":"Encoding Conversion","slug":"encoding-conversion-1","link":"#encoding-conversion-1","children":[]}]},{"level":2,"title":"Hash Object","slug":"hash-object","link":"#hash-object","children":[{"level":3,"title":"Encoding Conversion","slug":"encoding-conversion-2","link":"#encoding-conversion-2","children":[]}]},{"level":2,"title":"Collection Object","slug":"collection-object","link":"#collection-object","children":[{"level":3,"title":"Encoding Conversion","slug":"encoding-conversion-3","link":"#encoding-conversion-3","children":[]}]},{"level":2,"title":"Ordered Collection Object","slug":"ordered-collection-object","link":"#ordered-collection-object","children":[{"level":3,"title":"Encoding Conversion","slug":"encoding-conversion-4","link":"#encoding-conversion-4","children":[]}]},{"level":2,"title":"Type Check","slug":"type-check","link":"#type-check","children":[]},{"level":2,"title":"Polymorphism","slug":"polymorphism","link":"#polymorphism","children":[]},{"level":2,"title":"Reference Counting","slug":"reference-counting","link":"#reference-counting","children":[]},{"level":2,"title":"Object Sharing","slug":"object-sharing","link":"#object-sharing","children":[]},{"level":2,"title":"LRU","slug":"lru","link":"#lru","children":[]}],"git":{},"filePathRelative":"redis-implementation-notes/Part 1 - 数据结构与对象/Chapter 8 - 对象.md"}');export{p as comp,d as data};
