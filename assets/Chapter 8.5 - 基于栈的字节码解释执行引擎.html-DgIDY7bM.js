import{_ as a,c as s,a as l,o as n}from"./app-7eKjwDat.js";const i={};function t(r,e){return n(),s("div",null,e[0]||(e[0]=[l(`<h1 id="chapter-8-5-基于栈的字节码解释执行引擎" tabindex="-1"><a class="header-anchor" href="#chapter-8-5-基于栈的字节码解释执行引擎"><span>Chapter 8.5 - 基于栈的字节码解释执行引擎</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 01 / 30 23:12 🧨🧧</p><p>Ningbo, Zhejiang, China</p><hr><h2 id="_8-5-基于栈的字节码解释执行引擎" tabindex="-1"><a class="header-anchor" href="#_8-5-基于栈的字节码解释执行引擎"><span>8.5 基于栈的字节码解释执行引擎</span></a></h2><h3 id="_8-5-1-解释执行" tabindex="-1"><a class="header-anchor" href="#_8-5-1-解释执行"><span>8.5.1 解释执行</span></a></h3><p>在 Java 初生的年代，解释执行还是比较准确的，但当主流 JVM 内部都包含了即时编译器后，Class 文件中的代码到底是被解释执行还是编译执行，就只有 JVM 自己才能判断了。</p><h3 id="_8-5-2-基于栈的指令集与基于寄存器的指令集" tabindex="-1"><a class="header-anchor" href="#_8-5-2-基于栈的指令集与基于寄存器的指令集"><span>8.5.2 基于栈的指令集与基于寄存器的指令集</span></a></h3><p>Javac 编译器输出的字节码指令流，是一种基于栈的指令集架构，指令大部分都是 <strong>零地址指令</strong> (没有地址)，依赖 <strong>操作数栈</strong> 进行工作。常用的指令级架构是基于寄存器的指令集，比如 x86 的 <strong>二地址指令集</strong>。</p><p>JVM 的指令通常不带参数，使用操作数栈中的数据作为输入，运算结果存储在操作数栈中。</p><div class="language-assembly line-numbers-mode" data-highlighter="prismjs" data-ext="assembly" data-title="assembly"><pre><code><span class="line">iconst_1</span>
<span class="line">iconst_1</span>
<span class="line">iadd</span>
<span class="line">istore_0</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而基于寄存器的指令包含独立的输入参数，依赖寄存器来访问和存储数据：</p><div class="language-assembly line-numbers-mode" data-highlighter="prismjs" data-ext="assembly" data-title="assembly"><pre><code><span class="line">mov eax, 1</span>
<span class="line">add eax, 1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>基于栈的指令集 - 优势：</p><ul><li>可移植 <ul><li>寄存器由硬件提供，程序依赖寄存器不可避免地受到体系结构的约束</li><li>JVM 可以由虚拟机实现自行决定把访问最频繁的数据放到寄存器中</li></ul></li><li>代码相对紧凑 <ul><li>一个字节</li><li>没有地址参数</li></ul></li><li>编译器实现简单 <ul><li>不需考虑空间分配问题</li><li>所需空间都在栈上操作</li></ul></li></ul><p>劣势：</p><ul><li>理论执行速度较慢 (特指解释执行)</li><li>代码紧凑，但是实现相同功能所需的指令数量较多</li><li>栈的实现在内存中，对于 CPU 来说，内存是执行速度的瓶颈</li></ul><p>JVM 会对指令的执行过程做出一系列优化以提高性能。JVM 中的 <strong>解释器</strong> 和 <strong>即时编译器</strong> 都会对输入的字节码进行优化。</p>`,19)]))}const p=a(i,[["render",t],["__file","Chapter 8.5 - 基于栈的字节码解释执行引擎.html.vue"]]),c=JSON.parse('{"path":"/understanding-the-jvm-notes/Part%203%20-%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/Chapter%208.5%20-%20%E5%9F%BA%E4%BA%8E%E6%A0%88%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.html","title":"Chapter 8.5 - 基于栈的字节码解释执行引擎","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"8.5 基于栈的字节码解释执行引擎","slug":"_8-5-基于栈的字节码解释执行引擎","link":"#_8-5-基于栈的字节码解释执行引擎","children":[{"level":3,"title":"8.5.1 解释执行","slug":"_8-5-1-解释执行","link":"#_8-5-1-解释执行","children":[]},{"level":3,"title":"8.5.2 基于栈的指令集与基于寄存器的指令集","slug":"_8-5-2-基于栈的指令集与基于寄存器的指令集","link":"#_8-5-2-基于栈的指令集与基于寄存器的指令集","children":[]}]}],"git":{},"filePathRelative":"understanding-the-jvm-notes/Part 3 - 虚拟机执行子系统/Chapter 8.5 - 基于栈的字节码解释执行引擎.md"}');export{p as comp,c as data};
