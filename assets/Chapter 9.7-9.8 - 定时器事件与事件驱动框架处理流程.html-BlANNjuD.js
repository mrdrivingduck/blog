import{_ as s,c as a,a as e,o as c}from"./app-BeHGwf2X.js";const p={};function t(l,n){return c(),a("div",null,n[0]||(n[0]=[e(`<h1 id="chapter-9-7-9-8-定时器事件与事件驱动框架处理流程" tabindex="-1"><a class="header-anchor" href="#chapter-9-7-9-8-定时器事件与事件驱动框架处理流程"><span>Chapter 9.7-9.8 - 定时器事件与事件驱动框架处理流程</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 07 / 27 20:19</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="_9-7-定时器事件" tabindex="-1"><a class="header-anchor" href="#_9-7-定时器事件"><span>9.7 定时器事件</span></a></h2><p>网络事件是由内核触发的，而定时器事件完全由 Nginx 自身实现，与内核无关。</p><h3 id="_9-7-1-缓存事件的管理" tabindex="-1"><a class="header-anchor" href="#_9-7-1-缓存事件的管理"><span>9.7.1 缓存事件的管理</span></a></h3><p>Nginx 中每个进程都会单独地管理当前事件，其使用的事件会被缓存在内存中。具体缓存的形式如下 (精确到毫秒级)：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">time_t</span> sec<span class="token punctuation">;</span> <span class="token comment">// 1970.01.01 00:00:00 到现在的秒数</span></span>
<span class="line">    <span class="token class-name">ngx_uint_t</span> msec<span class="token punctuation">;</span> <span class="token comment">// 当前事件相对于 sec 的毫秒偏移量</span></span>
<span class="line">    <span class="token class-name">ngx_int_t</span> gmtoff<span class="token punctuation">;</span> <span class="token comment">// 时区</span></span>
<span class="line"><span class="token punctuation">}</span> <span class="token class-name">ngx_time_t</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>作为 Web 服务器，Nginx 还定义了一些全局变量，用于得到可读性较强的规范时间字符串：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">volatile</span> <span class="token class-name">ngx_msec_t</span>      ngx_current_msec<span class="token punctuation">;</span> <span class="token comment">// 毫秒级别的 UNIX 时间戳</span></span>
<span class="line"><span class="token keyword">volatile</span> <span class="token class-name">ngx_time_t</span>     <span class="token operator">*</span>ngx_cached_time<span class="token punctuation">;</span> <span class="token comment">// 当前时间的结构体指针</span></span>
<span class="line"><span class="token keyword">volatile</span> <span class="token class-name">ngx_str_t</span>       ngx_cached_err_log_time<span class="token punctuation">;</span> <span class="token comment">// 用于记录 error log 的当前时间字符串</span></span>
<span class="line"><span class="token keyword">volatile</span> <span class="token class-name">ngx_str_t</span>       ngx_cached_http_time<span class="token punctuation">;</span> <span class="token comment">// 用于 HTTP 相关的当前时间字符串</span></span>
<span class="line"><span class="token keyword">volatile</span> <span class="token class-name">ngx_str_t</span>       ngx_cached_http_log_time<span class="token punctuation">;</span> <span class="token comment">// 用于记录 HTTP 日志的当前时间字符串</span></span>
<span class="line"><span class="token keyword">volatile</span> <span class="token class-name">ngx_str_t</span>       ngx_cached_http_log_iso8601<span class="token punctuation">;</span> <span class="token comment">// ISO 8601 格式下的字符串形式的标准时间</span></span>
<span class="line"><span class="token keyword">volatile</span> <span class="token class-name">ngx_str_t</span>       ngx_cached_syslog_time<span class="token punctuation">;</span> <span class="token comment">// 用于系统日志的时间字符串</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>缓存时间的更新时机：在 Nginx 启动时更新一次时间，之后更新时间的操作只能由 <code>ngx_epoll_process_events()</code> 执行。当标志位参数中有 <code>NGX_UPDATE_TIME</code> 标志时，就会调用 <code>ngx_time_update()</code> 更新缓存时间。</p><h3 id="_9-7-2-缓存时间的精度" tabindex="-1"><a class="header-anchor" href="#_9-7-2-缓存时间的精度"><span>9.7.2 缓存时间的精度</span></a></h3><p>根据缓存时间的更新策略，缓存时间的精度与 <code>ngx_epoll_process_events()</code> 函数的调用频率有关。</p><p>Nginx 自身还另外提供了设置更新缓存时间频率的功能。<code>ngx_event_core_module</code> 模块在初始化时，会向内核注册定时器，使内核定期调用一次 <code>ngx_timer_signal_handler()</code> 函数 - 在该函数中，会将 <code>ngx_event_timer_alarm</code> 标志位设置为 <code>1</code>，由此之后一旦调用了 <code>ngx_epoll_process_events()</code> 函数，一定会更新缓存时间。</p><p>如果 <code>ngx_epoll_process_events()</code> 很长时间不会被执行呢？在 EPOLL 模块下，会使得 <code>epoll_wait()</code> 的调用立刻返回，而不是等待一段时间，由此来控制时间精度。</p><h3 id="_9-7-3-定时器的实现" tabindex="-1"><a class="header-anchor" href="#_9-7-3-定时器的实现"><span>9.7.3 定时器的实现</span></a></h3><p>定时器由 <strong>红黑树</strong> 实现，树结点关键字是事件的超时时间，整棵树按超时时间的大小组织。需要找出最有可能超时的事件，只需要把树中最左边的结点取出来，并与当前事件对比即可。</p><hr><h2 id="_9-8-事件驱动框架的处理流程" tabindex="-1"><a class="header-anchor" href="#_9-8-事件驱动框架的处理流程"><span>9.8 事件驱动框架的处理流程</span></a></h2><p>Nginx 会将监听连接的读事件回调函数设置为 <code>ngx_event_accept()</code>，并把读事件添加到事件驱动模块中。当执行 <code>ngx_epoll_process_events()</code> 函数时，就会调用回调函数建立新连接。Nginx 为了充分发挥多核 CPU 架构性能的考虑，使用了多个 worker 子进程监听相同的端口，由此会引发子进程在 <code>accept()</code> 连接时发生 <em>惊群</em> (争抢) 问题。另外，建立连接时话要考虑负载均衡问题，使得各个子进程之前的负载尽量均衡，尽量独占一个 CPU 核心。</p><p>Nginx 的 post 事件处理机制用于解决这两个问题。Nginx 中设计了两个队列：</p><ul><li><code>ngx_posted_accept_events</code> 队列存放监听连接的读事件</li><li><code>ngx_posted_events</code> 队列存放普通读写事件</li></ul><p>由 <code>epoll_wait()</code> 查询得到的所有事件按类型分发到这两个队列中，然后优先执行监听连接的读时间，再处理普通读写事件。</p><h3 id="_9-8-1-如何建立新连接" tabindex="-1"><a class="header-anchor" href="#_9-8-1-如何建立新连接"><span>9.8.1 如何建立新连接</span></a></h3><p>建立新连接的回调函数 <code>ngx_event_accept()</code>：</p><ol><li>调用 <code>accept()</code> 函数试图建立连接，如果没有准备好新连接，则整个函数直接返回</li><li>设置负载均衡阈值</li><li>调用 <code>ngx_get_connection()</code> 函数从连接池中获取一个 <code>ngx_connection_t</code> 连接对象</li><li>为 <code>ngx_connection_t</code> 中的 <code>pool</code> 指针建立内存池</li><li>设置 socket 属性 (为非阻塞)</li><li>将新连接的读事件添加到 EPOLL 等事件驱动模块中</li><li>调用 <code>ngx_listening_t</code> 监听对象的 <code>handler</code> 回调函数</li></ol><h3 id="_9-8-2-如何解决-惊群-问题" tabindex="-1"><a class="header-anchor" href="#_9-8-2-如何解决-惊群-问题"><span>9.8.2 如何解决 <em>惊群</em> 问题</span></a></h3><p>某一时刻，恰好所有的 worker 子进程都在休眠并等待 <code>epoll_wait()</code> 时，一个客户端与服务器建立了新连接。此时，内核会激活所有休眠的 worker 子进程，而实际上最终只有一个子进程能够成功建立连接，其余进程的唤醒都是没有必要的，白白切换了上下文。很多 OS 已经从内核的层面上解决这一问题。但作为一个可移植的 Web 服务器，Nginx 从自身应用的层面上解决了问题：规定同一时刻只能有唯一一个 worker 子进程监听端口。那么如何限制某一时刻只能有一个进程监听端口呢？</p><p>只有在试图获得 <code>accept_mutex</code> 锁后，当前 worker 进程才会去监听端口。获取锁的过程不会阻塞，如果没有获取到锁，会立刻返回：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token class-name">ngx_int_t</span></span>
<span class="line"><span class="token function">ngx_trylock_accept_mutex</span><span class="token punctuation">(</span><span class="token class-name">ngx_cycle_t</span> <span class="token operator">*</span>cycle<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 试图得到锁，ngx_accept_mutex 是进程间的同步锁</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_shmtx_trylock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ngx_accept_mutex<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">        <span class="token function">ngx_log_debug0</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_EVENT<span class="token punctuation">,</span> cycle<span class="token operator">-&gt;</span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span></span>
<span class="line">                       <span class="token string">&quot;accept mutex locked&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 进程已经获取到锁了，直接返回</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_mutex_held <span class="token operator">&amp;&amp;</span> ngx_accept_events <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 将所有监听连接的读事件加入事件驱动模块中</span></span>
<span class="line">        <span class="token comment">// 如果失败，那么就释放锁</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_enable_accept_events</span><span class="token punctuation">(</span>cycle<span class="token punctuation">)</span> <span class="token operator">==</span> NGX_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token function">ngx_shmtx_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ngx_accept_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 设置已经获得锁的标志，通知本进程其它模块</span></span>
<span class="line">        ngx_accept_events <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">        ngx_accept_mutex_held <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token function">ngx_log_debug1</span><span class="token punctuation">(</span>NGX_LOG_DEBUG_EVENT<span class="token punctuation">,</span> cycle<span class="token operator">-&gt;</span>log<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span></span>
<span class="line">                   <span class="token string">&quot;accept mutex lock failed: %ui&quot;</span><span class="token punctuation">,</span> ngx_accept_mutex_held<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>ngx_accept_mutex_held<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ngx_disable_accept_events</span><span class="token punctuation">(</span>cycle<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> NGX_ERROR<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">return</span> NGX_ERROR<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        ngx_accept_mutex_held <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">return</span> NGX_OK<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，如果进程成功获取到了锁，那么就既要处理已有连接的读写事件，又要处理监听端口上的新连接事件；如果进程没有获得锁，那么就只处理已有连接的读写事件。那么 <strong>何时释放</strong> 这个锁呢？如果该进程有很多活跃连接，在处理这些连接时占用了很长时间，即很长时间不释放 <code>ngx_accept_mutex</code> 锁，那么其它 worker 进程就没有机会处理新连接，不利于负载均衡。</p><p>Nginx 使用两个延后处理队列解决这个问题。如果当前进程获得了锁，那么该进程的 <code>NGX_POST_EVENTS</code> 标志就会被设置。在事件的分发处理中，如果该标志被设置，那么就将事件放入延后处理队列中，回调函数不会立刻执行：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> NGX_POST_EVENTS<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    queue <span class="token operator">=</span> rev<span class="token operator">-&gt;</span>accept <span class="token operator">?</span> <span class="token operator">&amp;</span>ngx_posted_accept_events</span>
<span class="line">                        <span class="token operator">:</span> <span class="token operator">&amp;</span>ngx_posted_events<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token function">ngx_post_event</span><span class="token punctuation">(</span>rev<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">    rev<span class="token operator">-&gt;</span><span class="token function">handler</span><span class="token punctuation">(</span>rev<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里也相当于顺便给这些事件分了个类。将新连接事件全部放到 <code>ngx_posted_accept_events</code> 队列中，将普通事件放到 <code>ngx_posted_events</code> 队列中。接下来首先处理所有新连接事件，处理完后就 <strong>立刻释放</strong> <code>ngx_accept_mutex</code> 锁，再接着处理 <code>ngx_posted_events</code> 队列中的事件。</p><h3 id="_9-8-3-如何实现负载均衡" tabindex="-1"><a class="header-anchor" href="#_9-8-3-如何实现负载均衡"><span>9.8.3 如何实现负载均衡</span></a></h3><p>与 <em>惊群问题</em> 类似，只有打开了 <code>accept_mutex</code> 锁才能实现进程间的负载均衡。每个 worker 进程中都有一个整型全局变量 <code>ngx_accept_disabled</code>，是负载均衡机制实现的关键阈值。这个值与进程连接池中连接的使用情况密切相关：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line">ngx_accept_disabled <span class="token operator">=</span> ngx_cycle<span class="token operator">-&gt;</span>connection_n <span class="token operator">/</span> <span class="token number">8</span></span>
<span class="line">                              <span class="token operator">-</span> ngx_cycle<span class="token operator">-&gt;</span>free_connection_n<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，这个值被初始化为一个负数，绝对值为总连接数的 7/8。当这个阈值是负数时，不会触发负载均衡操作，因为进程的连接池还很充裕；而当 <code>ngx_accept_disabled</code> 是正数时，就会触发负载均衡操作：</p><ul><li>当前进程不再处理新连接事件</li><li>将 <code>ngx_accept_disable</code> 的值减 1</li></ul><p>也就是说，当进程的连接数达到连接池的 7/8 时，就不再处理新连接了，而是逐步减小阈值，直到 <code>ngx_accept_disable</code> 降到总连接数的 7/8 以下时，才会调用 <code>ngx_trylock_accept_mutex()</code> 试图处理新连接事件。总结来看，只有在某个 worker 子进程达到连接池使用达到 7/8 时，才会触发负载均衡，是这个 worker 进程减少处理新连接的机会。避免了某个 worker 进程因连接池耗尽而拒绝服务，而其它进程可处理的连接远未到达上限的问题。</p><h3 id="_9-8-4-post-事件队列" tabindex="-1"><a class="header-anchor" href="#_9-8-4-post-事件队列"><span>9.8.4 POST 事件队列</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token class-name">ngx_queue_t</span>  ngx_posted_accept_events<span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">ngx_queue_t</span>  ngx_posted_next_events<span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">ngx_queue_t</span>  ngx_posted_events<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-8-5-ngx-process-events-and-timers-流程" tabindex="-1"><a class="header-anchor" href="#_9-8-5-ngx-process-events-and-timers-流程"><span>9.8.5 <code>ngx_process_events_and_timers</code> 流程</span></a></h3><p>每个 worker 进程都在 <code>ngx_worker_process_cycle()</code> 函数中循环处理事件。其中，处理分发事件是通过 <code>ngx_process_events_and_timers()</code> 函数实现的 - 循环调用这个函数就是在循环处理事件。这个函数中，既处理网络事件，又处理定时器事件。总结为：</p><ol><li>调用事件驱动模块的 <code>process_events()</code> 函数处理网络事件</li><li>处理两个延后处理队列中的事件</li><li>处理定时器事件</li></ol><p>其中，在第一步的 <code>process_events()</code> 中，参数会传入 <code>timer</code> 和 <code>flags</code>，决定了时间精度和事件是否被延后处理。</p><ol><li>如果配置文件使用了 <code>timer_resolution</code> 配置，那么 <code>timer</code> 参数设置为 <code>-1</code>，在检测事件 (<code>epoll_wait()</code>) 时不等待直接返回</li><li>如果没有使用 <code>timer_resolution</code>，那么调用 <code>ngx_event_find_timer()</code> 获取最近将要触发的事件距离现在的时间，并赋值给 <code>timer</code>，使得检测事件时最多只等待这么多时间 (保证定时器事件准时被处理)；设置 <code>flag</code> 中的 <code>NGX_UPDATE_TIME</code> 以更新缓存的时间</li><li>如果配置文件中开启了 <code>accept_mutex</code>，那么检测负载均衡阈值 <code>ngx_accept_disabled</code> - 如果是正数，则减 1</li><li>如果负载均衡阈值是负数，则没有触发负载均衡，试图获取 <code>accept_mutex</code> 锁</li><li>如果锁获取成功，那么将 <code>flag</code> 中加上 <code>NGX_POST_EVENTS</code></li><li>如果没有获取到锁，(则等待一会儿再抢锁？)</li><li>调用 <code>ngx_process_events()</code> 函数分发处理事件，并计算这个函数执行时消耗的时间</li><li>如果 <code>ngx_posted_accept_events</code> 队列不为空，则依次调用队列中每个事件的回调，建立新连接</li><li>如果当前进程持有 <code>accept_mutex</code> 锁，则释放锁</li><li>如果 <code>ngx_process_events()</code> 的执行时间差大于 0，那么可能有新的定时器事件被触发，调用 <code>ngx_event_expire_timers()</code> 函数处理所有到期的定时器事件</li><li>如果 <code>ngx_posted_events</code> 队列不为空，则调用每个事件的回调，处理读写事件</li></ol>`,49)]))}const i=s(p,[["render",t],["__file","Chapter 9.7-9.8 - 定时器事件与事件驱动框架处理流程.html.vue"]]),d=JSON.parse('{"path":"/understanding-nginx-notes/Part%203%20-%20%E6%B7%B1%E5%85%A5%20Nginx/Chapter%209.7-9.8%20-%20%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.html","title":"Chapter 9.7-9.8 - 定时器事件与事件驱动框架处理流程","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"9.7 定时器事件","slug":"_9-7-定时器事件","link":"#_9-7-定时器事件","children":[{"level":3,"title":"9.7.1 缓存事件的管理","slug":"_9-7-1-缓存事件的管理","link":"#_9-7-1-缓存事件的管理","children":[]},{"level":3,"title":"9.7.2 缓存时间的精度","slug":"_9-7-2-缓存时间的精度","link":"#_9-7-2-缓存时间的精度","children":[]},{"level":3,"title":"9.7.3 定时器的实现","slug":"_9-7-3-定时器的实现","link":"#_9-7-3-定时器的实现","children":[]}]},{"level":2,"title":"9.8 事件驱动框架的处理流程","slug":"_9-8-事件驱动框架的处理流程","link":"#_9-8-事件驱动框架的处理流程","children":[{"level":3,"title":"9.8.1 如何建立新连接","slug":"_9-8-1-如何建立新连接","link":"#_9-8-1-如何建立新连接","children":[]},{"level":3,"title":"9.8.2 如何解决 惊群 问题","slug":"_9-8-2-如何解决-惊群-问题","link":"#_9-8-2-如何解决-惊群-问题","children":[]},{"level":3,"title":"9.8.3 如何实现负载均衡","slug":"_9-8-3-如何实现负载均衡","link":"#_9-8-3-如何实现负载均衡","children":[]},{"level":3,"title":"9.8.4 POST 事件队列","slug":"_9-8-4-post-事件队列","link":"#_9-8-4-post-事件队列","children":[]},{"level":3,"title":"9.8.5 ngx_process_events_and_timers 流程","slug":"_9-8-5-ngx-process-events-and-timers-流程","link":"#_9-8-5-ngx-process-events-and-timers-流程","children":[]}]}],"git":{},"filePathRelative":"understanding-nginx-notes/Part 3 - 深入 Nginx/Chapter 9.7-9.8 - 定时器事件与事件驱动框架处理流程.md"}');export{i as comp,d as data};
