import{_ as a,c as s,a as n,o as i}from"./app-BeHGwf2X.js";const l="/blog/assets/makefile-dependencies-BDmMxf4N.png",c={};function d(p,e){return i(),s("div",null,e[0]||(e[0]=[n(`<h1 id="chapter-15-development-tools" tabindex="-1"><a class="header-anchor" href="#chapter-15-development-tools"><span>Chapter 15 - Development Tools</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 07 / 11 17:00</p><p>@NUAA, Nanjing, Jiangsu, China</p><hr><h2 id="_15-1-the-c-compiler" tabindex="-1"><a class="header-anchor" href="#_15-1-the-c-compiler"><span>15.1 The C Compiler</span></a></h2><p>大部分 Unix 系统上 C 编译器是 GNU C compiler - <code>gcc</code>。而 LLVM 中的 <code>clang</code> 正越来越受欢迎。</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">cc hello.c</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>会生成 <code>a.out</code> 的可执行文件，当然也可以生成指定名称的可执行文件：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">cc <span class="token parameter variable">-o</span> hello hello.c</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_15-1-1-multiple-source-files" tabindex="-1"><a class="header-anchor" href="#_15-1-1-multiple-source-files"><span>15.1.1 Multiple Source Files</span></a></h3><p>使用 <code>-c</code> 选项将源文件编译为目标文件：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">cc <span class="token parameter variable">-c</span> main.c</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>得到 <code>main.o</code>。但 OS 不知道如何执行目标文件，需要将目标文件和系统库文件合并为完整的程序。为了产生完整的可执行程序，需要运行链接器。程序员很少需要在 cmd 中使用 <code>ld</code> 命令进行显示链接，这些工作会由编译器完成。</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">cc <span class="token parameter variable">-o</span> my_program main.o other.o</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_15-1-2-header-include-files-and-directories" tabindex="-1"><a class="header-anchor" href="#_15-1-2-header-include-files-and-directories"><span>15.1.2 Header (Include) Files and Directories</span></a></h3><p>C 头文件是包含类型和函数库函数声明的部分。很多时候，编译器发生错误的原因是找不到头文件。</p><h4 id="fixing-include-file-problems" tabindex="-1"><a class="header-anchor" href="#fixing-include-file-problems"><span>Fixing Include File Problems</span></a></h4><p>Unix 中默认的 include 目录是 <code>/usr/include</code>，编译器会自动在该目录中找头文件。如果想指定一个 include 目录：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">cc <span class="token parameter variable">-c</span> -I/usr/somewhere/include main.c</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;myheader.h&quot;</span></span></span>
<span class="line"><span class="token comment">// #include &lt;myheader.h&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="what-is-the-c-preprocessor-cpp" tabindex="-1"><a class="header-anchor" href="#what-is-the-c-preprocessor-cpp"><span>What Is the C Preprocessor (cpp)?</span></a></h4><p>C 预处理器是编译器在开始转换源代码之前首先运行的程序。处理源代码中的宏指令，包含三种类型：</p><ul><li>Include files：<code>#include ...</code>，编译器会根据默认路径或 <code>-I</code> 选项寻找对应头文件</li><li>Macro definitions：预处理器会替代源代码中所有的宏定义部分</li><li>Conditionals：<code>#ifdef</code>, <code>#if</code>, <code>#endif</code></li></ul><p>C 预处理器对 C 的语法一无所知，只认识宏指令。在 Unix 中，C 的预处理器名称是 <code>cpp</code>。</p><h3 id="_15-1-3-linking-with-libraries" tabindex="-1"><a class="header-anchor" href="#_15-1-3-linking-with-libraries"><span>15.1.3 Linking with Libraries</span></a></h3><p>C 库是一个预编译的函数集合，在链接阶段开始被引入。最有可能出现的问题是找不到库中的某个函数。在命令中，需要使用 <code>-l</code> 来链接对应的库，系统默认会到 <code>/usr/lib</code> 中寻找对应的库。</p><p>库文件 <code>libgobject.a</code> 对应库的名称是 <code>gobject</code>。如果某个库位于非默认路径，则需要用 <code>-L</code> 参数来告诉链接器库的位置：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">cc <span class="token parameter variable">-o</span> main main.o <span class="token parameter variable">-lgobject</span> -L/usr/somewhere/lib <span class="token parameter variable">-lcrud</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_15-1-4-shared-libraries" tabindex="-1"><a class="header-anchor" href="#_15-1-4-shared-libraries"><span>15.1.4 Shared Libraries</span></a></h3><p>以 <code>.a</code> 结尾的库文件被称为静态库。当链接静态库时，链接器将库文件中的机器码拷贝到程序中。因此，最终的可执行文件不需要原库文件被运行。当原库文件改变时，可执行文件的行为不会改变。然而，随着库文件越来越大，静态库太占用磁盘空间和内存空间。此外，如果发现静态库中存在漏洞，在不重新编译可执行文件的条件下，无法更新可执行文件中的库代码。</p><p>共享库解决了这些问题：</p><ul><li>系统在执行的程序需要用到共享库时才将库代码载入进程地址空间</li><li>多个进程可以共享内存中相同的库代码</li><li>如果需要改动库代码，不需要重新编译可执行文件</li></ul><p>共享库的问题：</p><ul><li>复杂的管理</li><li>复杂的链接过程</li></ul><h4 id="listing-shared-library-dependencies" tabindex="-1"><a class="header-anchor" href="#listing-shared-library-dependencies"><span>Listing Shared Library Dependencies</span></a></h4><p>共享库文件通常和静态库的位置相同：<code>/lib</code> 和 <code>/usr/lib</code>。<code>/lib</code> 目录通常不包含静态库。共享库的后缀： <code>.so</code> (shared object)。使用 <code>ldd</code> 命令查看程序使用的所有动态库：</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ ldd /bin/bash</span>
<span class="line">        linux-vdso.so.1 (0x00007ffe0d4ee000)</span>
<span class="line">        libtinfo.so.5 =&gt; /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f7ac707d000)</span>
<span class="line">        libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f7ac6e79000)</span>
<span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7ac6a88000)</span>
<span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f7ac75c1000)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可执行文件自身通常不知道共享库的具体位置。<code>ld.so</code> (运行时动态装入/链接器) 在运行时寻找并装入共享库。</p><h4 id="how-ld-so-finds-shared-libraries" tabindex="-1"><a class="header-anchor" href="#how-ld-so-finds-shared-libraries"><span>How ld.so Finds Shared Libraries</span></a></h4><p>动态链接器通常遇到的问题是找不到库。动态链接器会寻找的第一个地方是可执行文件预先配置的 runtime library search path (<em>rpath</em>)。下一步，动态链接器会在系统缓存 <code>/etc/ld.so.cache</code> 中查看库是否在默认位置：这是 <code>/etc/ld.so.conf</code> 的快速缓存，<code>ld.so.conf</code> 文件的每一行都是想要引入的路径。标准库路径 <code>/lib</code> 和 <code>/usr/lib</code> 是隐含的，不需要额外配置。如果改动了 <code>ld.so.conf</code> 中的目录，需要 rebuild <code>/etc/li.so.cache</code> 文件：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">ldconfig <span class="token parameter variable">-v</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>ld.so</code> 还会在一个地方寻找共享库：环境变量 <code>LD_LIBRARY_PATH</code>。</p><h4 id="linking-programs-against-shared-libraries" tabindex="-1"><a class="header-anchor" href="#linking-programs-against-shared-libraries"><span>Linking Programs Against Shared Libraries</span></a></h4><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">cc <span class="token parameter variable">-o</span> main main.o -Wl,-rpath<span class="token operator">=</span>/opt/<span class="token punctuation">..</span>. -L/opt/<span class="token punctuation">..</span>. <span class="token parameter variable">-lweird</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>-Wl</code> 和 <code>-rapth</code> 告诉链接器将对应的目录加入到可执行程序的运行时库搜索路径中。</p><h4 id="programs-with-shared-libraries" tabindex="-1"><a class="header-anchor" href="#programs-with-shared-libraries"><span>Programs with Shared Libraries</span></a></h4><ul><li>Missing libraries</li><li>Terrible performance</li><li>Mismatched libraries</li></ul><p>首先可能导致问题的地方是 <code>LD_LIBRARY_PATH</code> 环境变量。<code>ld.so</code> 会优先从环境变量中搜索共享库。不要在 shell 启动文件或编译软件时设置该环境变量：</p><ul><li>运行时动态链接器会遍历该变量中的所有路径，从而导致性能问题</li><li>同时还会导致冲突和不匹配的库，因为运行时链接器在这些路径中为每个程序寻找共享库</li></ul><p>如果一定要使用该环境变量，应当在 wrapper script 中设置该环境变量：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token shebang important">#!/bin/sh</span></span>
<span class="line"><span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span>/opt/<span class="token punctuation">..</span>.</span>
<span class="line"><span class="token builtin class-name">export</span> LD_LIBRARY_PATH</span>
<span class="line"><span class="token builtin class-name">exec</span> /opt/<span class="token punctuation">..</span>./<span class="token punctuation">..</span>.bin <span class="token variable">$@</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>避免使用该环境变量避免了大部分共享库问题。</p><h2 id="_15-2-make" tabindex="-1"><a class="header-anchor" href="#_15-2-make"><span>15.2 make</span></a></h2><p>有多个源程序或需要大量编译选项的程序，直接手动编译很困难。<code>make</code> 解决了这个问题。<code>make</code> 背后的基本思想是 target：一个用户想要完成的目标。目标可以是一个文件或可执行文件。</p><p>此外，一些目标可能会依赖其它目标，即所谓的 dependencies。为了 build 一个目标，<code>make</code> 会遵守一定的规则，比如如何将 <code>.c</code> 文件转换为 <code>.o</code> 文件。</p><h3 id="_15-2-1-a-sample-makefile" tabindex="-1"><a class="header-anchor" href="#_15-2-1-a-sample-makefile"><span>15.2.1 A Sample Makefile</span></a></h3><div class="language-makefile line-numbers-mode" data-highlighter="prismjs" data-ext="makefile" data-title="makefile"><pre><code><span class="line"><span class="token comment"># object files</span></span>
<span class="line">OBJS<span class="token operator">=</span>aux.o main.o</span>
<span class="line"></span>
<span class="line"><span class="token target symbol">all</span><span class="token punctuation">:</span> myprog</span>
<span class="line"></span>
<span class="line"><span class="token target symbol">myprog</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span></span>
<span class="line">	<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o myprog <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>#</code> 是 makefile 中的注释</li><li><code>OBJS</code> 是变量，在之后可以被引用：<code>$(OBJS)</code></li><li>第一个目标：<code>all</code>，第一个目标是 make 的默认目标</li><li>对于 <code>all</code>，需要满足的目标是 <code>myprog</code>，即依赖；<code>myprog</code> 可以是另一个目标，也可以是文件</li><li>宏展开后：<code>myprog: aux.o main.o</code>，说明 <code>myprog</code> 依赖这两个文件</li></ul><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ make</span>
<span class="line">cc    -c -o aux.o aux.c</span>
<span class="line">cc    -c -o main.o main.c</span>
<span class="line">cc -o myprog aux.o main.o</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+l+`" alt="makefile-dependencies"></p><h3 id="_15-2-2-built-in-rules" tabindex="-1"><a class="header-anchor" href="#_15-2-2-built-in-rules"><span>15.2.2 Built-in Rules</span></a></h3><p>内置规则：比如寻找与 <code>.o</code> 文件同名的 <code>.c</code> 文件，并将 <code>.c</code> 文件转换为 <code>.o</code> 文件。</p><h3 id="_15-2-3-final-program-build" tabindex="-1"><a class="header-anchor" href="#_15-2-3-final-program-build"><span>15.2.3 Final Program Build</span></a></h3><p>必须在实际命令面前插入一个 tab。</p><h3 id="_15-2-4-staying-up-to-date" tabindex="-1"><a class="header-anchor" href="#_15-2-4-staying-up-to-date"><span>15.2.4 Staying Up-to-Date</span></a></h3><p>运行 <code>make</code> 命令后，再次运行。<code>make</code> 查看规则，发现 <code>all</code> 已经存在。如果 <code>all</code> 的依赖都没有发生改变，将不再 rebuild；如果其中的某一个依赖发生了改变，只 rebuild 依赖发生改变的部分，引发链式反应。</p><h3 id="_15-2-5-command-line-arguments-and-options" tabindex="-1"><a class="header-anchor" href="#_15-2-5-command-line-arguments-and-options"><span>15.2.5 Command-Line Arguments and Options</span></a></h3><p>在运行 make 命令时，可以执行宏：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">make</span> <span class="token assign-left variable">CC</span><span class="token operator">=</span>clang</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>两个常用的 option：</p><ul><li><code>-n</code>：打印 build 过程中必须的命令，但 make 实际上不运行对应的命令</li><li><code>-f file</code>：从指定文件运行 make，而不是 <code>Makefile</code> 或 <code>makefile</code></li></ul><h3 id="_15-2-6-standard-macros-and-variables" tabindex="-1"><a class="header-anchor" href="#_15-2-6-standard-macros-and-variables"><span>15.2.6 Standard Macros and Variables</span></a></h3><p><code>make</code> 中的特殊宏和变量：</p><ul><li><code>CFLAGS</code>：C 编译器的选项，make 会将这些参数传递给编译器</li><li><code>LDFLAGS</code>：链接器选项</li><li><code>LDLIBS</code>：链接的库名称</li><li><code>CC</code>：C 编译器</li><li><code>CPPFLAGS</code>：C 预处理器选项</li><li><code>CXXFLAGS</code>：C++ 编译器选项</li><li><code>$@</code>：在规则内部，被扩展为当前目标</li><li><code>$*</code>：被扩展为当前目标的 basename</li></ul><h3 id="_15-2-7-conventional-targets" tabindex="-1"><a class="header-anchor" href="#_15-2-7-conventional-targets"><span>15.2.7 Conventional Targets</span></a></h3><p>几个标准的目标：</p><ul><li><p><code>clean</code>：清除所有的目标文件和可执行文件</p><div class="language-makefile line-numbers-mode" data-highlighter="prismjs" data-ext="makefile" data-title="makefile"><pre><code><span class="line"><span class="token target symbol">clean</span><span class="token punctuation">:</span></span>
<span class="line">	rm -f <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span> myprog</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>install</code>：将编译后的程序拷贝到 Makefile 认为合适的位置；可以运行 <code>make -n install</code> 来模拟执行一遍</p></li><li><p><code>test</code> / <code>check</code>：在一次 build 之后测试可用性</p></li><li><p><code>all</code>：通常代表 Makefile 中的第一个目标</p></li></ul><h3 id="_15-2-8-organizing-a-makefile" tabindex="-1"><a class="header-anchor" href="#_15-2-8-organizing-a-makefile"><span>15.2.8 Organizing a Makefile</span></a></h3><div class="language-makefile line-numbers-mode" data-highlighter="prismjs" data-ext="makefile" data-title="makefile"><pre><code><span class="line">MYPACKAGE_INCLUDES<span class="token operator">=</span>-I/usr/local/<span class="token keyword">include</span>/mypackage</span>
<span class="line">MYPACKAGE_LIB<span class="token operator">=</span>-L/usr/local/lib/mypackage -lmypackage</span>
<span class="line"></span>
<span class="line">CFLAGS<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>MYPACKAGE_INCLUDES<span class="token punctuation">)</span></span>
<span class="line">LDFLAGS<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>MYPACKAGE_LIB<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果两个可执行文件需要用到同一个文件中的代码：</p><div class="language-makefile line-numbers-mode" data-highlighter="prismjs" data-ext="makefile" data-title="makefile"><pre><code><span class="line">UTIL_OBJS<span class="token operator">=</span>util.o</span>
<span class="line"></span>
<span class="line">BORING_OBJS<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>UTIL_OBJS<span class="token punctuation">)</span> boring.o</span>
<span class="line">TRITE_OBJS<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>UTIL_OBJS<span class="token punctuation">)</span> trite.o</span>
<span class="line"></span>
<span class="line">PROGS<span class="token operator">=</span>boring trite</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最终是编译的部分：</p><div class="language-makefile line-numbers-mode" data-highlighter="prismjs" data-ext="makefile" data-title="makefile"><pre><code><span class="line"><span class="token target symbol">all</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>PROGS<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token target symbol">boring</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>BORING_OBJS<span class="token punctuation">)</span></span>
<span class="line">	<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o <span class="token variable">$@</span> <span class="token variable">$</span><span class="token punctuation">(</span>BORING_OBJS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span></span>
<span class="line">	<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o <span class="token variable">$@</span> <span class="token variable">$</span><span class="token punctuation">(</span>TRITE_OBJS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_15-3-debuggers" tabindex="-1"><a class="header-anchor" href="#_15-3-debuggers"><span>15.3 Debuggers</span></a></h2><p>为了启用程序的调试功能，在编译程序时加入 <code>-g</code> 选项，将符号表和其它调试信息写入可执行文件。</p><p>进入 <code>(gdb)</code> 的命令模式：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">gdb <span class="token operator">&lt;</span>program<span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>带参数运行程序：</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">(gdb) run &lt;options&gt;</span>
<span class="line">Starting program: /home/zhangjingtang/main</span>
<span class="line">Hello world</span>
<span class="line">[Inferior 1 (process 7617) exited normally]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>打印变量的值：</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">(gdb) print &lt;variable&gt;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>设断点：</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">(gdb) break &lt;file&gt;:&lt;line&gt;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>继续执行：</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">(gdb) continue</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>清除断点：</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">(gdb) clear &lt;file&gt;:&lt;line&gt;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,98)]))}const r=a(c,[["render",d],["__file","Chapter 15 - Development Tools.html.vue"]]),o=JSON.parse('{"path":"/how-linux-works-notes/Chapter%2015%20-%20Development%20Tools.html","title":"Chapter 15 - Development Tools","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"15.1 The C Compiler","slug":"_15-1-the-c-compiler","link":"#_15-1-the-c-compiler","children":[{"level":3,"title":"15.1.1 Multiple Source Files","slug":"_15-1-1-multiple-source-files","link":"#_15-1-1-multiple-source-files","children":[]},{"level":3,"title":"15.1.2 Header (Include) Files and Directories","slug":"_15-1-2-header-include-files-and-directories","link":"#_15-1-2-header-include-files-and-directories","children":[]},{"level":3,"title":"15.1.3 Linking with Libraries","slug":"_15-1-3-linking-with-libraries","link":"#_15-1-3-linking-with-libraries","children":[]},{"level":3,"title":"15.1.4 Shared Libraries","slug":"_15-1-4-shared-libraries","link":"#_15-1-4-shared-libraries","children":[]}]},{"level":2,"title":"15.2 make","slug":"_15-2-make","link":"#_15-2-make","children":[{"level":3,"title":"15.2.1 A Sample Makefile","slug":"_15-2-1-a-sample-makefile","link":"#_15-2-1-a-sample-makefile","children":[]},{"level":3,"title":"15.2.2 Built-in Rules","slug":"_15-2-2-built-in-rules","link":"#_15-2-2-built-in-rules","children":[]},{"level":3,"title":"15.2.3 Final Program Build","slug":"_15-2-3-final-program-build","link":"#_15-2-3-final-program-build","children":[]},{"level":3,"title":"15.2.4 Staying Up-to-Date","slug":"_15-2-4-staying-up-to-date","link":"#_15-2-4-staying-up-to-date","children":[]},{"level":3,"title":"15.2.5 Command-Line Arguments and Options","slug":"_15-2-5-command-line-arguments-and-options","link":"#_15-2-5-command-line-arguments-and-options","children":[]},{"level":3,"title":"15.2.6 Standard Macros and Variables","slug":"_15-2-6-standard-macros-and-variables","link":"#_15-2-6-standard-macros-and-variables","children":[]},{"level":3,"title":"15.2.7 Conventional Targets","slug":"_15-2-7-conventional-targets","link":"#_15-2-7-conventional-targets","children":[]},{"level":3,"title":"15.2.8 Organizing a Makefile","slug":"_15-2-8-organizing-a-makefile","link":"#_15-2-8-organizing-a-makefile","children":[]}]},{"level":2,"title":"15.3 Debuggers","slug":"_15-3-debuggers","link":"#_15-3-debuggers","children":[]}],"git":{},"filePathRelative":"how-linux-works-notes/Chapter 15 - Development Tools.md"}');export{r as comp,o as data};
