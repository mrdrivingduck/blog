import{_ as i,c as e,a,o as n}from"./app-BeHGwf2X.js";const s="/blog/assets/2-3-mz72_pHk.png",o="/blog/assets/2-4-B79mWA45.png",t="/blog/assets/2-5-DLqDwE81.png",r={};function c(d,l){return n(),e("div",null,l[0]||(l[0]=[a('<h1 id="chapter-2-微型计算机组成结构" tabindex="-1"><a class="header-anchor" href="#chapter-2-微型计算机组成结构"><span>Chapter 2 - 微型计算机组成结构</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 07 / 18 09:55</p><p>Nanjing, Jiangsu, China</p><hr><p>任何一个系统都可被认为由四部分组成：</p><ul><li>输入</li><li>输出</li><li>处理中心 - 加工输入，得到输出</li><li>能源部分 - 为整个系统提供能源供给</li></ul><p>对于计算机系统来说，由于输入和输出的大部分通道都是共享使用的：</p><ul><li>输入/输出 (I/O)</li><li>处理中心</li><li>能源</li></ul><hr><h2 id="_2-1-微型计算机组成原理" tabindex="-1"><a class="header-anchor" href="#_2-1-微型计算机组成原理"><span>2.1 微型计算机组成原理</span></a></h2><p>CPU 通过 <strong>地址线、数据线、控制线</strong> 组成的本地总线 (内部总线) 与系统其它部分进行通信</p><ul><li>地址线提供内存或 I/O 设备的地址</li><li>数据线负责数据传输</li><li>控制线负责指挥具体的读 / 写操作</li></ul><p><img src="'+s+'" alt="2-3"></p><p>现代 PC 主板由两个超大规模芯片组成 chipset：</p><ul><li>北桥 (Northbridge) 芯片 - Intel: <em>MCH (Memory Controller Hub)</em><ul><li>拥有很高的传输速率</li><li>连接 CPU、内存、AGP 视频接口</li></ul></li><li>南桥 (Southbridge) 芯片 - Intel: <em>ICH (I/O Controller Hub)</em><ul><li>管理中、低速的硬件</li><li>PCI 总线、硬盘接口、USB 接口等</li></ul></li></ul><hr><h2 id="_2-2-i-o-端口寻址和访问控制方式" tabindex="-1"><a class="header-anchor" href="#_2-2-i-o-端口寻址和访问控制方式"><span>2.2 I/O 端口寻址和访问控制方式</span></a></h2><h3 id="_2-2-1-i-o-端口和寻址" tabindex="-1"><a class="header-anchor" href="#_2-2-1-i-o-端口和寻址"><span>2.2.1 I/O 端口和寻址</span></a></h3><p>CPU 需要访问 I/O 接口控制器或控制卡上的数据和状态信息，首先需要制定它们的地址，即 I/O 端口地址 / 端口。通常 I/O 控制器包含：</p><ul><li>数据端口</li><li>命令端口</li><li>状态端口</li></ul><p>端口地址的设置方法：</p><ul><li>统一编址 <ul><li>将 I/O 控制器的端口地址归入存储器寻址地址空间范围内</li><li>使用内存访问指令可以访问 I/O</li></ul></li><li>独立编址 <ul><li>将 I/O 控制器和控制卡的寻址空间单独作为一个独立的地址空间对待</li><li>使用专用的 I/O 指令来访问端口</li></ul></li></ul><h3 id="_2-2-2-接口访问控制" tabindex="-1"><a class="header-anchor" href="#_2-2-2-接口访问控制"><span>2.2.2 接口访问控制</span></a></h3><ul><li>循环查询方式 <ul><li>CPU 在程序中循环查询设备控制器中的状态，判断是否可以进行数据交换</li><li>不需要硬件支持、简单</li><li>耗费 CPU 的时间</li></ul></li><li>中断处理控制方式 <ul><li>需要中断控制器的支持</li><li>I/O 设备向 CPU 提出中断请求</li></ul></li><li>直接存储器访问 (<em>DMA, Direct Memory Access</em>) 方式 <ul><li>用于 I/O 设备与系统内存之间进行批量数据传送</li><li>由专门的 DMA 控制器控制，不需要 CPU 插手</li><li>无需软件介入</li></ul></li></ul><hr><h2 id="_2-3-主存储器、bios-和-cmos-存储器" tabindex="-1"><a class="header-anchor" href="#_2-3-主存储器、bios-和-cmos-存储器"><span>2.3 主存储器、BIOS 和 CMOS 存储器</span></a></h2><h3 id="_2-3-1-主存储器" tabindex="-1"><a class="header-anchor" href="#_2-3-1-主存储器"><span>2.3.1 主存储器</span></a></h3><p>早期 8088/8086 CPU 只有 20 根地址线，因此内存寻址范围最高为 1 MB。Intel 32-bit CPU 可寻址 4GB 的地址，并通过 CPU 上的新特性，可以寻址 64GB 的物理内存。但为了与原来的 PC 在 <strong>软件</strong> 上兼容，1 MB 以下的物理内存使用分配依旧与最早期的使用方式一致。</p><h3 id="_2-3-2-基本输入-输出程序-bios" tabindex="-1"><a class="header-anchor" href="#_2-3-2-基本输入-输出程序-bios"><span>2.3.2 基本输入/输出程序 BIOS</span></a></h3><h4 id="_8088-8086-20-bit-地址线-启动方式" tabindex="-1"><a class="header-anchor" href="#_8088-8086-20-bit-地址线-启动方式"><span>8088/8086 (20 bit 地址线) 启动方式</span></a></h4><p><img src="'+o+'" alt="2-4"></p><p>20 根地址线只能寻址 <code>0x00000</code> - <code>0xFFFFF</code> 共 1MB 的地址空间，其中，ROM (BIOS) 和 RAM 统一编址：</p><ul><li>RAM 占据低端地址 768KB <ul><li>其中基本内存为 <code>0x00000</code> - <code>0x9FFFF</code> 共 640KB</li><li>显示内存缓冲区为 <code>0xA0000</code> - <code>0xBFFFF</code> 共 128KB</li></ul></li><li>ROM 占据从 <code>0xC0000</code> - <code>0xFFFFF</code> 开始的高端地址 256KB <ul><li>其中，系统 BIOS 占用最后的 64 KB 或更多 (<code>0xF0000</code> - <code>0xFFFFF</code>)</li></ul></li></ul><p>CPU 复位时，<code>CS</code> 寄存器设为 <code>0xFFFF</code>，<code>IP</code> 寄存器设为 <code>0x0000</code> - 地址指向 <code>0xFFFF0</code>，即 ROM BIOS 中的最后 16B 处、此处放置了一条 <code>JMP</code> 指令，指向 BIOS 程序的真正入口地址。此时，CPU 控制权被 BIOS 获得：</p><ul><li>BIOS 首先执行系统自检 POST (Power-On-Self-Test)</li><li>并在 RAM 最低端建立中断向量表等 OS 需要使用的配置表</li><li>初始化硬件 - 首先初始化显卡，并将后续硬件信息显示在 (显示缓冲区)</li><li>按照 CMOS 设定的启动顺序，依次寻找主引导记录</li><li>将主引导记录加载到 <code>0x7C00</code> 的位置 - 512B</li><li>检测 MBR 最后两个字节是否为 <code>0x55</code> 和 <code>0xAA</code>，如果是，则可以启动</li><li>跳转到引导程序的入口，将控制权交由引导程序</li></ul><h4 id="_80386-32-bit-地址线-启动方式" tabindex="-1"><a class="header-anchor" href="#_80386-32-bit-地址线-启动方式"><span>80386 (32 bit 地址线) 启动方式</span></a></h4><p>32 位地址线可以寻址 <code>0x00000000</code> - <code>0xFFFFFFFF</code> 共 4G 的地址空间。</p><p><img src="'+t+'" alt="2-5"></p><ul><li>ROM (Flash Memory) 被编址在了 4G 内存的最高端 <ul><li>Flash Memory 的大小可以为 256KB - 2MB</li></ul></li><li>32-bit CPU 复位后，通过硬件机制，使其访问的第一条指令位于 <code>0xFFFFFFF0</code>，即最后 16B 处</li><li>同样，这里也有一条 <code>JMP</code> 指令，跳转到 BIOS 真正的入口</li><li>在完成硬件自检和初始化操作后，BIOS 会将与原先兼容的 64 KB 系统 BIOS 拷贝到内存低端 1M 的最后 64KB 处，并跳转到该处，使 CPU 真正运行在实地址模式下</li><li>BIOS 寻找引导程序并加载至 <code>0x7C00</code> 处</li></ul><blockquote><p>个人理解，首先，ROM 和 RAM 的编址应当是连续的，如果再将 1M 地址空间中的高 256KB 分配给ROM，RAM 的地址将不再连续。所以永远将 ROM 编址在内存最高端，为了兼容，因此 BIOS 需要将兼容的一段 BIOS 复制到 RAM 中对应原先 ROM 的地址处。因此，这一段 RAM 称为 <em>BIOS Shadow</em>。然后跳转到 BIOS Shadow 的程序入口，这样，启动的过程就与原先兼容。总之：</p><ol><li>ROM 永远编址在内存最高端</li><li>CPU 复位后访问的第一条指令总位于内存最高端的最后 16B 处</li><li>不管 BIOS 中有多少新特性，Flash ROM 总体大小有多大，最终 BIOS 总需要将兼容程序拷贝到 1M 空间最后 64KB，并跳转过去，使 CPU 在实地址模式下启动</li></ol></blockquote><h3 id="_2-3-3-cmos-存储器" tabindex="-1"><a class="header-anchor" href="#_2-3-3-cmos-存储器"><span>2.3.3 CMOS 存储器</span></a></h3><p><em>Complementary Metal Oxide Semiconductor，互补金属氧化物半导体</em>，存储容量很小： 64 / 128B。存放：</p><ul><li>实时时钟信息</li><li>系统硬件配置信息</li></ul><p>CMOS 的地址空间在基本内存地址空间之外，需要使用 I/O 指令访问。</p><hr><h2 id="_2-4-控制器和控制卡" tabindex="-1"><a class="header-anchor" href="#_2-4-控制器和控制卡"><span>2.4 控制器和控制卡</span></a></h2><ul><li>控制器指集成在计算机主板上的控制部件</li><li>控制卡指通过扩展插槽进入计算机的控制卡部件，扩展插槽与系统总线连接，接口标准包含： <ul><li><em>ISA, Industry Standard Architecture</em> 总线</li><li><em>EISA, Extended ISA</em> 总线</li><li><em>PCI, Peripheral Component Interconnect</em> 总线</li><li><em>AGP, Accelerated Graphics Port</em> 总线</li></ul></li></ul><p>控制卡可以随着集成度的提高而被集成到主板上，因此控制器和控制卡没有实质上的区别。</p><h3 id="_2-4-1-中断控制器" tabindex="-1"><a class="header-anchor" href="#_2-4-1-中断控制器"><span>2.4.1 中断控制器</span></a></h3><p>使用两片级联的 8259A 可编程中断控制芯片组成中断控制器，能为 15 个设备提供独立的中断功能。ROM BIOS 对 8259A 芯片进行初始化：</p><ul><li>分配 15 级中断优先级</li><li>在内存最低端建立中断向量表</li></ul><p>Linux 不会直接使用 BIOS 设置好的中断号，在内核初始化期间，重新对 8259A 进行设置，将所有硬件中断号全部映射到 <code>0x20</code> 以上。</p><h3 id="_2-4-2-dma-控制器" tabindex="-1"><a class="header-anchor" href="#_2-4-2-dma-控制器"><span>2.4.2 DMA 控制器</span></a></h3><p>由 Intel 8237 及其兼容芯片实现，外设与内存之间的数据传输能在不受 CPU 控制的条件下进行。</p><h3 id="_2-4-3-定时-计数器" tabindex="-1"><a class="header-anchor" href="#_2-4-3-定时-计数器"><span>2.4.3 定时 / 计数器</span></a></h3><p>Intel 8253/8254 芯片提供了三个独立的 16 位计数器通道，分别被用于：</p><ul><li>时钟计时中断信号</li><li>动态内存 DRAM 刷新定时电路</li><li>主机扬声器音调合成</li></ul><p>Linux 0.12 只对通道 0 进行了重新设置，使其工作在方式 3 下：</p><ul><li>每隔 10 ms 发出一个信号，产生中断请求 IRQ0</li><li>该中断时 Linux 0.12 内核工作的脉搏</li><li>用于定时切换当前执行的任务和统计每个任务使用的系统资源量</li></ul><h3 id="_2-4-4-键盘控制器" tabindex="-1"><a class="header-anchor" href="#_2-4-4-键盘控制器"><span>2.4.4 键盘控制器</span></a></h3><p>键盘上有一个处理器称为 <strong>键盘编码器</strong> (Intel 8048)，专门用于扫描按键状态信息：扫描码。</p><ul><li>当按键按下时，键盘编码器发送 <strong>接通码</strong> (Make Code)</li><li>当按键松开时，键盘编码器发送 <strong>断开码</strong> (Break Code)</li></ul><p>主机的键盘控制器对扫描码进行解码，并将解码后的数据发送到 OS 的键盘数据队列中。键盘控制器收到串行数据后，将 <strong>键盘扫描码</strong> 转换为 <strong>系统扫描码</strong>，并通过 IRQ1 向 CPU 发出中断请求。CPU 调用键盘中断处理程序读取控制器中的扫描码。</p><h3 id="_2-4-5-串行控制卡" tabindex="-1"><a class="header-anchor" href="#_2-4-5-串行控制卡"><span>2.4.5 串行控制卡</span></a></h3><p>异步串行通信的帧包含：</p><ul><li>起始位</li><li>数据位</li><li>奇偶校验位</li><li>停止位</li></ul><p>PC 上电时，RESET 信号使 UART 内部寄存器和控制逻辑复位。此后若要使用，需要对其进行初始化编程。</p><h3 id="_2-4-6-显示控制" tabindex="-1"><a class="header-anchor" href="#_2-4-6-显示控制"><span>2.4.6 显示控制</span></a></h3><p>。</p><h3 id="_2-4-7-软盘和硬盘控制器" tabindex="-1"><a class="header-anchor" href="#_2-4-7-软盘和硬盘控制器"><span>2.4.7 软盘和硬盘控制器</span></a></h3><p>通常使用上下两个磁头在盘片的上下两面读写数据，磁头上分别有一个读线圈和写线圈。由于磁盘旋转，盘片上的磁介质相对磁头作匀速运动。</p><ul><li>磁头在切割磁介质的磁感线，从而产生感应电流</li><li>根据磁介质状态的方向不同，感应电流方向不同，从而区分 0 和 1</li><li>每个磁道都有存放信息的特定格式，因此能够区分各磁道的比特流</li></ul><p>磁盘控制器是 CPU 和驱动器之间的逻辑接口电路</p><ul><li>从 CPU 接受请求命令</li><li>向驱动器发送寻道、读/写和控制信号</li><li>控制和转换数据流格式 <ul><li>分离驱动器上的 metadata</li><li>CPU 的并行数据流和驱动器的串行数据流之间的转换</li></ul></li></ul><p>对磁盘控制器的编程：</p><ul><li>通过 I/O 端口设置控制器中的相关寄存器</li><li>通过寄存器获取操作结果</li></ul>',77)]))}const p=i(r,[["render",c],["__file","Chapter 2 - 微型计算机组成结构.html.vue"]]),u=JSON.parse('{"path":"/linux-kernel-comments-notes/Chapter%202%20-%20%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84/Chapter%202%20-%20%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84.html","title":"Chapter 2 - 微型计算机组成结构","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"2.1 微型计算机组成原理","slug":"_2-1-微型计算机组成原理","link":"#_2-1-微型计算机组成原理","children":[]},{"level":2,"title":"2.2 I/O 端口寻址和访问控制方式","slug":"_2-2-i-o-端口寻址和访问控制方式","link":"#_2-2-i-o-端口寻址和访问控制方式","children":[{"level":3,"title":"2.2.1 I/O 端口和寻址","slug":"_2-2-1-i-o-端口和寻址","link":"#_2-2-1-i-o-端口和寻址","children":[]},{"level":3,"title":"2.2.2 接口访问控制","slug":"_2-2-2-接口访问控制","link":"#_2-2-2-接口访问控制","children":[]}]},{"level":2,"title":"2.3 主存储器、BIOS 和 CMOS 存储器","slug":"_2-3-主存储器、bios-和-cmos-存储器","link":"#_2-3-主存储器、bios-和-cmos-存储器","children":[{"level":3,"title":"2.3.1 主存储器","slug":"_2-3-1-主存储器","link":"#_2-3-1-主存储器","children":[]},{"level":3,"title":"2.3.2 基本输入/输出程序 BIOS","slug":"_2-3-2-基本输入-输出程序-bios","link":"#_2-3-2-基本输入-输出程序-bios","children":[]},{"level":3,"title":"2.3.3 CMOS 存储器","slug":"_2-3-3-cmos-存储器","link":"#_2-3-3-cmos-存储器","children":[]}]},{"level":2,"title":"2.4 控制器和控制卡","slug":"_2-4-控制器和控制卡","link":"#_2-4-控制器和控制卡","children":[{"level":3,"title":"2.4.1 中断控制器","slug":"_2-4-1-中断控制器","link":"#_2-4-1-中断控制器","children":[]},{"level":3,"title":"2.4.2 DMA 控制器","slug":"_2-4-2-dma-控制器","link":"#_2-4-2-dma-控制器","children":[]},{"level":3,"title":"2.4.3 定时 / 计数器","slug":"_2-4-3-定时-计数器","link":"#_2-4-3-定时-计数器","children":[]},{"level":3,"title":"2.4.4 键盘控制器","slug":"_2-4-4-键盘控制器","link":"#_2-4-4-键盘控制器","children":[]},{"level":3,"title":"2.4.5 串行控制卡","slug":"_2-4-5-串行控制卡","link":"#_2-4-5-串行控制卡","children":[]},{"level":3,"title":"2.4.6 显示控制","slug":"_2-4-6-显示控制","link":"#_2-4-6-显示控制","children":[]},{"level":3,"title":"2.4.7 软盘和硬盘控制器","slug":"_2-4-7-软盘和硬盘控制器","link":"#_2-4-7-软盘和硬盘控制器","children":[]}]}],"git":{},"filePathRelative":"linux-kernel-comments-notes/Chapter 2 - 微型计算机组成结构/Chapter 2 - 微型计算机组成结构.md"}');export{p as comp,u as data};
