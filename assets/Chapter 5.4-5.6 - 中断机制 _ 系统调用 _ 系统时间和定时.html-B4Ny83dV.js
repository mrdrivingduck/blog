import{_ as n,c as a,a as s,o as l}from"./app-7eKjwDat.js";const i={};function t(p,e){return l(),a("div",null,e[0]||(e[0]=[s(`<h1 id="chapter-5-4-5-6-中断机制-系统调用-系统时间和定时" tabindex="-1"><a class="header-anchor" href="#chapter-5-4-5-6-中断机制-系统调用-系统时间和定时"><span>Chapter 5.4-5.6 - 中断机制 &amp; 系统调用 &amp; 系统时间和定时</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 08 / 03 11:41</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="_5-4-中断机制" tabindex="-1"><a class="header-anchor" href="#_5-4-中断机制"><span>5.4 中断机制</span></a></h2><h3 id="_5-4-1-中断操作原理" tabindex="-1"><a class="header-anchor" href="#_5-4-1-中断操作原理"><span>5.4.1 中断操作原理</span></a></h3><p>可编程中断控制器 (Programmable Interrupt Controller) 是微机系统中设备中断请求的管理者。</p><ul><li>连接到设备的中断请求引脚，接受中断请求信号</li><li>在同时收到几个中断的情况下，PIC 会对它们进行优先级比较，选出最高优先级中断进行处理</li><li>PIC 向 CPU 的 INT 引脚发出中断信号，通过数据总线发送与中断请求对应的中断号</li><li>CPU 停下当时所做的事情，根绝中断号查询中断表，并开始执行中断服务程序</li></ul><p>中断也可由软件产生：使用 <code>INT</code> 指令，并用操作数指明中断号。</p><h3 id="_5-4-2-80x86-微机的中断子系统" tabindex="-1"><a class="header-anchor" href="#_5-4-2-80x86-微机的中断子系统"><span>5.4.2 80X86 微机的中断子系统</span></a></h3><p>每个 8259A 芯片可以管理 8 个中断源，多片级联，最多可以管理 64 个中断向量系统。在 PC/AT 系列兼容机中，使用了两片 8259A，可管理 15 级中断向量，从片的 INT 引脚级联到了主片的 IRQ2 上，主片的原 IRQ2 被接到了从片的 IRQ9 上。BIOS 中的软件把 IRQ9 的中断 INT 71 定向到 IRQ2 的中断 INT 0x0A 上</p><blockquote><p>为了兼容。。。</p></blockquote><p>在总线控制器控制下，8259A 芯片可以处于编程状态和操作状态：</p><ul><li>编程状态：CPU 使用 IN 或 OUT 指令对芯片进行初始化编程的状态</li><li>操作状态：芯片随时响应外部请求</li></ul><h3 id="_5-4-3-中断向量表" tabindex="-1"><a class="header-anchor" href="#_5-4-3-中断向量表"><span>5.4.3 中断向量表</span></a></h3><p>80X86 支持 256 个中断。在实地址模式下，每个中断向量由 4B 组成，中断向量指明了对应中断服务程序的段和段内偏移，因此整个中断向量表的长度为 1024B。80X86 微机启动时，ROM BIOS 会在物理内存 0 处初始化中断向量表，各中断默认的中断服务程序则在 BIOS 中给出。在 BIOS 初始化操作中，设置了 8259A 芯片支持的 15 个中断向量，对于实际没有使用的向量，填入临时的哑中断服务程序地址。</p><p>对于 Linux，在刚开始加载内核时需要用到 BIOS 提供的显示和磁盘读中断，之后 Linux 会重新初始化 8259A 芯片，并重新设置一张中断向量表。即 Linux 在内核正常运行之后完全抛弃了 BIOS 所提供的中断服务功能。</p><h3 id="_5-4-4-linux-内核的中断处理" tabindex="-1"><a class="header-anchor" href="#_5-4-4-linux-内核的中断处理"><span>5.4.4 Linux 内核的中断处理</span></a></h3><p>对于 Linux 内核来说，中断信号分为：</p><ul><li>硬件中断</li><li>软件中断 (异常)</li></ul><p>每个中断由 0-255 之间的数字来标识，前 32 个中断号由 Intel 公司固定设定或保留，属于软件中断；中断 INT32 - INT255 可以由用户自己设定。在 Linux 系统中，将 INT32 - INT47 对应于 8259A 的 IRQ0 - IRQ15，并把用户程序发出的软件中断设置为 INT128 (0x80)：系统调用 (System Call)，是用户程序使用 OS 资源的唯一界面接口。</p><p>系统初始化时，内核使用哑中断向量对 IDT 中的 256 个描述符进行默认设置。哑中断向量指向默认的无中断处理过程。INT0 - INT31 在 <code>traps.c</code> 中进行了重新设置，INT128 则在调度程序初始化函数中进行了重新设置。设置 IDT 时，Linux 内核使用了中断门和陷阱门两种描述符：</p><ul><li>中断门描述符执行的中断会复位 IF 标志，避免其它中断干扰当前中断处理过程</li><li>陷阱门中执行的中断不会影响 IF 标志</li></ul><h3 id="_5-4-5-标志寄存器的中断标志" tabindex="-1"><a class="header-anchor" href="#_5-4-5-标志寄存器的中断标志"><span>5.4.5 标志寄存器的中断标志</span></a></h3><p>为了避免竞争条件和中断对临界代码区的干扰，Linux 0.12 内核代码中许多地方使用了 CLI 和 STI 指令进行开中断 / 关中断。</p><hr><h2 id="_5-5-linux-的系统调用" tabindex="-1"><a class="header-anchor" href="#_5-5-linux-的系统调用"><span>5.5 Linux 的系统调用</span></a></h2><h3 id="_5-5-1-系统调用接口" tabindex="-1"><a class="header-anchor" href="#_5-5-1-系统调用接口"><span>5.5.1 系统调用接口</span></a></h3><p>系统调用是 Linux 内核与上层应用程序进行交互通信的唯一接口。用户程序通过直接或间接 (库函数) 调用中断 INT 0x80，并在 eax 寄存器中指定系统调用功能号。通常应用程序都是使用具有标准接口定义的 C 库函数间接地使用系统调用，系统调用通过函数的形式调用，因此可以附带参数。执行结果会在返回值中表示：通常负值表示错误，0 表示成功。出错时，错误的类型码会被存放在全局变量 errno 中，通过调用库函数 <code>perror()</code> 可以打印出对应出错的字符串信息。</p><p>在 Linux 内核中，每个系统调用都具有唯一的系统调用功能号。0.12 中有 87 个系统调用功能，定义在 <code>include/unistd.h</code> 中，对应于 <code>include/linux/sys.h</code> 定义的系统调用处理程序指针数组表 <code>sys_call_table[]</code> 中的索引。</p><h3 id="_5-5-2-系统调用处理过程" tabindex="-1"><a class="header-anchor" href="#_5-5-2-系统调用处理过程"><span>5.5.2 系统调用处理过程</span></a></h3><p>寄存器 eax 中存放系统调用号，参数可依次放在 ebx、ecx 和 edx 中。因此 Linux 0.12 内核中，用户程序能够向内核最多直接传递三个参数。若需要传递大块数据，可以传递这块数据的指针。内核源码中定义了宏函数 <code>_syscalln()</code>，<code>n</code> 代表携带参数的个数，分别是 0 - 3。</p><p>对于 <code>read()</code> 系统调用，定义是：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>对应的宏形式：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token function">_syscall3</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> read<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>第一个参数对应返回值类型</li><li>第二个参数对应系统调用名称</li><li>之后是每个参数的参数类型和名称</li></ul><p>这个宏会被扩展成包含内嵌汇编的 C 函数。</p><p>对于多于三个参数的系统调用，通常使用 <code>_syscall1()</code>，把参数 buffer 的指针传给内核即可。</p><p>进入内核的系统调用处理程序 <code>kernel/sys_call.s</code> 后，首先检查 eax 中系统调用功能号是否在有效系统调用号范围内，然后根据 <code>sys_call_table[]</code> 函数指针表执行相应的系统调用处理程序。</p><h3 id="_5-5-3-linux-系统调用的参数传递方式" tabindex="-1"><a class="header-anchor" href="#_5-5-3-linux-系统调用的参数传递方式"><span>5.5.3 Linux 系统调用的参数传递方式</span></a></h3><p>Linux 系统使用的是通用寄存器传递方法。优点：当进入中断服务程序而保存寄存器值时，这些传递参数寄存器也被自动放在了内核堆栈上，不用再专门对传递参数的寄存器进行特殊处理。在每个系统调用处理程序中，应当对传递的参数进行验证，保证所有参数都合法有效。</p><hr><h2 id="_5-6-系统时间和定时" tabindex="-1"><a class="header-anchor" href="#_5-6-系统时间和定时"><span>5.6 系统时间和定时</span></a></h2><h3 id="_5-6-1-系统时间" tabindex="-1"><a class="header-anchor" href="#_5-6-1-系统时间"><span>5.6.1 系统时间</span></a></h3><p>PC/AT 微机系统中提供了用电池供电的实时钟 RT (Real Time) 电路，这部分电路与保存系统信息的 CMOS RAM 集成在一个芯片上：RT/CMOS RAM 电路 - 比如 Motorola 的 MC146818 芯片。内核初始化时，通过 <code>init/main.c</code> 中的 <code>time_init()</code> 函数读取芯片上的当前时间，通过 <code>kernel/mktime.c</code> 中的 <code>kernel_mktime()</code> 函数转换为 Unix 日历时间。</p><p>该时间确定了系统开始运行的日历时间，保存在全局变量 <code>startup_time</code> 中供内核所有代码会用，通过系统调用 <code>time()</code> 可以读取这个值，super user 可以通过系统调用 <code>stime()</code> 修改该值。</p><p>从系统启动开始计数的系统滴答值 - <code>jiffies</code>：程序可以唯一确定当前时间。每个滴答由系统定时芯片产生 - 10ms。因此内核代码中定义了一个宏，方便代码对当前时间的访问：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CURRENT_TIME</span> <span class="token expression"><span class="token punctuation">(</span>startup_time <span class="token operator">+</span> jiffies<span class="token operator">/</span>HZ<span class="token punctuation">)</span></span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>HZ = 100，是内核系统时钟的频率。</p><h3 id="_5-6-2-系统定时" tabindex="-1"><a class="header-anchor" href="#_5-6-2-系统定时"><span>5.6.2 系统定时</span></a></h3><p>Linux 0.12 内核初始化过程中，PC 中的 Intel 8253/8254 芯片的计数器通道 0 被设置在运行于方式 3 下。每隔 10ms 在通道 0 的输出端 OUT 发出一个方波上升沿，OUT 被连接到 PIC 的 0 级上，因此每 10ms 会产生一个时钟中断 IRQ0。这个时间节拍是 OS 的脉搏：一次中断被称为一个系统滴答或一个系统时钟周期，每经过一个系统时钟周期，系统就会调用一次时钟中断处理程序。时钟中断处理程序通过 <code>jiffies</code> 变量来累积系统启动以来的滴答数：每发生一次时钟中断，<code>jiffies</code> 就加 1，然后调用 <code>do_time()</code> 进行进一步处理。</p><p><code>do_timer()</code> 函数根据特权级对当前进程运行时间作累积</p><ul><li>CPL == 0，那么进程被中断于内核态，进程的内核态运行时间 + 1</li><li>否则把进程的用户态运行时间 + 1</li></ul><p><strong>时间片</strong> 是一个进程被切换掉之前能持续运行 CPU 的时间，以系统滴答为单位，每发生一次时钟中断，时间片 - 1。若进程时间片递减后依旧 &gt; 0，说明时间片还没有用完 - 退出 <code>do_timer()</code> 继续运行当前进程；如果时间片减至 0，内核根据被中断程序的级别做进一步处理：</p><ul><li>如果被中断进程运行在用户态，<code>do_timer()</code> 调用调度程序 <code>schedule()</code> 切换到其它进程</li><li>如果被中断进程运行在内核态，<code>do_timer()</code> 立刻退出</li><li>决定了进程在内核态运行时是不可抢占的，在用户态运行时是可以被抢占的</li></ul>`,57)]))}const o=n(i,[["render",t],["__file","Chapter 5.4-5.6 - 中断机制 _ 系统调用 _ 系统时间和定时.html.vue"]]),d=JSON.parse('{"path":"/linux-kernel-comments-notes/Chapter%205%20-%20Linux%20%E5%86%85%E6%A0%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Chapter%205.4-5.6%20-%20%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%20_%20%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%20_%20%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%92%8C%E5%AE%9A%E6%97%B6.html","title":"Chapter 5.4-5.6 - 中断机制 & 系统调用 & 系统时间和定时","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"5.4 中断机制","slug":"_5-4-中断机制","link":"#_5-4-中断机制","children":[{"level":3,"title":"5.4.1 中断操作原理","slug":"_5-4-1-中断操作原理","link":"#_5-4-1-中断操作原理","children":[]},{"level":3,"title":"5.4.2 80X86 微机的中断子系统","slug":"_5-4-2-80x86-微机的中断子系统","link":"#_5-4-2-80x86-微机的中断子系统","children":[]},{"level":3,"title":"5.4.3 中断向量表","slug":"_5-4-3-中断向量表","link":"#_5-4-3-中断向量表","children":[]},{"level":3,"title":"5.4.4 Linux 内核的中断处理","slug":"_5-4-4-linux-内核的中断处理","link":"#_5-4-4-linux-内核的中断处理","children":[]},{"level":3,"title":"5.4.5 标志寄存器的中断标志","slug":"_5-4-5-标志寄存器的中断标志","link":"#_5-4-5-标志寄存器的中断标志","children":[]}]},{"level":2,"title":"5.5 Linux 的系统调用","slug":"_5-5-linux-的系统调用","link":"#_5-5-linux-的系统调用","children":[{"level":3,"title":"5.5.1 系统调用接口","slug":"_5-5-1-系统调用接口","link":"#_5-5-1-系统调用接口","children":[]},{"level":3,"title":"5.5.2 系统调用处理过程","slug":"_5-5-2-系统调用处理过程","link":"#_5-5-2-系统调用处理过程","children":[]},{"level":3,"title":"5.5.3 Linux 系统调用的参数传递方式","slug":"_5-5-3-linux-系统调用的参数传递方式","link":"#_5-5-3-linux-系统调用的参数传递方式","children":[]}]},{"level":2,"title":"5.6 系统时间和定时","slug":"_5-6-系统时间和定时","link":"#_5-6-系统时间和定时","children":[{"level":3,"title":"5.6.1 系统时间","slug":"_5-6-1-系统时间","link":"#_5-6-1-系统时间","children":[]},{"level":3,"title":"5.6.2 系统定时","slug":"_5-6-2-系统定时","link":"#_5-6-2-系统定时","children":[]}]}],"git":{},"filePathRelative":"linux-kernel-comments-notes/Chapter 5 - Linux 内核体系结构/Chapter 5.4-5.6 - 中断机制 & 系统调用 & 系统时间和定时.md"}');export{o as comp,d as data};
