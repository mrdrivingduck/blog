import{_ as i,c as l,a,o as n}from"./app-BeHGwf2X.js";const o={};function s(t,e){return n(),l("div",null,e[0]||(e[0]=[a(`<h1 id="chapter-5-how-the-linux-kernel-boots" tabindex="-1"><a class="header-anchor" href="#chapter-5-how-the-linux-kernel-boots"><span>Chapter 5 - How the Linux Kernel Boots</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 06 / 25 0:14</p><p>@dorm, NUAA, Nanjing, Jiangsu, China</p><hr><p>内核如何启动？</p><ol><li>BIOS 或固件装载并运行 boot loader</li><li>boot loader 找到磁盘上的内核映像，将其装入内存并启动</li><li>内核初始化设备及其驱动</li><li>内核挂载根文件系统</li><li>内核启动 PID 为 1 的程序 <code>init</code> - 此时用户空间启动</li><li><code>init</code> 启动剩余的系统进程</li><li><code>init</code> 启动一个用于登录的进程</li></ol><h2 id="_5-1-startup-messages" tabindex="-1"><a class="header-anchor" href="#_5-1-startup-messages"><span>5.1 Startup Messages</span></a></h2><p>传统的 Unix 系统会打印大量表示启动过程的信息，但现代系统已经尽可能隐藏这些信息了。如果想看，可以：</p><ul><li>查看内核日志文件 - <code>/var/log/kern.log</code></li><li>使用 <code>dmesg</code> 命令，但需要通过管道连接到 <code>less</code> 中，否则太多</li></ul><h2 id="_5-2-kernel-initialization-and-boot-options" tabindex="-1"><a class="header-anchor" href="#_5-2-kernel-initialization-and-boot-options"><span>5.2 Kernel Initialization and Boot Options</span></a></h2><p>Linux 内核的初始化顺序：</p><ol><li>CPU 检查</li><li>存储器检查</li><li>发现设备总线</li><li>发现设备</li><li>内核辅助子系统启动</li><li>根文件系统挂载</li><li>用户空间启动</li></ol><h2 id="_5-3-kernel-parameters" tabindex="-1"><a class="header-anchor" href="#_5-3-kernel-parameters"><span>5.3 Kernel Parameters</span></a></h2><p>在运行 Linux 内核时，boot loader 传递一系列文本参数 (kernel parameters)，告诉内核它应该如何启动。可以在 <code>/proc/cmdline</code> 中查看内核参数：</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ cat /proc/cmdline</span>
<span class="line">BOOT_IMAGE=/boot/vmlinuz-4.15.0-51-generic root=UUID=af284c6e-d36f-410d-8c9e-950532e5ee89 ro console=tty1 console=ttyS0</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>one-word flags</li><li>key=value pairs</li></ul><p>其中，<code>root</code> 代表根文件系统所在位置：</p><ul><li>可以是一个设备文件（分区）</li><li>现在桌面系统中，UUID 更加流行</li></ul><p><code>ro</code> 命令内核以 read-only 的方式挂载根文件系统：</p><ul><li>确保 <code>fsck</code> 能够安全地检测根文件系统</li><li>检测完成之后，内核重新以 read-write 模式挂载根文件系统</li></ul><p>对于内核不认识的参数，内核会将其作为 <code>init</code> 函数的参数传递过去。</p><h2 id="_5-4-boot-loaders" tabindex="-1"><a class="header-anchor" href="#_5-4-boot-loaders"><span>5.4 Boot Loaders</span></a></h2><p>在启动的过程中，由 boot loader 来启动内核。功能看起来很简单：将内核装载到内存中，将一些列 kernel parameter 传递给内核，并启动内核。但是 boot loader 必须能够回答以下问题：</p><ul><li>内核在哪里？</li><li>当内核启动时，应当将哪些参数传递给它</li></ul><p>显然，内核及其参数肯定位于根文件系统的某个位置。然而，此时内核还没有开始运行，因此无法通过遍历文件系统来寻找。此外，用于访问磁盘的设备驱动也无法使用 - <em>chicken or egg</em> problem。在 PC 上，boot loader 使用以下两种方式访问磁盘：</p><ul><li>Basic Input/Output System (BIOS)</li><li>Unified Extensible Firmware Interface (UEFI)</li></ul><p>几乎所有的磁盘硬件都有允许 BIOS 使用 <em>Linear Block Addressing (LBA)</em> 来访问存储的固件，这种访问方式性能很低，但允许磁盘的完全访问。Boot loader 通常是使用这种访问方式的唯一程序。内核使用其高性能的驱动程序访问磁盘。</p><p>有一些先进的 boot loader 能够读取分区表，并提供了内置以 read-only 的方式访问文件系统的支持。因此 boot loader 可以寻找并读取文件。</p><h3 id="_5-4-1-boot-loader-tasks" tabindex="-1"><a class="header-anchor" href="#_5-4-1-boot-loader-tasks"><span>5.4.1 Boot Loader Tasks</span></a></h3><p>一个 Linux boot loader 的核心功能：</p><ul><li>在多个内核中选择</li><li>在一系列内核参数中切换</li><li>允许用户手动覆盖或编辑内核映像名和参数</li><li>提供启动其它操作系统的支持</li></ul><h3 id="_5-4-2-boot-loader-overview" tabindex="-1"><a class="header-anchor" href="#_5-4-2-boot-loader-overview"><span>5.4.2 Boot Loader Overview</span></a></h3><ul><li>GRUB：Linux 系统的基本标配</li><li>LILO：最早期的 Linux boot loader 之一</li><li>SYSLINUX</li><li>LOADLIN：从 MS-DOS 启动内核</li><li>efilinux</li><li>coreboot</li><li>Linux Kernel EFISTUB - 内核插件，直接从 ESP 分区装载内核</li></ul><h2 id="_5-5-grub-introduction" tabindex="-1"><a class="header-anchor" href="#_5-5-grub-introduction"><span>5.5 GRUB Introduction</span></a></h2><p>GRUB - <em>Grand Unified Boot Loader</em>。GRUB 最重要的能力是文件系统导航，使得选择内核映像和配置更加简单 (从 GRUB 的菜单就可以看出)。当 BIOS 或固件启动时，按住 shift 可以进入 GRUB 菜单；在菜单界面超时后，会自动启动。按下 <code>e</code> 按钮可以查看 boot loader 的配置命令。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">setparams &#39;Ubuntu, with Linux 3.2.0-31-generic-pae&#39;</span>
<span class="line">recordfail</span>
<span class="line">gfxmode $linux_gfx_mode</span>
<span class="line">insmod gzio</span>
<span class="line">insmod part_msdos</span>
<span class="line">insmod ext2</span>
<span class="line">set root=&#39;(hd0,msdos1)&#39;</span>
<span class="line">search --no-floppy --fs-uuid --set=root 4898e145-b064-45hd-b7b4-7326b00273b7</span>
<span class="line">linux /boot/vmlinuz-3.2.0-31-generic-pae root=UUID=489e145-b064-45bd-b7b4-7326b00273b7 ro quiet splash $vt_handoff</span>
<span class="line">initrd /boot/initrd.img-3.2.0-31-generic-pae</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>内核映像为 <code>/boot/vmlinuz-3.2.0-31-generic-pae</code></li><li>根文件系统由 UUID 标识</li><li>内核参数包含 <code>ro</code>、<code>quiet</code>、<code>splash</code></li><li>初始化 RAM 文件系统为 <code>/boot/initrd.img-3.2.0-31-generic-pae</code></li></ul><p>GRUB 只用于启动内核，因此不依赖于内核。上述命令全部是 GRUB 的内部命令</p><ul><li>GRUB 有自己的内核</li><li>GRUB 有自己的 <code>insmod</code> 命令，用于动态载入 GRUB 模块</li><li>很多 GRUB 命令和 Unix shell 的命令类似，比如 <code>ls</code></li></ul><p>上述命令中，只有 linux 命令下的 root 表示根文件系统的位置。其它 root 是 GRUB 的 root，是 GRUB 搜索内核和 RAM 文件系统映像的位置。在上述命令中，<code>root</code> 首先被设定为 <code>hd0,msdos1</code>，并在之后指定了一个 UUID，GRUB 在分区上查找该 UUID。如果找到，则将 <code>root</code> 设定为该 UUID 所在分区，<code>linux</code> 和 <code>initrd</code> 命令表示从 GRUB root 所在分区中的 <code>/boot</code> 目录下载入映像。以上配置命令可以在 GRUB 中修改。</p><h3 id="_5-5-1-exploring-devices-and-partitions-with-the-grub-command-line" tabindex="-1"><a class="header-anchor" href="#_5-5-1-exploring-devices-and-partitions-with-the-grub-command-line"><span>5.5.1 Exploring Devices and Partitions with the GRUB Command Line</span></a></h3><p>通过按下 <code>C</code> 可以进入 GRUB 命令行</p><h4 id="listing-devices" tabindex="-1"><a class="header-anchor" href="#listing-devices"><span>Listing Devices</span></a></h4><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">grub&gt; ls</span>
<span class="line">(hd0)  (hd0,msdos1)  (hd0,msdos5)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>ls</code> 命令列出了 GRUB 识别的所有设备</li><li><code>msdos</code> 表示磁盘包含 MBR 分区表，因此可能会有 <code>gpt</code> 的前缀</li></ul><p>使用 <code>ls -l</code> 可以详细查看各个分区的信息：</p><ul><li>文件系统类型</li><li>大小、最后修改时间</li><li>UUID</li></ul><h4 id="file-navigation" tabindex="-1"><a class="header-anchor" href="#file-navigation"><span>File Navigation</span></a></h4><p>GRUB 的文件系统导航能力</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">grub&gt; echo $root</span>
<span class="line">hd0,msdos1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">grub&gt; ls (hd0,msdos1)/</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">grub&gt; ls ($root)/</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">grub&gt; ls ($root)/boot</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>使用 <code>set</code> 命令可以查看所有的 GRUB 变量：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">grub&gt; set</span>
<span class="line">?=0</span>
<span class="line">color_highlight=black/white</span>
<span class="line">color_normal=white/black</span>
<span class="line">--snip--</span>
<span class="line">prefix=(hd0,msdos1)/boot/grub</span>
<span class="line">root=hd0,msdos1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>$prefix</code> 是 GRUB 寻找其配置文件和额外支持的路径。</p><h3 id="_5-5-2-grub-configuration" tabindex="-1"><a class="header-anchor" href="#_5-5-2-grub-configuration"><span>5.5.2 GRUB Configuration</span></a></h3><p>GRUB 的配置目录包含一个核心配置文件 <code>grub.cfg</code> 和大量可装载的模块 <code>-.mod</code>。</p><h4 id="reviewing-grub-cfg" tabindex="-1"><a class="header-anchor" href="#reviewing-grub-cfg"><span>Reviewing Grub.cfg</span></a></h4><h4 id="generating-a-new-configuration-file" tabindex="-1"><a class="header-anchor" href="#generating-a-new-configuration-file"><span>Generating a New Configuration File</span></a></h4><h3 id="_5-5-3-grub-installation" tabindex="-1"><a class="header-anchor" href="#_5-5-3-grub-installation"><span>5.5.3 GRUB Installation</span></a></h3><h4 id="installing-grub-on-your-system" tabindex="-1"><a class="header-anchor" href="#installing-grub-on-your-system"><span>Installing GRUB on Your System</span></a></h4><p>安装 boot loader 需要用户或安装器决定：</p><ul><li>GRUB 的目标路径，默认为 <code>/boot/grub</code>，但其它操作系统不同</li><li>GRUB 安装的目标设备</li><li>对于 UEFI 启动，还需要 UEFI boot 分区的挂载点</li></ul><p>GRUB 是一个模块化的系统，需要读取文件系统下的 GRUB 路径。所以在 Linux 上，只需要将 GRUB 和 ext2.mod 预装载版本放置在磁盘的启动区，其余部分放置在 GRUB 的目录下即可。</p><h2 id="_5-6-uefi-secure-boot-problems" tabindex="-1"><a class="header-anchor" href="#_5-6-uefi-secure-boot-problems"><span>5.6 UEFI Secure Boot Problems</span></a></h2><p>UEFI 的安全机制要求 boot loader 必须被可信方签名后才可运行，无法安装未被签名的 boot loader。</p><h2 id="_5-7-chainloading-other-operating-system" tabindex="-1"><a class="header-anchor" href="#_5-7-chainloading-other-operating-system"><span>5.7 Chainloading Other Operating System</span></a></h2><p>UEFI 使得装载其它操作系统变得简单，因为可以在 EFI 分区中安装多个 boot loader。通过 chainloading，可以使 GRUB 装载并运行一个指定磁盘分区上的另一个 boot loader。</p><h2 id="_5-8-boot-loader-details" tabindex="-1"><a class="header-anchor" href="#_5-8-boot-loader-details"><span>5.8 Boot Loader Details</span></a></h2><p>两种主要的启动模式：</p><ul><li>MBR</li><li>UEFI</li></ul><h3 id="_5-8-1-mbr-boot" tabindex="-1"><a class="header-anchor" href="#_5-8-1-mbr-boot"><span>5.8.1 MBR Boot</span></a></h3><p>Master Boot Record (MBR) 除了包含分区信息以外，还包括一个 <code>441</code> Bytes 的区域。用于 BIOS 在 <em>Power-On Self-Test (POST)</em> 之后装载并执行。但由于这个区域对于 boot loader 来说太小，需要一个额外的空间 - 即所谓的 <em>multi-stage boot loader</em>。此时，MBR 的初始空间只用于装载 boot loader 的剩余代码，剩余部分的 boot loader 代码通常位于 MBR 和磁盘第一个分区之间。</p><h3 id="_5-8-2-uefi-boot" tabindex="-1"><a class="header-anchor" href="#_5-8-2-uefi-boot"><span>5.8.2 UEFI Boot</span></a></h3><p>PC 制造商和软件公司意识到传统的 BIOS 有诸多局限，因此开发了替代品 - <em>Extensible Firmware Interface (EFI)</em>，目前的标准是 <em>Unified EFI (UEFI)</em>：</p><ul><li>包括一个内置的 shell</li><li>和读取分区表，导航文件系统的能力</li></ul><p>GPT 分区模式是 UEFI 标准的一部分。总是会有一个特殊的文件系统 - <em>EFI System Partition (ESP)</em>。</p><ul><li>包含一个名为 <code>efi</code> 的目录</li><li>每个 boot loader 有其自身的标识和对应的子目录</li><li><code>.efi</code> 的 boot loader 文件分别存放在每个子目录中</li></ul><p>BIOS 和 UEFI 的 boot loader 版本是不同的。</p><h3 id="_5-8-3-how-grub-works" tabindex="-1"><a class="header-anchor" href="#_5-8-3-how-grub-works"><span>5.8.3 How GRUB Works</span></a></h3><ol><li>BIOS/固件初始化硬件，搜索带有 boot code 的存储设备</li><li>BIOS/固件载入并执行 boot code - GRUB begins</li><li>GRUB core 装载</li><li>GRUB core 初始化，现在 GRUB 可以开始访问磁盘和文件系统</li><li>GRUB 识别其 boot 分区，加载配置文件</li><li>GRUB 给用户提供修改配置的机会</li><li>在用户选择或超时后，GRUB 执行当前配置</li><li>GRUB 在 boot 分区中加载其它代码 (modules)</li><li>GRUB 执行 boot 命令，装载并执行内核</li></ol><p>问题：<strong>Where is the GRUB core?</strong> 除了 ESP 以外，BIOS 读取 MBR 的 <code>512</code> 字节，即 GRUB 开始的地方，不包含 GRUB core，但包含 GRUB 的起始位置，和从该位置加载的代码。如果使用 ESP，则固件可以直接寻找到 GRUB core 的文件并执行。</p>`,84)]))}const d=i(o,[["render",s],["__file","Chapter 5 - How the Linux Kernel Boots.html.vue"]]),c=JSON.parse('{"path":"/how-linux-works-notes/Chapter%205%20-%20How%20the%20Linux%20Kernel%20Boots.html","title":"Chapter 5 - How the Linux Kernel Boots","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"5.1 Startup Messages","slug":"_5-1-startup-messages","link":"#_5-1-startup-messages","children":[]},{"level":2,"title":"5.2 Kernel Initialization and Boot Options","slug":"_5-2-kernel-initialization-and-boot-options","link":"#_5-2-kernel-initialization-and-boot-options","children":[]},{"level":2,"title":"5.3 Kernel Parameters","slug":"_5-3-kernel-parameters","link":"#_5-3-kernel-parameters","children":[]},{"level":2,"title":"5.4 Boot Loaders","slug":"_5-4-boot-loaders","link":"#_5-4-boot-loaders","children":[{"level":3,"title":"5.4.1 Boot Loader Tasks","slug":"_5-4-1-boot-loader-tasks","link":"#_5-4-1-boot-loader-tasks","children":[]},{"level":3,"title":"5.4.2 Boot Loader Overview","slug":"_5-4-2-boot-loader-overview","link":"#_5-4-2-boot-loader-overview","children":[]}]},{"level":2,"title":"5.5 GRUB Introduction","slug":"_5-5-grub-introduction","link":"#_5-5-grub-introduction","children":[{"level":3,"title":"5.5.1 Exploring Devices and Partitions with the GRUB Command Line","slug":"_5-5-1-exploring-devices-and-partitions-with-the-grub-command-line","link":"#_5-5-1-exploring-devices-and-partitions-with-the-grub-command-line","children":[]},{"level":3,"title":"5.5.2 GRUB Configuration","slug":"_5-5-2-grub-configuration","link":"#_5-5-2-grub-configuration","children":[]},{"level":3,"title":"5.5.3 GRUB Installation","slug":"_5-5-3-grub-installation","link":"#_5-5-3-grub-installation","children":[]}]},{"level":2,"title":"5.6 UEFI Secure Boot Problems","slug":"_5-6-uefi-secure-boot-problems","link":"#_5-6-uefi-secure-boot-problems","children":[]},{"level":2,"title":"5.7 Chainloading Other Operating System","slug":"_5-7-chainloading-other-operating-system","link":"#_5-7-chainloading-other-operating-system","children":[]},{"level":2,"title":"5.8 Boot Loader Details","slug":"_5-8-boot-loader-details","link":"#_5-8-boot-loader-details","children":[{"level":3,"title":"5.8.1 MBR Boot","slug":"_5-8-1-mbr-boot","link":"#_5-8-1-mbr-boot","children":[]},{"level":3,"title":"5.8.2 UEFI Boot","slug":"_5-8-2-uefi-boot","link":"#_5-8-2-uefi-boot","children":[]},{"level":3,"title":"5.8.3 How GRUB Works","slug":"_5-8-3-how-grub-works","link":"#_5-8-3-how-grub-works","children":[]}]}],"git":{},"filePathRelative":"how-linux-works-notes/Chapter 5 - How the Linux Kernel Boots.md"}');export{d as comp,c as data};
