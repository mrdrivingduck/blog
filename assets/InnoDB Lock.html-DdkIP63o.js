import{_ as n,c as t,a,o}from"./app-7eKjwDat.js";const l={};function d(r,e){return o(),t("div",null,e[0]||(e[0]=[a(`<h1 id="innodb-lock" tabindex="-1"><a class="header-anchor" href="#innodb-lock"><span>InnoDB - Lock</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 10 / 17 20:20</p><p>Nanjing, Jiangsu, China</p><hr><p>锁机制用于管理对共享资源的访问，使用户能够最大程度利用数据库的并发访问，同时又能以一致的方式读取和修改数据。</p><h2 id="lock-in-innodb" tabindex="-1"><a class="header-anchor" href="#lock-in-innodb"><span>Lock in InnoDB</span></a></h2><p>InnoDB 存储引擎会在行级别上对表数据进行加锁。InnoDB 存储引擎实现了两种标准行级锁：</p><ul><li>S Lock (共享锁，读锁) - 允许事务读一行数据</li><li>X Lock (排他锁，写锁) - 允许事务删除或更新一行数据</li></ul><p>行为与常见的读写锁一致：多个事务可以同时获取一行的读锁，但是只有获取一行写锁的事务可以修改该行数据。当事务 1 上的锁与事务 2 上的锁都不改变行数据时，称为 <em>锁兼容</em>；否则称为 <em>锁不兼容</em>。</p><table><thead><tr><th></th><th>S Lock</th><th>X Lock</th></tr></thead><tbody><tr><td>S Lock</td><td>兼容</td><td>不兼容</td></tr><tr><td>X Lock</td><td>不兼容</td><td>不兼容</td></tr></tbody></table><p>InnoDB 还支持多粒度的锁定 - 允许事务在行级别上的锁和表级别上的锁同时存在。<strong>意向锁 (Intention Lock)</strong> 用于将锁定的对象分为多个层次，表示事务希望在更细的粒度上进行加锁：</p><ul><li>IS Lock (意向共享锁)</li><li>IX Lock (意向排他锁)</li></ul><p>如果事务要对某个页上的记录 r 上 X 锁，那么首先需要对数据库、表、页上 IX 锁，最后对记录上 X 锁。若其中任意一次上锁操作导致了等待 (不兼容)，都需要等待粗粒度锁释放后再进一步上锁。规律总结如下：</p><ul><li>意向锁之间兼容</li><li>S Lock 之和 S/IS Lock 兼容</li><li>X Lock 和其它所有锁都不兼容</li></ul><table><thead><tr><th></th><th>IS Lock</th><th>IX Lock</th><th>S Lock</th><th>X Lock</th></tr></thead><tbody><tr><td>IS Lock</td><td>兼容</td><td>兼容</td><td>兼容</td><td>不兼容</td></tr><tr><td>IX Lock</td><td>兼容</td><td>兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td>S Lock</td><td>兼容</td><td>不兼容</td><td>兼容</td><td>不兼容</td></tr><tr><td>X Lock</td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr></tbody></table><p>InnoDB 中，意向锁实际上就是表级别的锁，不会阻塞除全表扫描以外的任何请求。</p><h2 id="consistent-non-locking-read" tabindex="-1"><a class="header-anchor" href="#consistent-non-locking-read"><span>Consistent Non-locking Read</span></a></h2><p><em>一致性非锁定读</em> 指 InnoDB 存储引擎通过管理多个版本的控制来读取数据库中的数据。假设当前读取的行正在进行 <code>UPDATE</code> 或 <code>DELETE</code> 操作，则不会因此去等待行上的 (X) 锁释放，而是直接读取行的 <strong>快照数据</strong>，从而避免了阻塞。快照数据是通过 undo 段实现的，undo 段本用于在事务中回滚数据，因此没有额外开销；另外，读取快照数据也不需要上锁。</p><p>每个行记录的快照可能会有多个版本，这就是所谓的行多版本并发控制 (Multi Version Concurrency Control, MVCC)。在不同的 <strong>事务隔离级别</strong> 下，使用的是不同版本的行快照。</p><ul><li><code>READ COMMITTED</code> 事务隔离级别下，读取行的最新快照数据 (其它事务对行的更改会被当前事务读取到，违反了 ACID 中的隔离性)</li><li><code>REPEATABLE READ</code> 事务隔离级别下，读取事务开始时的快照版本</li></ul><h2 id="consistent-locking-read" tabindex="-1"><a class="header-anchor" href="#consistent-locking-read"><span>Consistent Locking Read</span></a></h2><p>在某些情况下，用户需要 <strong>显式</strong> 对数据库读取操作进行加锁来保证数据一致性。InnoDB 存储引擎对 <code>SELECT</code> 语句支持两种 <em>一致性锁定读</em> 操作：</p><ul><li><code>SELECT ... FOR UPDATE</code> - 对读取的行记录加 X 锁</li><li><code>SELECT ... LOCK IN SHARE MODE</code> - 对读取的行记录加 S 锁</li></ul><p>上述两种语句必须出现在事务中。事务提交后，锁也就被释放了。</p><h2 id="auto-increment" tabindex="-1"><a class="header-anchor" href="#auto-increment"><span>Auto Increment</span></a></h2><p>InnoDB 存储引擎对每一个 <strong>含有自增长值</strong> 的表都带有一个自增长计数器，插入操作会根据计数器的值 + 1 赋予自增长列。该值可能会遭到并发修改，因此存在 AUTO-INC Locking，这是 MySQL 5.1.22 版本之前的实现方式。为了提高插入性能，锁不是在事务完成后才释放，而是完成执行插入自增长列的 SQL 语句后立刻释放该锁。</p><p>MySQL 后续支持了较为轻量级的自增长实现方式，即使用互斥量。但是可能带来的问题是每次插入时自增长的值可能不是连续的。</p><hr><h2 id="lock-algorithm" tabindex="-1"><a class="header-anchor" href="#lock-algorithm"><span>Lock Algorithm</span></a></h2><p>行锁包含了三种算法：</p><ul><li>Record Lock - 单个行记录上锁</li><li>Gap Lock - 锁定一个范围，但不锁定记录本身</li><li>Next-Key Lock - 锁定一个范围，并锁定记录本身</li></ul><p>当查询的索引中包含 <strong>唯一索引</strong> 时，InnoDB 存储引擎会将 Next-key Lock 降级为 Record Lock (因为没必要锁定一个范围)，从而提高系统并发性。这些锁用于解决各种锁问题。</p><h3 id="phantom-problem" tabindex="-1"><a class="header-anchor" href="#phantom-problem"><span>Phantom Problem</span></a></h3><p><em>幻读</em> 问题。在同一事务下，连续执行两次同样的 SQL 语句，得到的记录数不一样 (特指数据新增或删除)。比如在一个事务内执行了两次如下语句：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t <span class="token keyword">WHERE</span> a <span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在该事务执行两次该语句之间，另一个事务插入了一个值为 <code>4</code> 的值，因此第二次执行该语句会得到不一样的结果。幻读违反了事务的隔离性。InnoDB 的 <code>REPEATABLE READ</code> 事务隔离等级下使用 Next-Key Locking 来解决幻读问题，即对 <code>(2, +∞)</code> 的范围加 X 锁，对该范围的任何插入都是不允许的。</p><h3 id="dirty-read" tabindex="-1"><a class="header-anchor" href="#dirty-read"><span>Dirty Read</span></a></h3><p>脏数据指事务对缓冲区中行记录修改但没有被提交的数据。如果一个事务读到了另一个事务中未提交的数据，就是脏读。脏读违反了数据库的隔离性，只有在 <code>READ UNCOMMITTED</code> 事务隔离等级下才可能会发生。</p><p>在修改事务时加 X 锁，当事务提交后再解锁，可以解决脏读问题。</p><h3 id="unrepeatable-read" tabindex="-1"><a class="header-anchor" href="#unrepeatable-read"><span>Unrepeatable Read</span></a></h3><p><em>不可重复读</em> 指在一个事务内多次读取同一数据集合，同时另一事务也访问了同一数据集合并进行了 DML 操作 (并提交) - 第一个事务两次读取到的数据可能不一致 (特指数据更新)。由于不可重复读读到的是已经提交的数据，因此违反的是 ACID 中的一致性要求。</p><p>在 InnoDB 存储引擎中，还是通过 Next-Key Lock 算法来避免不可重复读的问题。在该算法下，对索引的扫描，不仅会锁住扫描到的索引，还会锁住索引的覆盖范围。实现该算法的事务隔离等级为 <code>READ REPEATABLE</code>。</p><h3 id="lost-update" tabindex="-1"><a class="header-anchor" href="#lost-update"><span>Lost Update</span></a></h3><p><em>丢失更改</em> 发生于一个事务的更新被另一个事务的更新覆盖。为了避免这个问题，需要让事务操作 <strong>串行化</strong> - 在用户读取记录时上 X 锁，等事务提交后再释放 X 锁。</p><h2 id="dead-lock" tabindex="-1"><a class="header-anchor" href="#dead-lock"><span>Dead Lock</span></a></h2><p>死锁指的是两个或两个以上的事务在执行过程中，因争夺锁资源而造成的互相等待的现象。若无外力作用，则事务无法推进下去。解决死锁的方式是 <strong>超时</strong> - 当一个事务等待时间超过阈值时，就让其中的一个事务回滚，另一个等待中的事务自然继续进行。但是根据 FIFO 的顺序选择事务进行回滚比较暴力，理论上应该选择 undo 代价较小的事务进行回滚。</p><p>当前数据库普遍使用 <em>wait-for graph</em> 进行死锁检测 - 构造对资源使用的图，如果图中存在回路，那么存在死锁。</p><h2 id="lock-escalation" tabindex="-1"><a class="header-anchor" href="#lock-escalation"><span>Lock Escalation</span></a></h2><p><em>锁升级</em> 指的是当细粒度的锁数量过多，而锁本身是一种稀缺资源，那么可以将大量细粒度的锁升级为少量粗粒度的锁，从而保护了系统资源，防止系统使用过多内存来维护锁。对于 SQL Server 来说，由于锁是稀缺资源，锁升级会带来效率上的提高，但也可能导致并发性能的降低。而对于 InnoDB 存储引擎来说，由于不是根据每个记录产生锁，而是根据每个页对锁进行管理，因此不管事务锁住页中的几条记录，开销都是一致的。</p><hr><h2 id="references" tabindex="-1"><a class="header-anchor" href="#references"><span>References</span></a></h2><p><a href="https://zhuanlan.zhihu.com/p/149228460" target="_blank" rel="noopener noreferrer">知乎专栏 - 把 MySQL 中的各种锁及其原理都画出来</a></p><p><a href="https://blog.csdn.net/jdnicky/article/details/91493719" target="_blank" rel="noopener noreferrer">CSDN - 数据库 不可重复读与幻读的区别</a></p><hr>`,55)]))}const c=n(l,[["render",d],["__file","InnoDB Lock.html.vue"]]),i=JSON.parse('{"path":"/notes/MySQL/InnoDB%20Lock.html","title":"InnoDB - Lock","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Lock in InnoDB","slug":"lock-in-innodb","link":"#lock-in-innodb","children":[]},{"level":2,"title":"Consistent Non-locking Read","slug":"consistent-non-locking-read","link":"#consistent-non-locking-read","children":[]},{"level":2,"title":"Consistent Locking Read","slug":"consistent-locking-read","link":"#consistent-locking-read","children":[]},{"level":2,"title":"Auto Increment","slug":"auto-increment","link":"#auto-increment","children":[]},{"level":2,"title":"Lock Algorithm","slug":"lock-algorithm","link":"#lock-algorithm","children":[{"level":3,"title":"Phantom Problem","slug":"phantom-problem","link":"#phantom-problem","children":[]},{"level":3,"title":"Dirty Read","slug":"dirty-read","link":"#dirty-read","children":[]},{"level":3,"title":"Unrepeatable Read","slug":"unrepeatable-read","link":"#unrepeatable-read","children":[]},{"level":3,"title":"Lost Update","slug":"lost-update","link":"#lost-update","children":[]}]},{"level":2,"title":"Dead Lock","slug":"dead-lock","link":"#dead-lock","children":[]},{"level":2,"title":"Lock Escalation","slug":"lock-escalation","link":"#lock-escalation","children":[]},{"level":2,"title":"References","slug":"references","link":"#references","children":[]}],"git":{},"filePathRelative":"notes/MySQL/InnoDB Lock.md"}');export{c as comp,i as data};
