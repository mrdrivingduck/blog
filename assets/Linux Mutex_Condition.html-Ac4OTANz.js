import{_ as e,c as a,a as t,o as s}from"./app-BeHGwf2X.js";const i={};function l(p,n){return s(),a("div",null,n[0]||(n[0]=[t(`<h1 id="linux-mutex-condition" tabindex="-1"><a class="header-anchor" href="#linux-mutex-condition"><span>Linux - Mutex &amp; Condition</span></a></h1><p>Created by : Mr Dk.</p><p>2021 / 03 / 02 20:25</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="semaphore" tabindex="-1"><a class="header-anchor" href="#semaphore"><span>Semaphore</span></a></h2><p>信号量用于进程 (或线程) 之间的同步：一个线程完成后，通知另一个线程。信号量自身带有 <strong>数值</strong>，数值决定了共享资源的数量。如果共享资源的数量为 1，那么就可以完成资源的互斥访问。</p><ul><li>有名信号量 - 适用于不同进程间</li><li>无名信号量 - 适用于进程内部的线程之间</li></ul><p>具体操作：</p><ul><li>初始化，并指定共享资源数量：<code>int sem_init (sem_t* sem, int pshared, unsigned int value)</code></li><li>信号量 P 操作 <ul><li><code>int sem_wait(sem_t* sem)</code></li><li><code>int sem_trywait(sem_t* sem)</code></li></ul></li><li>信号量 V 操作：<code>int sem_post(sem_t* sem)</code> (唯一一个能在信号处理程序中安全调用的函数)</li><li>取得信号量的值：<code>int sem_getvalue (sem_t* sem)</code></li><li>销毁信号量：<code>int sem_destroy(sem_t* sem)</code></li></ul><h2 id="mutex" tabindex="-1"><a class="header-anchor" href="#mutex"><span>Mutex</span></a></h2><p>线程互斥锁，用于锁住线程间的共享资源。相当于共享资源数量为 1 的信号量。具体操作：</p><ul><li>初始化：<code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restric attr)</code></li><li>销毁：<code>int pthread_mutex_destroy(pthread_mutex_t *mutex)</code></li><li>上锁 <ul><li>阻塞加锁：<code>int pthread_mutex_lock(pthread_mutex_t *mutex)</code></li><li>非阻塞试图加锁：<code>int pthread_mutex_trylock(pthread_mutex_t *mutex)</code></li></ul></li><li>解锁：<code>int pthread_mutex_unlock(pthread_mutex_t *mutex)</code></li></ul><p>由一个线程上锁后，只能由那个线程解锁。</p><h2 id="condition-variable" tabindex="-1"><a class="header-anchor" href="#condition-variable"><span>Condition Variable</span></a></h2><p>条件变量需要与 <em>互斥锁</em> 同时使用。互斥锁用于原子地计算条件。主要的操作是 wait 和 signal。在进行操作前，总是需要先获得互斥锁。</p><ul><li>对于 wait 操作，线程进入等待队列，然后释放锁；被唤醒后返回前，线程重新获得锁并返回</li><li>对于 signal 操作，线程唤醒一个或多个等待线程后，释放锁；所有被唤醒的线程 <strong>重新竞争互斥锁</strong>，竞争成功的那个线程以持有互斥锁的方式从 wait 操作返回</li></ul><p>发出 wait 和 signal 操作的线程不是同一个。具体操作：</p><ul><li>初始化条件变量：<code>int pthread_cond_init(pthread_cond_t *restrict cond, pthread_condattr_t *restrict attr)</code></li><li>销毁条件变量：<code>int pthread_cond_destroy(pthread_cond_t *cond)</code></li><li>等待 <ul><li>阻塞等待：<code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restric mutex)</code></li><li>超时等待：<code>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict timeout)</code></li></ul></li><li>通知 <ul><li>通知一个线程 (按入队顺序)：<code>int pthread_cond_signal(pthread_cond_t *cond)</code></li><li>通知所有线程：<code>int pthread_cond_broadcast(pthread_cond_t *cond)</code></li></ul></li></ul><p>使用方式：在 signal 激活等待线程后，当前线程需要释放互斥锁。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token comment">// thread 1</span></span>
<span class="line"><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span>　　</span>
<span class="line"><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当等待线程被唤醒后，重新对互斥锁进行竞争；竞争成功的线程从 wait 函数返回。从 wait 操作返回后，需要重新对条件进行判断：有可能在这段时间内，条件已经被改变了。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token comment">// thread 2</span></span>
<span class="line"><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">while</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cond<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="references" tabindex="-1"><a class="header-anchor" href="#references"><span>References</span></a></h2><p><a href="https://www.cnblogs.com/li-daphne/p/5558435.html" target="_blank" rel="noopener noreferrer">博客园 - Linux 互斥锁、条件变量和信号量</a></p><p><a href="http://blog.chinaunix.net/uid-20671208-id-4935154.html" target="_blank" rel="noopener noreferrer">ChinaUnix - 信号量、互斥锁、读写锁和条件变量的区别</a></p><hr>`,28)]))}const c=e(i,[["render",l],["__file","Linux Mutex_Condition.html.vue"]]),r=JSON.parse('{"path":"/notes/Operating%20System/Linux%20Mutex_Condition.html","title":"Linux - Mutex & Condition","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Semaphore","slug":"semaphore","link":"#semaphore","children":[]},{"level":2,"title":"Mutex","slug":"mutex","link":"#mutex","children":[]},{"level":2,"title":"Condition Variable","slug":"condition-variable","link":"#condition-variable","children":[]},{"level":2,"title":"References","slug":"references","link":"#references","children":[]}],"git":{},"filePathRelative":"notes/Operating System/Linux Mutex&Condition.md"}');export{c as comp,r as data};
