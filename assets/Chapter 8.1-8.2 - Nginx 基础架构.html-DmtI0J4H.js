import{_ as a,c as s,a as e,o as l}from"./app-BeHGwf2X.js";const i={};function t(p,n){return l(),s("div",null,n[0]||(n[0]=[e(`<h1 id="chapter-8-1-8-2-nginx-基础架构" tabindex="-1"><a class="header-anchor" href="#chapter-8-1-8-2-nginx-基础架构"><span>Chapter 8.1-8.2 - Nginx 基础架构</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 07 / 19 14:09</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="_8-1-web-服务器设计中的关键约束" tabindex="-1"><a class="header-anchor" href="#_8-1-web-服务器设计中的关键约束"><span>8.1 Web 服务器设计中的关键约束</span></a></h2><p>(可能是架构师要考虑的问题...但我好希望有朝一日我也能有机会考虑这些)</p><ul><li>性能 (由于 Nginx 是一个 Web 服务器，因此性能主要从网络角度出发) <ul><li>网络性能 - 不同负载下，Web 服务在网络通信上的吞吐量 (并发数上升)</li><li>单次请求延迟 - 针对用户而言</li><li>网络效率 - 使用长连接减少建立 / 关闭连接带来的开销，使用压缩算法，使用缓存等</li></ul></li><li>可伸缩性 - 降低组件间耦合度、简化组件、服务拆分</li><li>简单性</li><li>可修改性 - 当前架构下对系统做出修改的难易程度</li><li>可见性 - 关键组件运行情况可以被监控</li><li>可移植性 - 跨平台运行</li><li>可靠性 - 架构容易收到系统层面故障影响的程度</li></ul><hr><h2 id="_8-2-nginx-的架构设计" tabindex="-1"><a class="header-anchor" href="#_8-2-nginx-的架构设计"><span>8.2 Nginx 的架构设计</span></a></h2><h3 id="_8-2-1-优秀的模块化设计" tabindex="-1"><a class="header-anchor" href="#_8-2-1-优秀的模块化设计"><span>8.2.1 优秀的模块化设计</span></a></h3><p>Nginx 中除了少量核心代码，其它一切皆模块。这种高度模块化的设计具有以下几个优点：</p><ul><li><p>高度抽象的模块接口 - 所有模块都遵循相同的接口 <code>ngx_module_t</code></p></li><li><p>模块接口简单 - 只涉及模块初始化、退出、配置处理等，且特权级高</p></li><li><p>配置模块 - 使 Nginx 具有高可配置性、高可扩展性、高可定制性、高可伸缩性</p></li><li><p>官方提供六个核心模块 <code>NGX_CORE_MODULE</code>，其它非核心模块只需要关心如何调用核心模块即可</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">ngx_str_t</span> name<span class="token punctuation">;</span> <span class="token comment">// 核心模块名称</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>create_conf<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">ngx_cycle_t</span> <span class="token operator">*</span>cycle<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 解析配置项前由 Nginx 框架调用</span></span>
<span class="line">    <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>init_conf<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">ngx_cycle_t</span> <span class="token operator">*</span>cycle<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>conf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 配置项解析完毕后，通过配置项初始化模块</span></span>
<span class="line"><span class="token punctuation">}</span> <span class="token class-name">ngx_core_module_t</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个核心模块又可以定义各自的新类型：</p><ul><li><code>NGX_EVENT_MODULE</code> - 事件模块类型</li><li><code>NGX_HTTP_MODULE</code> - HTTP 模块类型</li><li><code>NGX_MAIL_MODULE</code> - 邮件模块类型</li></ul></li><li><p>多层次、多类别的模块设计 - Nginx 官方共有五大类型模块：</p><ul><li>核心模块</li><li>配置模块</li><li>事件模块</li><li>HTTP 模块</li><li>MAIL 模块</li></ul><p>后三个模块会再次具体化 <code>ngx_module_t</code> 接口，派生出负责各自功能的模块</p></li></ul><h3 id="_8-2-2-事件驱动架构" tabindex="-1"><a class="header-anchor" href="#_8-2-2-事件驱动架构"><span>8.2.2 事件驱动架构</span></a></h3><p>由事件发生源产生事件，由一个或多个事件收集器来收集、分发事件，事件处理器注册自己感兴趣的事件并消费这些事件。具体到 Nginx 来说，由网卡、磁盘产生事件，由事件模块负责事件的收集、分发，所有的模块都可能是事件消费者。</p><p>对于传统的 Web 服务器，事件驱动局限于 <strong>TCP 连接建立、关闭</strong>，在连接建立后到关闭之前，所有操作都不再是事件驱动。因此，在连接存在期间，每个请求将一直占用系统资源，造成了服务器资源的浪费。传统的 Web 服务器通常把进程或线程作为事件消费者。当一个请求被一个进程处理时，请求将一直占用进程直至结束。这将导致大量的上下文切换开销。</p><p>Nginx 不使用进程或线程作为事件消费者，事件消费者只能是某个模块。Nginx 在收集完事件后，开始使用当前进程分发事件，调用相应的事件消费者模块来处理事件。与前者的区别是，前者每个事件消费者独占一个进程资源，后者事件消费者只是被事件分发者进程 <strong>短期调用</strong>。这种设计使得网络吞吐量得到提升。但是这要要求了事件消费者 <strong>不能有阻塞行为</strong>，否则会长时间占用事件分发者进程导致其它事件得不到响应 - 每个事件消费者不可以让进程转换为 <strong>休眠状态</strong> 或 <strong>阻塞状态</strong>。</p><h3 id="_8-2-3-请求的多阶段异步处理" tabindex="-1"><a class="header-anchor" href="#_8-2-3-请求的多阶段异步处理"><span>8.2.3 请求的多阶段异步处理</span></a></h3><p>把一个请求的处理过程按照事件的触发方式 <strong>划分为多个阶段</strong>，每个阶段都可以由事件分发器触发。每个阶段中的事件消费者不知道本次完整操作什么时候会完成，只能被动等待下一次被调用。这种处理方式极高地提升了网络的性能，使得每一个进程都能全力运转，不会或尽可能少地出现进程休眠的状况。一旦出现进程休眠，为了能够及时处理更多的请求，服务器只能增加进程的数量，进程数量过多就会带来上下文切换的开销，也会使得进程占用的内存得不到及时的释放。</p><p>划分阶段的原则 - 找到请求处理流程中的 <strong>阻塞方法</strong>：</p><ul><li>将阻塞方法改为非阻塞方法，第一阶段执行到非阻塞方法执行完毕为止 (立刻将控制权归还进程)，第二阶段用于处理非阻塞方法的结果</li><li>按时间分解阻塞方法 - 10MB 的文件 I/O，分解为每次 10KB (?)</li><li>使用定时器来实现需要 CPU 空转等待结果的场景 (定期检查是否完成，如果没有完成则立刻归还控制权，并设置下一个定时器事件)</li><li>如果阻塞方法无法划分，则必须使用独立的进程执行阻塞方法 (需要审视这样的事件消费者是否合理)</li></ul><h3 id="_8-2-4-管理进程、多工作进程设计" tabindex="-1"><a class="header-anchor" href="#_8-2-4-管理进程、多工作进程设计"><span>8.2.4 管理进程、多工作进程设计</span></a></h3><p>Nginx 采用一个 master 管理进程，多个 worker 工作进程的设计方式。优点：</p><ol><li>充分利用多核系统的并发处理能力 - Nginx 中所有的 worker 工作进程都是完全平等的</li><li>多个 worker 进程通过进程间通信来实现负载均衡</li><li>当工作进程出现问题时，管理进程可以启动新的工作进程来避免系统性能的下降，并支持服务运行时的程序升级、配置修改</li></ol><h3 id="_8-2-5-平台无关的代码实现" tabindex="-1"><a class="header-anchor" href="#_8-2-5-平台无关的代码实现"><span>8.2.5 平台无关的代码实现</span></a></h3><p>Nginx 尽量减少使用与 OS 相关的代码，核心代码都使用了与 OS 无关的实现。造就了 Nginx 的可移植性。</p><h3 id="_8-2-6-内存池的设计" tabindex="-1"><a class="header-anchor" href="#_8-2-6-内存池的设计"><span>8.2.6 内存池的设计</span></a></h3><p>为了避免出现内存碎片、减少向 OS 申请内存的次数，Nginx 设计了简单的内存池。这样，把多次向 OS 申请内存的操作整合成一次，大大减少了 CPU 消耗与内存碎片。Nginx 为每一个 HTTP 请求申请了独立的内存池，为每一个 TCP 连接也申请了独立的内存池。内存池会随着请求的结束和连接的关闭而被销毁。用户甚至可以不同关心内存的释放问题。减少内存碎片能够提高内存利用率，增强网络性能。</p><h3 id="_8-2-7-使用统一管道过滤器模式的-http-过滤模块" tabindex="-1"><a class="header-anchor" href="#_8-2-7-使用统一管道过滤器模式的-http-过滤模块"><span>8.2.7 使用统一管道过滤器模式的 HTTP 过滤模块</span></a></h3><p>每一个过滤模块都有输入端和输出端，输入端和输出端都具有统一的接口。每个过滤模块都完全独立，处理输入端接收的数据，由输出端传递给下一个过滤模块。HTTP 过滤系统的输入输出被简化为一个个过滤模块的简单组合，并且完全支持并发执行。</p>`,30)]))}const o=a(i,[["render",t],["__file","Chapter 8.1-8.2 - Nginx 基础架构.html.vue"]]),r=JSON.parse('{"path":"/understanding-nginx-notes/Part%203%20-%20%E6%B7%B1%E5%85%A5%20Nginx/Chapter%208.1-8.2%20-%20Nginx%20%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84.html","title":"Chapter 8.1-8.2 - Nginx 基础架构","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"8.1 Web 服务器设计中的关键约束","slug":"_8-1-web-服务器设计中的关键约束","link":"#_8-1-web-服务器设计中的关键约束","children":[]},{"level":2,"title":"8.2 Nginx 的架构设计","slug":"_8-2-nginx-的架构设计","link":"#_8-2-nginx-的架构设计","children":[{"level":3,"title":"8.2.1 优秀的模块化设计","slug":"_8-2-1-优秀的模块化设计","link":"#_8-2-1-优秀的模块化设计","children":[]},{"level":3,"title":"8.2.2 事件驱动架构","slug":"_8-2-2-事件驱动架构","link":"#_8-2-2-事件驱动架构","children":[]},{"level":3,"title":"8.2.3 请求的多阶段异步处理","slug":"_8-2-3-请求的多阶段异步处理","link":"#_8-2-3-请求的多阶段异步处理","children":[]},{"level":3,"title":"8.2.4 管理进程、多工作进程设计","slug":"_8-2-4-管理进程、多工作进程设计","link":"#_8-2-4-管理进程、多工作进程设计","children":[]},{"level":3,"title":"8.2.5 平台无关的代码实现","slug":"_8-2-5-平台无关的代码实现","link":"#_8-2-5-平台无关的代码实现","children":[]},{"level":3,"title":"8.2.6 内存池的设计","slug":"_8-2-6-内存池的设计","link":"#_8-2-6-内存池的设计","children":[]},{"level":3,"title":"8.2.7 使用统一管道过滤器模式的 HTTP 过滤模块","slug":"_8-2-7-使用统一管道过滤器模式的-http-过滤模块","link":"#_8-2-7-使用统一管道过滤器模式的-http-过滤模块","children":[]}]}],"git":{},"filePathRelative":"understanding-nginx-notes/Part 3 - 深入 Nginx/Chapter 8.1-8.2 - Nginx 基础架构.md"}');export{o as comp,r as data};
