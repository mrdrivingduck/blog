import{_ as s,c as a,a as p,o as e}from"./app-BeHGwf2X.js";const t="/blog/assets/2-4-CEw8V0H9.png",l={};function o(c,n){return e(),a("div",null,n[0]||(n[0]=[p(`<h1 id="chapter-2-2-sgi-特殊的空间分配器" tabindex="-1"><a class="header-anchor" href="#chapter-2-2-sgi-特殊的空间分配器"><span>Chapter 2.2 - SGI 特殊的空间分配器</span></a></h1><p>Created by : Mr Dk.</p><p>2021 / 04 / 01 22:10</p><p>Nanjing, Jiangsu, China</p><hr><p>一般而言，在 C++ 中动态分配内存及释放，使用 <code>new</code> 和 <code>delete</code> 操作符。</p><p>其中 <code>new</code> 包含两个阶段的操作：</p><ol><li>调用 <code>operator new</code> 分配内存</li><li>调用构造函数构造对象</li></ol><p><code>delete</code> 也包含两个阶段的操作：</p><ol><li>调用析构函数析构对象</li><li>调用 <code>operator delete</code> 释放内存</li></ol><p>为了减小操作的粒度，寻找机会获得性能上的提升，STL 的空间分配器将这些阶段独立：</p><ul><li>内存分配由 <code>alloc::allocate()</code> 负责</li><li>内存释放由 <code>alloc::deallocate()</code> 负责</li><li>对象构造由 <code>::construct()</code> 负责</li><li>对象析构由 <code>::destroy()</code> 负责</li></ul><h2 id="_2-2-3-构造和析构基本工具-construct-和-destroy" tabindex="-1"><a class="header-anchor" href="#_2-2-3-构造和析构基本工具-construct-和-destroy"><span>2.2.3 构造和析构基本工具：<code>construct()</code> 和 <code>destroy()</code></span></a></h2><p><code>construct()</code> 接受的参数包括一个指针和一个初值，作用是将初值设置到该指针所在的位置上。该指针指向的内存 <strong>已经被分配完毕</strong>，可以属于堆空间，也可以属于栈空间。C++ 的 <strong>placement new</strong> 运算符可以完成这样的任务：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token comment">// operator new</span></span>
<span class="line">Type <span class="token operator">*</span>t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// placement new</span></span>
<span class="line">Type <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">// p = malloc...</span></span>
<span class="line"><span class="token keyword">new</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，<code>construct()</code> 和 <code>destroy()</code> 的工作只关心对象的构造与析构，不关心内存的分配与释放。对于 <code>construct()</code> 来说，在已分配完毕的内存上调用 placement new 即可；对于 <code>destroy()</code> 来说，手动调用对象的析构函数即可。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_T2</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">_Construct</span><span class="token punctuation">(</span>_T1<span class="token operator">*</span> __p<span class="token punctuation">,</span> <span class="token keyword">const</span> _T2<span class="token operator">&amp;</span> __value<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> __p<span class="token punctuation">)</span> <span class="token function">_T1</span><span class="token punctuation">(</span>__value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拷贝构造</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_T1</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">_Construct</span><span class="token punctuation">(</span>_T1<span class="token operator">*</span> __p<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> __p<span class="token punctuation">)</span> <span class="token function">_T1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 默认构造</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Tp</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">_Destroy</span><span class="token punctuation">(</span>_Tp<span class="token operator">*</span> __pointer<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  __pointer<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">_Tp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 析构</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，<code>destroy()</code> 还有接收一对迭代器作为参数的范围版本，用于批量销毁对象。这里引申出是否可以 <strong>高效地</strong> 销毁对象：如果该对象类型的析构函数是 trivial 的 (不涉及对动态分配的内存进行回收)，那么可以什么都不做就结束 (就当这些对象已经被销毁)；如果析构函数是 non-trivial 的，则依次调用每一个对象的析构函数。如何判断数据类型是否具有 trivial 的析构函数呢？通过 STL 的 <code>__type_traits</code> 类型特性萃取机制。</p><p>批量销毁的最外层函数，将对象数据类型通过 <code>iterator_traits</code> 萃取出来：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_ForwardIterator</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">_Destroy</span><span class="token punctuation">(</span>_ForwardIterator __first<span class="token punctuation">,</span> _ForwardIterator __last<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">__destroy</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> __last<span class="token punctuation">,</span> <span class="token function">__VALUE_TYPE</span><span class="token punctuation">(</span>__first<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后进一步萃取对象的数据类型是否有 trivial 的析构函数：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_Tp</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">void</span></span>
<span class="line"><span class="token function">__destroy</span><span class="token punctuation">(</span>_ForwardIterator __first<span class="token punctuation">,</span> _ForwardIterator __last<span class="token punctuation">,</span> _Tp<span class="token operator">*</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">__type_traits</span><span class="token operator">&lt;</span>_Tp<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>has_trivial_destructor</span>
<span class="line">          _Trivial_destructor<span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">__destroy_aux</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> __last<span class="token punctuation">,</span> <span class="token function">_Trivial_destructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，实现有 trivial 和无 trivial 情况下的两种销毁函数：</p><ul><li>无 trivial 的析构函数：依次调用每一个对象的析构函数</li><li>有 trivial 的析构函数：什么也不做</li></ul><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_ForwardIterator</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">void</span></span>
<span class="line"><span class="token function">__destroy_aux</span><span class="token punctuation">(</span>_ForwardIterator __first<span class="token punctuation">,</span> _ForwardIterator __last<span class="token punctuation">,</span> __false_type<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> __first <span class="token operator">!=</span> __last<span class="token punctuation">;</span> <span class="token operator">++</span>__first<span class="token punctuation">)</span></span>
<span class="line">    <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token operator">*</span>__first<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_ForwardIterator</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__destroy_aux</span><span class="token punctuation">(</span>_ForwardIterator<span class="token punctuation">,</span> _ForwardIterator<span class="token punctuation">,</span> __true_type<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-2-4-空间的分配和释放" tabindex="-1"><a class="header-anchor" href="#_2-2-4-空间的分配和释放"><span>2.2.4 空间的分配和释放</span></a></h2><p>SGI 使用 <code>malloc()</code> 和 <code>free()</code> 完成对内存的分配和释放。设计哲学：</p><ul><li>内存不足时的应变措施</li><li>需要分配较多小型内存块时，如何解决内存碎片问题</li></ul><p>SGI 设计了 <strong>双层级分配器</strong>：</p><ul><li>第一级分配器 (<code>__malloc_alloc_template</code>) 直接使用 <code>malloc()</code> 和 <code>free()</code> (128B 以上)</li><li>第二级分配器 (<code>__default_alloc_template</code>) 使用 <strong>内存池</strong> 来管理小块内存</li></ul><h2 id="_2-2-5-第一级分配器-malloc-alloc-template-剖析" tabindex="-1"><a class="header-anchor" href="#_2-2-5-第一级分配器-malloc-alloc-template-剖析"><span>2.2.5 第一级分配器 <code>__malloc_alloc_template</code> 剖析</span></a></h2><p>第一级分配器直接基于 <code>malloc()</code>。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> __inst<span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">__malloc_alloc_template</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义了一下几个函数用于处理 out of memory 的情况：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">_S_oom_malloc</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">_S_oom_realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span> __malloc_alloc_oom_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，用户可以注册一个函数指针 <code>__malloc_alloc_oom_handler</code>，分配器将在内存分配无法满足需求时调用该函数，开发者可以在这个函数中试图腾出一些位置：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token function">__set_malloc_handler</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>__f<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span> __old<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> __malloc_alloc_oom_handler<span class="token punctuation">;</span></span>
<span class="line">    __malloc_alloc_oom_handler <span class="token operator">=</span> __f<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span><span class="token punctuation">(</span>__old<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 <code>malloc()</code> 无法分配指定内存时，分配器将在一个死循环中不断调用用户注册的函数指针，试着腾出一些内存；如果用户没有注册这个函数指针，那么分配器无技可施，只能抛出 <code>bad_alloc()</code> 异常：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> __inst<span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">void</span><span class="token operator">*</span></span>
<span class="line"><span class="token class-name">__malloc_alloc_template</span><span class="token operator">&lt;</span>__inst<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">_S_oom_malloc</span><span class="token punctuation">(</span>size_t __n<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span> __my_malloc_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">void</span><span class="token operator">*</span> __result<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        __my_malloc_handler <span class="token operator">=</span> __malloc_alloc_oom_handler<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> __my_malloc_handler<span class="token punctuation">)</span> <span class="token punctuation">{</span> __THROW_BAD_ALLOC<span class="token punctuation">;</span> <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">(</span><span class="token operator">*</span>__my_malloc_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        __result <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>__result<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">(</span>__result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 <code>realloc()</code> 的处理也完全类似：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> __inst<span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token class-name">__malloc_alloc_template</span><span class="token operator">&lt;</span>__inst<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">_S_oom_realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> __p<span class="token punctuation">,</span> size_t __n<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span> __my_malloc_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">void</span><span class="token operator">*</span> __result<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        __my_malloc_handler <span class="token operator">=</span> __malloc_alloc_oom_handler<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> __my_malloc_handler<span class="token punctuation">)</span> <span class="token punctuation">{</span> __THROW_BAD_ALLOC<span class="token punctuation">;</span> <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">(</span><span class="token operator">*</span>__my_malloc_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        __result <span class="token operator">=</span> <span class="token function">realloc</span><span class="token punctuation">(</span>__p<span class="token punctuation">,</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>__result<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">(</span>__result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一级分配器对 <code>allocate()</code> / <code>deallocate()</code> / <code>reallocate()</code> 三个函数的实现就很直截了当：直接调用 <code>malloc()</code> / <code>free()</code> / <code>realloc()</code>，并在内存分配失败时调用上述的处理方法：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">allocate</span><span class="token punctuation">(</span>size_t __n<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">void</span><span class="token operator">*</span> __result <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> __result<span class="token punctuation">)</span> __result <span class="token operator">=</span> <span class="token function">_S_oom_malloc</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span> __result<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">deallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> __p<span class="token punctuation">,</span> size_t <span class="token comment">/* __n */</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">free</span><span class="token punctuation">(</span>__p<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">reallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> __p<span class="token punctuation">,</span> size_t <span class="token comment">/* old_sz */</span><span class="token punctuation">,</span> size_t __new_sz<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">void</span><span class="token operator">*</span> __result <span class="token operator">=</span> <span class="token function">realloc</span><span class="token punctuation">(</span>__p<span class="token punctuation">,</span> __new_sz<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> __result<span class="token punctuation">)</span> __result <span class="token operator">=</span> <span class="token function">_S_oom_realloc</span><span class="token punctuation">(</span>__p<span class="token punctuation">,</span> __new_sz<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span> __result<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-2-6-第二级分配器-default-alloc-template-剖析" tabindex="-1"><a class="header-anchor" href="#_2-2-6-第二级分配器-default-alloc-template-剖析"><span>2.2.6 第二级分配器 <code>__default_alloc_template</code> 剖析</span></a></h2><p>第二级分配器负责避免太多小块内存造成的碎片，同时，还要是管理内存的额外开销尽可能小。如果要分配的内存高于 128B，那么直接交给第一级分配器处理；当要分配的内存小于 128B 时，则使用 <strong>memory pool</strong> 管理：每次分配一大块内存，并将这块内存切分为小块，用一个空闲链表 (free list) 串起来。下次接收到小块内存的分配需求，则直接从 free list 中取出。</p><p>SGI 第二级分配器会将任何小额内存需求对齐 8 字节 (上调至 8 字节的倍数)，从而维护了 16 个 free-lists (8 / 16 / 24 / 32 / 40 / 48 / 56 / 64 / 72 / 80 / 88 / 96 / 104 / 112 / 120 / 128)。这 16 个链表指针的初始值都为 0：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">enum</span> <span class="token punctuation">{</span>_ALIGN <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">enum</span> <span class="token punctuation">{</span>_MAX_BYTES <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">enum</span> <span class="token punctuation">{</span>_NFREELISTS <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// _MAX_BYTES/_ALIGN</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">static</span> _Obj<span class="token operator">*</span> __STL_VOLATILE _S_free_list<span class="token punctuation">[</span>_NFREELISTS<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了维护链表，需要额外的指针开销吗？答案是不需要：当小块内存不被使用时，其内存块中的前几个 (8 个？) 字节被用于链表指针；当小块内存被使用时，其整块内存都归用户使用。小块内存结点定义如下：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">union</span> _Obj <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">union</span> _Obj<span class="token operator">*</span> _M_free_list_link<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">char</span> _M_client_data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/* The client sees this.        */</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>已被分配的内存块与未被分配的内存块在 free-list 链表中的示意如图：</p><img src="`+t+`" alt="2-4" style="zoom:50%;"><p>给定一个内存需求，分配器首先需要根据内存大小将其上扩到对齐 8 字节，然后在 16 个 free-list 中选择合适的链表：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">static</span> size_t</span>
<span class="line"><span class="token function">_S_round_up</span><span class="token punctuation">(</span>size_t __bytes<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__bytes<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span> _ALIGN<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span> _ALIGN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">static</span>  size_t <span class="token function">_S_freelist_index</span><span class="token punctuation">(</span>size_t __bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__bytes<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>_ALIGN<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>_ALIGN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-2-7-空间分配函数-allocate" tabindex="-1"><a class="header-anchor" href="#_2-2-7-空间分配函数-allocate"><span>2.2.7 空间分配函数 <code>allocate()</code></span></a></h2><p>首先判断内存分配大小是否超过 128B，如果超过就使用第一级分配器。如果是小块内存需求，那么将区块上调到对齐 8 字节后，查找对应的 free-list。如果有可用的内存块，则从链表头摘下第一个空闲内存块来并返回；如果没有可用内存块了，那么调用 <code>refill()</code> 为链表重新填充空间。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token comment">/* __n must be &gt; 0      */</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">allocate</span><span class="token punctuation">(</span>size_t __n<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">void</span><span class="token operator">*</span> __ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>__n <span class="token operator">&gt;</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span> _MAX_BYTES<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment">// &gt; 128 bytes</span></span>
<span class="line">        __ret <span class="token operator">=</span> malloc_alloc<span class="token double-colon punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第一级分配器</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        _Obj<span class="token operator">*</span> __STL_VOLATILE<span class="token operator">*</span> __my_free_list</span>
<span class="line">            <span class="token operator">=</span> _S_free_list <span class="token operator">+</span> <span class="token function">_S_freelist_index</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 找到合适的 free-list</span></span>
<span class="line">        <span class="token comment">// Acquire the lock here with a constructor call.</span></span>
<span class="line">        <span class="token comment">// This ensures that it is released in exit or during stack</span></span>
<span class="line">        <span class="token comment">// unwinding.</span></span>
<span class="line">        <span class="token macro property"><span class="token directive-hash">#</span>     <span class="token directive keyword">ifndef</span> <span class="token expression">_NOTHREADS</span></span></span>
<span class="line">        <span class="token comment">/*REFERENCED*/</span></span>
<span class="line">        _Lock __lock_instance<span class="token punctuation">;</span></span>
<span class="line">        <span class="token macro property"><span class="token directive-hash">#</span>     <span class="token directive keyword">endif</span></span></span>
<span class="line">        _Obj<span class="token operator">*</span> __RESTRICT __result <span class="token operator">=</span> <span class="token operator">*</span>__my_free_list<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>__result <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line">            __ret <span class="token operator">=</span> <span class="token function">_S_refill</span><span class="token punctuation">(</span><span class="token function">_S_round_up</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// refill</span></span>
<span class="line">        <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 从 free-list 头部摘下第一个空闲内存块</span></span>
<span class="line">            <span class="token operator">*</span>__my_free_list <span class="token operator">=</span> __result <span class="token operator">-&gt;</span> _M_free_list_link<span class="token punctuation">;</span></span>
<span class="line">            __ret <span class="token operator">=</span> __result<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">return</span> __ret<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-2-8-空间释放函数-deallocate" tabindex="-1"><a class="header-anchor" href="#_2-2-8-空间释放函数-deallocate"><span>2.2.8 空间释放函数 <code>deallocate()</code></span></a></h2><p>首先判断待回收内存块的大小。如果大于 128B，就调用第一级分配器回收；否则找到合适的 free-list 并将内存块插回链表的头部。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token comment">/* __p may not be 0 */</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">deallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> __p<span class="token punctuation">,</span> size_t __n<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>__n <span class="token operator">&gt;</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span> _MAX_BYTES<span class="token punctuation">)</span></span>
<span class="line">        malloc_alloc<span class="token double-colon punctuation">::</span><span class="token function">deallocate</span><span class="token punctuation">(</span>__p<span class="token punctuation">,</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第一级分配器</span></span>
<span class="line">    <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        _Obj<span class="token operator">*</span> __STL_VOLATILE<span class="token operator">*</span>  __my_free_list</span>
<span class="line">            <span class="token operator">=</span> _S_free_list <span class="token operator">+</span> <span class="token function">_S_freelist_index</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 找到合适的 free-list</span></span>
<span class="line">        _Obj<span class="token operator">*</span> __q <span class="token operator">=</span> <span class="token punctuation">(</span>_Obj<span class="token operator">*</span><span class="token punctuation">)</span>__p<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// acquire lock</span></span>
<span class="line">        <span class="token macro property"><span class="token directive-hash">#</span>       <span class="token directive keyword">ifndef</span> <span class="token expression">_NOTHREADS</span></span></span>
<span class="line">        <span class="token comment">/*REFERENCED*/</span></span>
<span class="line">        _Lock __lock_instance<span class="token punctuation">;</span></span>
<span class="line">        <span class="token macro property"><span class="token directive-hash">#</span>       <span class="token directive keyword">endif</span> <span class="token comment">/* _NOTHREADS */</span></span></span>
<span class="line">        __q <span class="token operator">-&gt;</span> _M_free_list_link <span class="token operator">=</span> <span class="token operator">*</span>__my_free_list<span class="token punctuation">;</span> <span class="token comment">// 将内存块插入链表</span></span>
<span class="line">        <span class="token operator">*</span>__my_free_list <span class="token operator">=</span> __q<span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// lock is released here</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-2-9-重新填充-free-lists" tabindex="-1"><a class="header-anchor" href="#_2-2-9-重新填充-free-lists"><span>2.2.9 重新填充 Free Lists</span></a></h2><p>当调用 <code>allocate()</code> 而相应 free-list 中没有可用内存块时，则调用 <code>refill()</code> 来为 free-list 填充空间。新的空间将取自内存池，默认取得 20 个所需内存块大小的空间，但在内存不足时可能并不能取得这么多的内存块：</p><ul><li>如果只取得了一个内存块，那么直接将这个内存块返回给调用者使用，free-list 没有新内存块</li><li>如果取得了一个以上的内存块，则将除返回给调用者那一块以外的剩余内存块重新组织为链表</li></ul><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token comment">/* Returns an object of size __n, and optionally adds to size __n free list.*/</span></span>
<span class="line"><span class="token comment">/* We assume that __n is properly aligned.                                */</span></span>
<span class="line"><span class="token comment">/* We hold the allocation lock.                                         */</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span> __threads<span class="token punctuation">,</span> <span class="token keyword">int</span> __inst<span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">void</span><span class="token operator">*</span></span>
<span class="line"><span class="token class-name">__default_alloc_template</span><span class="token operator">&lt;</span>__threads<span class="token punctuation">,</span> __inst<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">_S_refill</span><span class="token punctuation">(</span>size_t __n<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">int</span> __nobjs <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// 默认分配 20 个内存块 (n * nobjs bytes)</span></span>
<span class="line">    <span class="token keyword">char</span><span class="token operator">*</span> __chunk <span class="token operator">=</span> <span class="token function">_S_chunk_alloc</span><span class="token punctuation">(</span>__n<span class="token punctuation">,</span> __nobjs<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从内存池分配</span></span>
<span class="line">    _Obj<span class="token operator">*</span> __STL_VOLATILE<span class="token operator">*</span> __my_free_list<span class="token punctuation">;</span></span>
<span class="line">    _Obj<span class="token operator">*</span> __result<span class="token punctuation">;</span></span>
<span class="line">    _Obj<span class="token operator">*</span> __current_obj<span class="token punctuation">;</span></span>
<span class="line">    _Obj<span class="token operator">*</span> __next_obj<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">int</span> __i<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> __nobjs<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">(</span>__chunk<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 只获得一个内存块，直接返回给调用者</span></span>
<span class="line">    __my_free_list <span class="token operator">=</span> _S_free_list <span class="token operator">+</span> <span class="token function">_S_freelist_index</span><span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">/* Build free list in chunk */</span></span>
<span class="line">      __result <span class="token operator">=</span> <span class="token punctuation">(</span>_Obj<span class="token operator">*</span><span class="token punctuation">)</span>__chunk<span class="token punctuation">;</span></span>
<span class="line">      <span class="token operator">*</span>__my_free_list <span class="token operator">=</span> __next_obj <span class="token operator">=</span> <span class="token punctuation">(</span>_Obj<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>__chunk <span class="token operator">+</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 空闲链表指向从内存池分配的起始位置</span></span>
<span class="line">      <span class="token keyword">for</span> <span class="token punctuation">(</span>__i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> __i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 将空闲内存分块并组织为链表</span></span>
<span class="line">        __current_obj <span class="token operator">=</span> __next_obj<span class="token punctuation">;</span></span>
<span class="line">        __next_obj <span class="token operator">=</span> <span class="token punctuation">(</span>_Obj<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>__next_obj <span class="token operator">+</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>__nobjs <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">==</span> __i<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            __current_obj <span class="token operator">-&gt;</span> _M_free_list_link <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">break</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">            __current_obj <span class="token operator">-&gt;</span> _M_free_list_link <span class="token operator">=</span> __next_obj<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">return</span><span class="token punctuation">(</span>__result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-2-10-内存池-memory-pool" tabindex="-1"><a class="header-anchor" href="#_2-2-10-内存池-memory-pool"><span>2.2.10 内存池 Memory Pool</span></a></h2><p>内存池是程序从堆中获取来的大块内存，在第二级分配器的类中由两个指针来指示空闲内存的起止位置：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token comment">// Chunk allocation state.</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">char</span><span class="token operator">*</span> _S_start_free<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">char</span><span class="token operator">*</span> _S_end_free<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> size_t _S_heap_size<span class="token punctuation">;</span> <span class="token comment">// 已从堆上分配的总内存</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过计算 <code>end_free - start_free</code> 表达式，可以判断内存池中的剩余空闲内存。</p><ul><li>如果足够分配 20 个小块内存，则直接把空闲内存拨付出去</li><li>如果不足以分配 20 个小块内存，但至少能够分配 1 块以上，就拨付这些内存出去</li><li>如果内存池连 1 块空闲内存也提供不了，就需要调用 <code>malloc()</code> 从堆上分配内存，分配量为需求量的 2 倍 <ul><li>1 块内存交出</li><li>n - 1 块内存进入 free-list</li><li>n 块内存留在内存池中</li></ul></li></ul><p>如果整个系统堆都不够用了，<code>malloc()</code> 无法分配内存，那么 <code>chunk_alloc()</code> 将会寻找还有未用内存块且内存块足够大的 free-list：</p><ul><li>如果找到，就使用这个内存块</li><li>如果没找到，则调用第一级分配器</li></ul><p>第一级分配器实际上也使用了 <code>malloc()</code>，但有着用户注册的 out-of-memory 处理指针，使得有机会调用用户注册的代码释放出一部分内存以供使用。如果还是不成功，则最终产生 <code>bad_alloc</code> 异常。</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token comment">/* We allocate memory in large chunks in order to avoid fragmenting     */</span></span>
<span class="line"><span class="token comment">/* the malloc heap too much.                                            */</span></span>
<span class="line"><span class="token comment">/* We assume that size is properly aligned.                             */</span></span>
<span class="line"><span class="token comment">/* We hold the allocation lock.                                         */</span></span>
<span class="line"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span> __threads<span class="token punctuation">,</span> <span class="token keyword">int</span> __inst<span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">char</span><span class="token operator">*</span></span>
<span class="line"><span class="token class-name">__default_alloc_template</span><span class="token operator">&lt;</span>__threads<span class="token punctuation">,</span> __inst<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">_S_chunk_alloc</span><span class="token punctuation">(</span>size_t __size<span class="token punctuation">,</span></span>
<span class="line">                                                            <span class="token keyword">int</span><span class="token operator">&amp;</span> __nobjs<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">char</span><span class="token operator">*</span> __result<span class="token punctuation">;</span></span>
<span class="line">    size_t __total_bytes <span class="token operator">=</span> __size <span class="token operator">*</span> __nobjs<span class="token punctuation">;</span></span>
<span class="line">    size_t __bytes_left <span class="token operator">=</span> _S_end_free <span class="token operator">-</span> _S_start_free<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>__bytes_left <span class="token operator">&gt;=</span> __total_bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 内存池剩余空间足够</span></span>
<span class="line">        __result <span class="token operator">=</span> _S_start_free<span class="token punctuation">;</span></span>
<span class="line">        _S_start_free <span class="token operator">+=</span> __total_bytes<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">return</span><span class="token punctuation">(</span>__result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>__bytes_left <span class="token operator">&gt;=</span> __size<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 内存池剩余空间还够 1 个内存块以上</span></span>
<span class="line">        __nobjs <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>__bytes_left<span class="token operator">/</span>__size<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        __total_bytes <span class="token operator">=</span> __size <span class="token operator">*</span> __nobjs<span class="token punctuation">;</span></span>
<span class="line">        __result <span class="token operator">=</span> _S_start_free<span class="token punctuation">;</span></span>
<span class="line">        _S_start_free <span class="token operator">+=</span> __total_bytes<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">return</span><span class="token punctuation">(</span>__result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        size_t __bytes_to_get <span class="token operator">=</span></span>
<span class="line">	  <span class="token number">2</span> <span class="token operator">*</span> __total_bytes <span class="token operator">+</span> <span class="token function">_S_round_up</span><span class="token punctuation">(</span>_S_heap_size <span class="token operator">&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// Try to make use of the left-over piece.</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>__bytes_left <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            _Obj<span class="token operator">*</span> __STL_VOLATILE<span class="token operator">*</span> __my_free_list <span class="token operator">=</span></span>
<span class="line">                        _S_free_list <span class="token operator">+</span> <span class="token function">_S_freelist_index</span><span class="token punctuation">(</span>__bytes_left<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">            <span class="token punctuation">(</span><span class="token punctuation">(</span>_Obj<span class="token operator">*</span><span class="token punctuation">)</span>_S_start_free<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> _M_free_list_link <span class="token operator">=</span> <span class="token operator">*</span>__my_free_list<span class="token punctuation">;</span></span>
<span class="line">            <span class="token operator">*</span>__my_free_list <span class="token operator">=</span> <span class="token punctuation">(</span>_Obj<span class="token operator">*</span><span class="token punctuation">)</span>_S_start_free<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        _S_start_free <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>__bytes_to_get<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 分配更多的内存</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> _S_start_free<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            size_t __i<span class="token punctuation">;</span></span>
<span class="line">            _Obj<span class="token operator">*</span> __STL_VOLATILE<span class="token operator">*</span> __my_free_list<span class="token punctuation">;</span></span>
<span class="line">	    _Obj<span class="token operator">*</span> __p<span class="token punctuation">;</span></span>
<span class="line">            <span class="token comment">// Try to make do with what we have.  That can&#39;t</span></span>
<span class="line">            <span class="token comment">// hurt.  We do not try smaller requests, since that tends</span></span>
<span class="line">            <span class="token comment">// to result in disaster on multi-process machines.</span></span>
<span class="line">            <span class="token keyword">for</span> <span class="token punctuation">(</span>__i <span class="token operator">=</span> __size<span class="token punctuation">;</span></span>
<span class="line">                 __i <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span> _MAX_BYTES<span class="token punctuation">;</span></span>
<span class="line">                 __i <span class="token operator">+=</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span> _ALIGN<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                __my_free_list <span class="token operator">=</span> _S_free_list <span class="token operator">+</span> <span class="token function">_S_freelist_index</span><span class="token punctuation">(</span>__i<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                __p <span class="token operator">=</span> <span class="token operator">*</span>__my_free_list<span class="token punctuation">;</span></span>
<span class="line">                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">!=</span> __p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 从更大的内存块 free-list 中寻找</span></span>
<span class="line">                    <span class="token operator">*</span>__my_free_list <span class="token operator">=</span> __p <span class="token operator">-&gt;</span> _M_free_list_link<span class="token punctuation">;</span></span>
<span class="line">                    _S_start_free <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>__p<span class="token punctuation">;</span></span>
<span class="line">                    _S_end_free <span class="token operator">=</span> _S_start_free <span class="token operator">+</span> __i<span class="token punctuation">;</span></span>
<span class="line">                    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token function">_S_chunk_alloc</span><span class="token punctuation">(</span>__size<span class="token punctuation">,</span> __nobjs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                    <span class="token comment">// Any leftover piece will eventually make it to the</span></span>
<span class="line">                    <span class="token comment">// right free list.</span></span>
<span class="line">                <span class="token punctuation">}</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">	    _S_end_free <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	<span class="token comment">// In case of exception.</span></span>
<span class="line">            _S_start_free <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>malloc_alloc<span class="token double-colon punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span>__bytes_to_get<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token comment">// 使用第一级分配器</span></span>
<span class="line">            <span class="token comment">// This should either throw an</span></span>
<span class="line">            <span class="token comment">// exception or remedy the situation.  Thus we assume it</span></span>
<span class="line">            <span class="token comment">// succeeded.</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token comment">// 内存获取成功，更新内存池指针</span></span>
<span class="line">        _S_heap_size <span class="token operator">+=</span> __bytes_to_get<span class="token punctuation">;</span></span>
<span class="line">        _S_end_free <span class="token operator">=</span> _S_start_free <span class="token operator">+</span> __bytes_to_get<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token function">_S_chunk_alloc</span><span class="token punctuation">(</span>__size<span class="token punctuation">,</span> __nobjs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,72)]))}const u=s(l,[["render",o],["__file","Chapter 2.2 - SGI 特殊的空间分配器.html.vue"]]),r=JSON.parse('{"path":"/the-annotated-stl-sources-notes/Chapter%202%20-%20%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8%20allocator/Chapter%202.2%20-%20SGI%20%E7%89%B9%E6%AE%8A%E7%9A%84%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8.html","title":"Chapter 2.2 - SGI 特殊的空间分配器","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"2.2.3 构造和析构基本工具：construct() 和 destroy()","slug":"_2-2-3-构造和析构基本工具-construct-和-destroy","link":"#_2-2-3-构造和析构基本工具-construct-和-destroy","children":[]},{"level":2,"title":"2.2.4 空间的分配和释放","slug":"_2-2-4-空间的分配和释放","link":"#_2-2-4-空间的分配和释放","children":[]},{"level":2,"title":"2.2.5 第一级分配器 __malloc_alloc_template 剖析","slug":"_2-2-5-第一级分配器-malloc-alloc-template-剖析","link":"#_2-2-5-第一级分配器-malloc-alloc-template-剖析","children":[]},{"level":2,"title":"2.2.6 第二级分配器 __default_alloc_template 剖析","slug":"_2-2-6-第二级分配器-default-alloc-template-剖析","link":"#_2-2-6-第二级分配器-default-alloc-template-剖析","children":[]},{"level":2,"title":"2.2.7 空间分配函数 allocate()","slug":"_2-2-7-空间分配函数-allocate","link":"#_2-2-7-空间分配函数-allocate","children":[]},{"level":2,"title":"2.2.8 空间释放函数 deallocate()","slug":"_2-2-8-空间释放函数-deallocate","link":"#_2-2-8-空间释放函数-deallocate","children":[]},{"level":2,"title":"2.2.9 重新填充 Free Lists","slug":"_2-2-9-重新填充-free-lists","link":"#_2-2-9-重新填充-free-lists","children":[]},{"level":2,"title":"2.2.10 内存池 Memory Pool","slug":"_2-2-10-内存池-memory-pool","link":"#_2-2-10-内存池-memory-pool","children":[]}],"git":{},"filePathRelative":"the-annotated-stl-sources-notes/Chapter 2 - 空间分配器 allocator/Chapter 2.2 - SGI 特殊的空间分配器.md"}');export{u as comp,r as data};
