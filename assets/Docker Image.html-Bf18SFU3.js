import{_ as s,c as n,a,o as l}from"./app-7eKjwDat.js";const i={};function p(r,e){return l(),n("div",null,e[0]||(e[0]=[a(`<h1 id="docker-image" tabindex="-1"><a class="header-anchor" href="#docker-image"><span>Docker - Image</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 09 / 07 17:02</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="什么是-docker-镜像" tabindex="-1"><a class="header-anchor" href="#什么是-docker-镜像"><span>什么是 Docker 镜像</span></a></h2><p>Docker 容器从镜像中启动。Docker 镜像由多层文件系统叠加而成。最底层是 <strong>bootfs (引导文件系统)</strong> - 当一个容器启动后，bootfs 就会被 unmount，从而留出更多内存供 initrd 磁盘镜像使用。</p><p>在 bootfs 层之上，是 <strong>rootfs (root 文件系统)</strong>，可以是一种或多种操作系统 (如 Ubuntu 或 Debian)。在传统的 Linux 引导过程中，rootfs 会先以只读方式加载，在引导结束并完成完整性检查后，会被切换为读写模式。而 Docker 中的 rootfs 永远是只读状态 - 通过 <em>联合加载技术 (Union Mount)</em>，Docker 还会在 rootfs 上加载更多的只读文件系统，而从容器外面看起来只能看到一个文件系统。</p><p>以上文件系统就是镜像。在容器启动完成后，Docker 会在镜像最顶层加载一个 <strong>读写文件系统</strong>。之后在 Docker 中运行的程序将操作读写层。读写层一开始是空的。当文件系统发生变化时 (比如修改了一个文件)，那么文件将首先从读写层以下的只读层复制到读写层中，并应用修改。该文件的只读版本依然存在，但已经被读写层中的副本遮盖隐藏。这种机制被称为 <em>写时复制 (Copy-on-Write)</em>。Docker 的每一个只读镜像层都是只读的，每当创建新容器时，Docker 会构建出镜像栈，然后在最顶层添加一个读写层。也就是说，读写层只包含当前容器中被修改了的文件。</p><h2 id="相关命令" tabindex="-1"><a class="header-anchor" href="#相关命令"><span>相关命令</span></a></h2><p>列出主机上可用的镜像 (位于 <code>/var/lib/docker</code>)：</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ sudo docker images</span>
<span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span>
<span class="line">ubuntu              20.04               4e2eef94cd6b        2 weeks ago         73.9MB</span>
<span class="line">hello-world         latest              bf756fb1ae65        8 months ago        13.3kB</span>
<span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从 Docker Registry 上拉取镜像。同一个仓库 (如 <code>ubuntu</code>) 可以有多个不同的镜像 (<code>12.04</code> / <code>12.10</code> / <code>precise</code>)。</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ sudo docker pull ubuntu:20.04</span>
<span class="line">20.04: Pulling from library/ubuntu</span>
<span class="line">54ee1f796a1e: Already exists</span>
<span class="line">f7bfea53ad12: Already exists</span>
<span class="line">46d371e02073: Already exists</span>
<span class="line">b66c17bbf772: Already exists</span>
<span class="line">Digest: sha256:31dfb10d52ce76c5ca0aa19d10b3e6424b830729e32a89a7c6eee2cda2be67a5</span>
<span class="line">Status: Downloaded newer image for ubuntu:20.04</span>
<span class="line">docker.io/library/ubuntu:20.04</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了区分同一个仓库中的不同镜像，Docker 提供了 <strong>标签 (tag)</strong> 功能。每个标签对一些特定的镜像层进行标记。通过在仓库名后加一个冒号和标签名来指定仓库中的镜像。另外，一个镜像也可以有多个标签。</p><p>Docker Hub 上有两种类型的仓库：</p><ul><li>用户仓库 - 存放用户创建的镜像，包含用户名和仓库名</li><li>顶层仓库 - 由 Docker 与选定的优质厂商合作，只包含仓库名 (如 <code>ubuntu</code> 仓库)</li></ul><p>当运行 <code>docker run</code> 时，如果本地没有镜像，则 Docker 会先从 Docker Hub 下载镜像。如果镜像的标签没有指定，那么默认下载 <code>latest</code> 标签的镜像。在下载镜像时，可以指定镜像的 tag：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">sudo</span> <span class="token function">docker</span> pull fedora:21</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在 Docker Hub 可以查找公共的镜像，也可以通过命令完成：</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ sudo docker search puppet</span>
<span class="line">NAME                                               DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span>
<span class="line">puppet/puppetserver                                A Docker Image for running Puppet Server. Wi…   93</span>
<span class="line">alekzonder/puppeteer                               GoogleChrome/puppeteer image and screenshots…   75                                      [OK]</span>
<span class="line">buildkite/puppeteer                                A Puppeteer Docker image based on Puppeteer’…   54                                      [OK]</span>
<span class="line">puppet/puppetdb                                    A Docker image for running PuppetDB             33</span>
<span class="line">devopsil/puppet                                    Dockerfile for a container with puppet insta…   31                                      [OK]</span>
<span class="line">macadmins/puppetmaster                             Simple puppetmaster based on CentOS 6           26                                      [OK]</span>
<span class="line">puppet/puppetboard                                 The Puppet Board dashboard for PuppetDB         19</span>
<span class="line">puppet/puppet-agent-alpine                         Puppet Agent as a Docker Image. Based on Alp…   17</span>
<span class="line">puppet/puppet-agent                                Puppet Agent as a Docker Image.                 13</span>
<span class="line">puppet/puppetexplorer                              The Puppet Explorer dashboard for PuppetDB      13</span>
<span class="line">puppet/puppet-agent-ubuntu                         Puppet Agent as a Docker Image. Based on the…   13</span>
<span class="line">zenato/puppeteer-renderer                          Puppeteer(Chrome headless node API) based we…   11                                      [OK]</span>
<span class="line">puppet/puppet-dev-tools                            Puppet development tools such as PDK, onceov…   8</span>
<span class="line">camptocamp/puppetserver                            Puppetlabs&#39;s puppetserver                       7                                       [OK]</span>
<span class="line">puppet/continuous-delivery-for-puppet-enterprise   Automated testing and promotion of infrastru…   4</span>
<span class="line">jumanjiman/puppet                                  Use Puppet to configure CoreOS hosts            3</span>
<span class="line">vpgrp/puppet                                       Docker images of Puppet.                        2                                       [OK]</span>
<span class="line">vladgh/puppetserver                                Vlad&#39;s Puppet Server                            2                                       [OK]</span>
<span class="line">vladgh/puppet                                      Ubuntu 16.04 LTS Base image with Puppet         2                                       [OK]</span>
<span class="line">ccaum/puppet-dev                                   Puppet development tools in Docker              1</span>
<span class="line">vladgh/puppetserverdb                              Vlad&#39;s Puppet Server configured for PuppetDB    1                                       [OK]</span>
<span class="line">puppet/puppet-bolt                                 Puppet Bolt as a docker image                   1</span>
<span class="line">terzom/puppetboard                                 Puppetboard is a web interface to PuppetDB p…   0                                       [OK]</span>
<span class="line">ananace/puppetlint                                 Docker images with Puppet-lint and checks fo…   0                                       [OK]</span>
<span class="line">ipcrm/puppet_webapp                                                                                0</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="构建镜像" tabindex="-1"><a class="header-anchor" href="#构建镜像"><span>构建镜像</span></a></h2><p>与 Git 类似，通过 <code>docker commit</code> 就可以构建自己的镜像并发布，但这种方法不被推荐使用。最好是编写 Dokcerfile 文件后使用 <code>docker build</code> 命令。通常来说，一般用户是基于一个已有的基础镜像构建一个新镜像。</p><p>显然，<code>docker commit</code> 会将创建容器的镜像与容器当前状态之间有差异的部分构建为一个新的镜像层，因此更新应当非常轻量。只需要给出容器 ID、远程仓库，以及可选的提交信息和作者信息。</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">sudo</span> <span class="token function">docker</span> commit -m<span class="token string">&quot;...&quot;</span> -a<span class="token string">&quot;...&quot;</span> 4aab3ce3cb76 jamtur01/apache2:webserver</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>但是更为推荐的是使用 Dockerfile + <code>docker build</code> 命令来构建镜像，这样构建出的镜像更具备 <strong>可重复性</strong> 和 <strong>透明性</strong>。Dockerfile 由一系列执行和参数组成，按顺序从上到下依次执行。每条指令被执行后，Docker 都会构建一个新的镜像层并 commit。如果 Dockerfile 执行到某条指令时失败了，那么用户将得到失败前的最后一个正确构建的镜像。在修改 Dockerfile 之后重新执行 <code>docker build</code> 时，Docker 会将已经构建成功的镜像作为缓存，直接从那个缓存层开始继续构建。如果确定不要使用构建缓存，那么可以使用 <code>docker build --no-cache</code>。</p><p>如果想深入探究镜像如何被构建：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">sudo</span> <span class="token function">docker</span> <span class="token function">history</span> 22d47c8cb6e5</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="启动容器" tabindex="-1"><a class="header-anchor" href="#启动容器"><span>启动容器</span></a></h2><p>基于新构建的镜像启动容器时，在 <code>docker run</code> 中附加 <code>-p</code> 标志来控制该容器运行时暴露哪些端口给宿主机：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">sudo</span> <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">80</span> <span class="token parameter variable">--name</span> mycontainer someone/somerepo nginx <span class="token parameter variable">-g</span> <span class="token string">&quot;daemon off;&quot;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这样，就在容器中暴露了 <code>80</code> 端口。容器的暴露端口将会与宿主机上的一个较大的随机端口相映射。通过以下命令可以查看容器的端口映射情况：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">sudo</span> <span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-l</span></span>
<span class="line"><span class="token function">sudo</span> <span class="token function">docker</span> port 6751b94bb5c0 <span class="token number">80</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，也可以在命令行直接指定端口的映射关系，但是需要小心这种做法，因为一个宿主机端口只能被一个容器端口映射。</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">sudo</span> <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8080</span>:80 <span class="token parameter variable">--name</span> mycontainer someone/somerepo nginx <span class="token parameter variable">-g</span> <span class="token string">&quot;daemon off;&quot;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="dockerfile-指令" tabindex="-1"><a class="header-anchor" href="#dockerfile-指令"><span>Dockerfile 指令</span></a></h2><h3 id="from-指令" tabindex="-1"><a class="header-anchor" href="#from-指令"><span>FROM 指令</span></a></h3><p>每个 Dockerfile 的第一条指令必须是 <code>FROM</code>，该指令指定一个已经存在的镜像作为当前容器的基础镜像 (base image)。</p><h3 id="maintainer-指令" tabindex="-1"><a class="header-anchor" href="#maintainer-指令"><span>MAINTAINER 指令</span></a></h3><p><code>MAINTAINER</code> 指令，告诉 Docker 该镜像的作者是谁，邮件是多少。</p><h3 id="run-指令" tabindex="-1"><a class="header-anchor" href="#run-指令"><span>RUN 指令</span></a></h3><p><code>RUN</code> 指令会在当前镜像中运行指定的命令。每条 <code>RUN</code> 指令都会创建一个新的镜像层 - 如果指令执行成功，那么这个新的镜像层将会被 commit。<code>RUN</code> 指令默认由容器中的 <code>/bin/sh -c</code> 运行，但也支持 Linux execve 系统调用形式的 <code>RUN</code> 命令。</p><h3 id="expose-指令" tabindex="-1"><a class="header-anchor" href="#expose-指令"><span>EXPOSE 指令</span></a></h3><p><code>EXPOSE</code> 指令指定了当前容器中将要暴露的端口。Docker 不会自动打开这些端口，而是要在运行 <code>docker run</code> 命令时显式指定。</p><div class="language-docker line-numbers-mode" data-highlighter="prismjs" data-ext="docker" data-title="docker"><pre><code><span class="line"><span class="token instruction"><span class="token keyword">FROM</span> ubuntu:14.04</span></span>
<span class="line"><span class="token instruction"><span class="token keyword">MAINTAINER</span> someone <span class="token string">&quot;someone@some.com&quot;</span></span></span>
<span class="line"><span class="token instruction"><span class="token keyword">RUN</span> apt update &amp;&amp; apt install -y nginx</span></span>
<span class="line"><span class="token instruction"><span class="token keyword">RUN</span> [ <span class="token string">&quot;apt&quot;</span>, <span class="token string">&quot;install&quot;</span>, <span class="token string">&quot;-y&quot;</span>, <span class="token string">&quot;nginx&quot;</span> ]</span></span>
<span class="line"><span class="token instruction"><span class="token keyword">EXPOSE</span> 80</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="cmd-指令" tabindex="-1"><a class="header-anchor" href="#cmd-指令"><span>CMD 指令</span></a></h3><p><code>CMD</code> 指令一个容器启动时要运行的命令，这与 <code>docker run</code> 指定的启动命令非常类似。与 <code>RUN</code> 类似，<code>CMD</code> 也支持类似 execve 风格的调用方式。<code>docker run</code> 命令中的启动命令将会覆盖 Dockerfile 中的 <code>CMD</code> 指令。</p><h3 id="entrypoint-指令" tabindex="-1"><a class="header-anchor" href="#entrypoint-指令"><span>ENTRYPOINT 指令</span></a></h3><p>与 <code>CMD</code> 指令类似，但是处理 <code>docker run</code> 的命令行覆盖问题。在 <code>docker run</code> 命令行中指定的任何参数都会被当作参数传递给 <code>ENTRYPOINT</code> 指令中指定的命令。</p><h3 id="workdir-指令" tabindex="-1"><a class="header-anchor" href="#workdir-指令"><span>WORKDIR 指令</span></a></h3><p>从镜像创建新容器时，在容器内部设置一个工作目录，用于指令 <code>ENTRYPOINT</code> 或 <code>CMD</code> 指令。</p><h3 id="env-指令" tabindex="-1"><a class="header-anchor" href="#env-指令"><span>ENV 指令</span></a></h3><p>在镜像构建过程中设置环境变量，且环境变量可以在后续的任何 <code>RUN</code> 指令或其它指令中使用。另外，还可以通过 <code>docker run</code> 命令的 <code>-e</code> 标志传递环境变量 - 这些变量将只会在运行时有效。</p><h3 id="user-指令" tabindex="-1"><a class="header-anchor" href="#user-指令"><span>USER 指令</span></a></h3><p>指定镜像以什么用户去运行。</p><h3 id="volume-指令" tabindex="-1"><a class="header-anchor" href="#volume-指令"><span>VOLUME 指令</span></a></h3><p>用于向基于镜像创建的容器添加 <strong>卷</strong>。卷可以是存在于一个或多个容器内的特定目录，该目录绕过联合文件系统，使用户能够将数据、数据库或其它内容添加到镜像中，而不用产生镜像层，并且允许多个容器间共享这些内容。</p><h3 id="add-指令" tabindex="-1"><a class="header-anchor" href="#add-指令"><span>ADD 指令</span></a></h3><p>将构建环境下的文件和目录复制到镜像中 - 因此需要 <strong>源文件位置</strong> 和 <strong>目的文件位置</strong> 两个参数。当源文件是一个归档文件时，Docker 还会自动将归档解开。</p><h3 id="copy-指令" tabindex="-1"><a class="header-anchor" href="#copy-指令"><span>COPY 指令</span></a></h3><p>与 <code>ADD</code> 指令非常类似，但不同的是 <code>COPY</code> 只关心复制文件，而不关心提取和解压。</p><h3 id="label-指令" tabindex="-1"><a class="header-anchor" href="#label-指令"><span>LABEL 指令</span></a></h3><p>用于为 Docker 镜像添加元数据。</p><h3 id="stopsignal-指令" tabindex="-1"><a class="header-anchor" href="#stopsignal-指令"><span>STOPSIGNAL 指令</span></a></h3><p>设置停止容器时向容器发送的系统调用信号。</p><h3 id="arg-指令" tabindex="-1"><a class="header-anchor" href="#arg-指令"><span>ARG 指令</span></a></h3><p>定义可以在 <code>docker build</code> 命令运行时传递的变量：</p><div class="language-docker line-numbers-mode" data-highlighter="prismjs" data-ext="docker" data-title="docker"><pre><code><span class="line"><span class="token instruction"><span class="token keyword">ARG</span> build</span></span>
<span class="line"><span class="token instruction"><span class="token keyword">ARG</span> webapp_user=user</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">sudo</span> <span class="token function">docker</span> build --build-arg <span class="token assign-left variable">build</span><span class="token operator">=</span><span class="token number">1234</span> <span class="token parameter variable">-t</span> someone/somerepo <span class="token builtin class-name">.</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>另外，Docker 还预定义了一组 <code>ARG</code> 变量，可以在构建时直接使用。</p><h3 id="onbuild-指令" tabindex="-1"><a class="header-anchor" href="#onbuild-指令"><span>ONBUILD 指令</span></a></h3><p>为镜像添加触发器。当这个镜像被其它镜像用作基础镜像时，触发器将会被执行。也就是说，在基础镜像 A 中设置了 <code>ONBUILD</code> 指令后，在 B 镜像使用 A 镜像作为基础镜像时，在 B 镜像 Dockerfile 的 <code>FROM</code> 指令执行后，将会触发 A 中设置的指令。</p><p><code>ONBUILD</code> 触发器会按照在父镜像中指定的顺序执行，且只能被继承一次 (在孙子镜像中不会被执行)。</p><h2 id="将镜像推送到-docker-hub" tabindex="-1"><a class="header-anchor" href="#将镜像推送到-docker-hub"><span>将镜像推送到 Docker Hub</span></a></h2><p>与 Git 类似，在镜像被构建完毕后，通过 <code>docker push</code> 可以将镜像保存到仓库中。</p><p>可以将包含 Dockerfile 的目录推送到 Docker Hub 上，并触发自动构建，自动产生一个新镜像。</p><h2 id="删除镜像" tabindex="-1"><a class="header-anchor" href="#删除镜像"><span>删除镜像</span></a></h2><p>如果不再需要一个镜像了，就可以使用 <code>docker rmi</code> 命令删除镜像。</p><hr>`,79)]))}const d=s(i,[["render",p],["__file","Docker Image.html.vue"]]),o=JSON.parse('{"path":"/notes/Docker/Docker%20Image.html","title":"Docker - Image","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"什么是 Docker 镜像","slug":"什么是-docker-镜像","link":"#什么是-docker-镜像","children":[]},{"level":2,"title":"相关命令","slug":"相关命令","link":"#相关命令","children":[]},{"level":2,"title":"构建镜像","slug":"构建镜像","link":"#构建镜像","children":[]},{"level":2,"title":"启动容器","slug":"启动容器","link":"#启动容器","children":[]},{"level":2,"title":"Dockerfile 指令","slug":"dockerfile-指令","link":"#dockerfile-指令","children":[{"level":3,"title":"FROM 指令","slug":"from-指令","link":"#from-指令","children":[]},{"level":3,"title":"MAINTAINER 指令","slug":"maintainer-指令","link":"#maintainer-指令","children":[]},{"level":3,"title":"RUN 指令","slug":"run-指令","link":"#run-指令","children":[]},{"level":3,"title":"EXPOSE 指令","slug":"expose-指令","link":"#expose-指令","children":[]},{"level":3,"title":"CMD 指令","slug":"cmd-指令","link":"#cmd-指令","children":[]},{"level":3,"title":"ENTRYPOINT 指令","slug":"entrypoint-指令","link":"#entrypoint-指令","children":[]},{"level":3,"title":"WORKDIR 指令","slug":"workdir-指令","link":"#workdir-指令","children":[]},{"level":3,"title":"ENV 指令","slug":"env-指令","link":"#env-指令","children":[]},{"level":3,"title":"USER 指令","slug":"user-指令","link":"#user-指令","children":[]},{"level":3,"title":"VOLUME 指令","slug":"volume-指令","link":"#volume-指令","children":[]},{"level":3,"title":"ADD 指令","slug":"add-指令","link":"#add-指令","children":[]},{"level":3,"title":"COPY 指令","slug":"copy-指令","link":"#copy-指令","children":[]},{"level":3,"title":"LABEL 指令","slug":"label-指令","link":"#label-指令","children":[]},{"level":3,"title":"STOPSIGNAL 指令","slug":"stopsignal-指令","link":"#stopsignal-指令","children":[]},{"level":3,"title":"ARG 指令","slug":"arg-指令","link":"#arg-指令","children":[]},{"level":3,"title":"ONBUILD 指令","slug":"onbuild-指令","link":"#onbuild-指令","children":[]}]},{"level":2,"title":"将镜像推送到 Docker Hub","slug":"将镜像推送到-docker-hub","link":"#将镜像推送到-docker-hub","children":[]},{"level":2,"title":"删除镜像","slug":"删除镜像","link":"#删除镜像","children":[]}],"git":{},"filePathRelative":"notes/Docker/Docker Image.md"}');export{d as comp,o as data};
