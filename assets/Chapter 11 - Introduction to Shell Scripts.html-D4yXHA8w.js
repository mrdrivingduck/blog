import{_ as e,c as a,a as n,o as l}from"./app-BeHGwf2X.js";const i={};function t(c,s){return l(),a("div",null,s[0]||(s[0]=[n(`<h1 id="chapter-11-introduction-to-shell-scripts" tabindex="-1"><a class="header-anchor" href="#chapter-11-introduction-to-shell-scripts"><span>Chapter 11 - Introduction to Shell Scripts</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 07 / 10 17:03</p><p>@NUAA, Nanjing, Jiangsu, China</p><hr><p>Shell script 是位于文件中的一系列命令。shell 从文件中读取命令并执行，就好像在 terminal 中输入一样。</p><h2 id="_11-1-shell-script-basics" tabindex="-1"><a class="header-anchor" href="#_11-1-shell-script-basics"><span>11.1 Shell Script Basics</span></a></h2><p>Shell 脚本的通常格式：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token shebang important">#!/bin/sh</span></span>
<span class="line"><span class="token comment">#</span></span>
<span class="line"><span class="token comment"># Print</span></span>
<span class="line"></span>
<span class="line"><span class="token builtin class-name">echo</span> a b c</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>#</code> 表示注释，shell 将会忽略以 <code>#</code> 开头的行。在创建脚本后，需要对脚本设置权限：</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ chmod +rx &lt;script_name&gt;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_11-1-1-limitations-of-shell-scripts" tabindex="-1"><a class="header-anchor" href="#_11-1-1-limitations-of-shell-scripts"><span>11.1.1 Limitations of Shell Scripts</span></a></h3><p>Shell 脚本适合文件批处理的工作。对于字符串操作、运算操作，使用 Python 等编程语言会更好。</p><h2 id="_11-2-quoting-and-literals" tabindex="-1"><a class="header-anchor" href="#_11-2-quoting-and-literals"><span>11.2 Quoting and Literals</span></a></h2><p>Shell 会将 <code>$</code> 字符识别为 shell 变量。为了输出 <code>$</code> 字符，需要将 <code>$</code> 用 <code>&#39;&#39;</code> 括起来。</p><h3 id="_11-2-1-literals" tabindex="-1"><a class="header-anchor" href="#_11-2-1-literals"><span>11.2.1 Literals</span></a></h3><p>Literal 是一个字符串，用于将一个想要传入指定命令的字符串 <strong>完整</strong> 地传进去。比如，想将 <code>$100</code> 传入 <code>echo</code> 命令中，Shell 处理命令的过程：</p><ol><li>在执行命令之前，shell 会寻找命令中的变量等，并进行替换</li><li>shell 将替换后的结果传递给对应命令</li></ol><p>Literal 实际上跳过了第一步。</p><h3 id="_11-2-2-single-quotes" tabindex="-1"><a class="header-anchor" href="#_11-2-2-single-quotes"><span>11.2.2 Single Quotes</span></a></h3><p>单引号中的所有字符 (包括空格) 被视为一个参数，保证了 shell 不会对单引号中的内容做任何替换。</p><h3 id="_11-2-3-double-quotes" tabindex="-1"><a class="header-anchor" href="#_11-2-3-double-quotes"><span>11.2.3 Double Quotes</span></a></h3><p>双引号的功能与单引号大致相同，但除了 shell 会将所有的变量名 <code>$</code> 替换为对应变量值。</p><h3 id="_11-2-4-passing-a-literal-single-quote" tabindex="-1"><a class="header-anchor" href="#_11-2-4-passing-a-literal-single-quote"><span>11.2.4 Passing a Literal Single Quote</span></a></h3><p>如果想要将单引号作为字符输出，或作为命令参数的一部分，需要使用 <code>\\</code> 作为转义。简单粗暴的方法：</p><ol><li>将参数中所有的 <code>&#39;</code> 替换为 <code>&#39;\\&#39;&#39;</code></li><li>将整个参数字符串用 <code>&#39;&#39;</code> 包围</li></ol><h2 id="_11-3-special-variables" tabindex="-1"><a class="header-anchor" href="#_11-3-special-variables"><span>11.3 Special Variables</span></a></h2><h3 id="_11-3-1-individual-arguments-1-2" tabindex="-1"><a class="header-anchor" href="#_11-3-1-individual-arguments-1-2"><span>11.3.1 Individual Arguments: $1, $2, ...</span></a></h3><p>所有非零正整数的变量分别对应 shell 脚本的输入参数。Shell 内置的 <code>shift</code> 命令将会移除 <code>$1</code>，其余参数依次前移</p><h3 id="_11-3-2-number-of-arguments" tabindex="-1"><a class="header-anchor" href="#_11-3-2-number-of-arguments"><span>11.3.2 Number of Arguments: $#</span></a></h3><p>表示传入脚本的输出参数个数。</p><h3 id="_11-3-3-all-arguments" tabindex="-1"><a class="header-anchor" href="#_11-3-3-all-arguments"><span>11.3.3 All Arguments: $@</span></a></h3><p>该参数代表脚本的所有参数。</p><h3 id="_11-3-4-script-name-0" tabindex="-1"><a class="header-anchor" href="#_11-3-4-script-name-0"><span>11.3.4 Script Name: $0</span></a></h3><p>该参数代表脚本的名称。</p><h3 id="_11-3-5-process-id" tabindex="-1"><a class="header-anchor" href="#_11-3-5-process-id"><span>11.3.5 Process ID: $$</span></a></h3><p>该参数代表了 shell 的进程 ID。</p><h3 id="_11-3-6-exit-code" tabindex="-1"><a class="header-anchor" href="#_11-3-6-exit-code"><span>11.3.6 Exit Code: $?</span></a></h3><p>该参数代表了上一条命令的 exit code。</p><h2 id="_11-4-exit-codes" tabindex="-1"><a class="header-anchor" href="#_11-4-exit-codes"><span>11.4 Exit Codes</span></a></h2><p>Unix 程序终结时，会向启动该程序的父进程返回 exit code。一般来说：</p><ul><li><code>0</code> 代表了程序结束时没有出现任何问题</li><li><code>1</code> 代表了程序异常退出</li></ul><p>但也有一些程序例外，比如 <code>diff</code> 和 <code>grep</code></p><ul><li><code>1</code> 可能代表该程序找到了符合条件的信息</li><li><code>2</code> 才代表程序异常</li></ul><p>需要看一下程序的说明文档。</p><h2 id="_11-5-conditionals" tabindex="-1"><a class="header-anchor" href="#_11-5-conditionals"><span>11.5 Conditionals</span></a></h2><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token shebang important">#!/bin/sh</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$1</span> <span class="token operator">=</span> hi <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span></span>
<span class="line">    <span class="token comment"># ...</span></span>
<span class="line"><span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token punctuation">..</span>. <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span></span>
<span class="line">    <span class="token comment"># ...</span></span>
<span class="line"><span class="token keyword">else</span></span>
<span class="line">    <span class="token comment"># ...</span></span>
<span class="line"><span class="token keyword">fi</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>[</code> 字符其实对应一个 Unix 程序 <code>test</code>：</p><ul><li>当该程序的 exit code 为 0 时，该条件判断为真</li><li>由于 <code>[</code> 对应一个命令，因此同一行的 <code>then</code> 关键字之前必须加 <code>;</code>，否则就需要另起一行</li><li>条件分支在 <code>fi</code> 终止</li><li><code>elif</code> 可以少用，因为可以用 <code>case</code> 替代</li></ul><h3 id="_11-5-1-getting-around-empty-parameter-lists" tabindex="-1"><a class="header-anchor" href="#_11-5-1-getting-around-empty-parameter-lists"><span>11.5.1 Getting Around Empty Parameter Lists</span></a></h3><p>一个很常见的错误：<code>$1</code> 为空。避免错误的方法：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">&quot;<span class="token variable">$1</span>&quot;</span> <span class="token operator">=</span> hi <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">[</span> x<span class="token string">&quot;<span class="token variable">$1</span>&quot;</span> <span class="token operator">=</span> x<span class="token string">&quot;hi&quot;</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_11-5-4-and-logical-constructs" tabindex="-1"><a class="header-anchor" href="#_11-5-4-and-logical-constructs"><span>11.5.4 &amp;&amp; and || Logical Constructs</span></a></h3><p>通常用在 <code>if</code> 条件分支中。</p><p>对于 <code>&amp;&amp;</code> ：</p><ul><li>如果第一条命令失败，那么 <code>if</code> 使用第一条命令的 exit code</li><li>否则使用第二条命令的 exit code</li></ul><p>对于 <code>||</code> ：</p><ul><li>如果第一条命令失败，那么 <code>if</code> 使用第二条命令的 exit code</li><li>否则使用第一条命令的 exit code</li></ul><h3 id="_11-5-5-testing-conditions" tabindex="-1"><a class="header-anchor" href="#_11-5-5-testing-conditions"><span>11.5.5 Testing Conditions</span></a></h3><p>test 分三种类型：</p><h4 id="file-tests" tabindex="-1"><a class="header-anchor" href="#file-tests"><span>File Tests</span></a></h4><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token punctuation">[</span> <span class="token parameter variable">-f</span> <span class="token function">file</span> <span class="token punctuation">]</span></span>
<span class="line"><span class="token punctuation">[</span> file1 <span class="token parameter variable">-nt</span> file2 <span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>-e</code>：如果文件存在返回 true</li><li><code>-s</code>：如果文件非空返回 true</li><li>...</li></ul><h4 id="string-tests" tabindex="-1"><a class="header-anchor" href="#string-tests"><span>String Tests</span></a></h4><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token punctuation">[</span> <span class="token parameter variable">-z</span> <span class="token string">&quot;&quot;</span> <span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>-z</code>：如果字符串为空返回 true</li><li><code>-n</code>：如果字符串非空返回 true</li></ul><h4 id="arithmetic-tests" tabindex="-1"><a class="header-anchor" href="#arithmetic-tests"><span>Arithmetic Tests</span></a></h4><p>使用 <code>=</code> 是字符串比较，而不是数学比较。需要使用选项参数来进行数学比较：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token punctuation">[</span> <span class="token number">1</span> <span class="token parameter variable">-eq</span> <span class="token number">1</span> <span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_11-5-6-matching-strings-with-case" tabindex="-1"><a class="header-anchor" href="#_11-5-6-matching-strings-with-case"><span>11.5.6 Matching Strings with case</span></a></h3><p><code>case</code> 经常用于字符串比较。不包含任何 <code>test</code> 命令，也不评估任何 exit code。</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token shebang important">#!/bin/sh</span></span>
<span class="line"><span class="token keyword">case</span> <span class="token variable">$1</span> <span class="token keyword">in</span></span>
<span class="line">    bye<span class="token punctuation">)</span></span>
<span class="line">        <span class="token comment"># ...</span></span>
<span class="line">        <span class="token punctuation">;</span><span class="token punctuation">;</span></span>
<span class="line">    hi<span class="token operator">|</span>hello<span class="token punctuation">)</span></span>
<span class="line">        <span class="token comment"># ...</span></span>
<span class="line">        <span class="token punctuation">;</span><span class="token punctuation">;</span></span>
<span class="line">    what*<span class="token punctuation">)</span></span>
<span class="line">        <span class="token comment"># ...</span></span>
<span class="line">        <span class="token punctuation">;</span><span class="token punctuation">;</span></span>
<span class="line">    *<span class="token punctuation">)</span></span>
<span class="line">        <span class="token comment"># ...</span></span>
<span class="line">        <span class="token punctuation">;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">esac</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>将 <code>$1</code> 与 <code>)</code> 之前的值进行比较</li><li>如果匹配，则执行对应的脚本，直到 <code>;;</code>，并跳转到 <code>esac</code></li><li><code>case</code> 结束于 <code>esac</code></li><li>同时匹配多个字符串：使用 <code>|</code>，或 <code>*</code> 和 <code>?</code></li><li>用 <code>*</code> 来包含所有的默认情况，相当于 C 语言中 switch 中的 <code>default</code></li></ul><h2 id="_11-6-loops" tabindex="-1"><a class="header-anchor" href="#_11-6-loops"><span>11.6 Loops</span></a></h2><h3 id="_11-6-1-for-loops" tabindex="-1"><a class="header-anchor" href="#_11-6-1-for-loops"><span>11.6.1 for Loops</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token shebang important">#!/bin/sh</span></span>
<span class="line"><span class="token keyword">for</span> <span class="token for-or-select variable">str</span> <span class="token keyword">in</span> one two three four<span class="token punctuation">;</span> <span class="token keyword">do</span></span>
<span class="line">    <span class="token builtin class-name">echo</span> <span class="token variable">$str</span></span>
<span class="line"><span class="token keyword">done</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_11-6-2-while-loops" tabindex="-1"><a class="header-anchor" href="#_11-6-2-while-loops"><span>11.6.2 while Loops</span></a></h3><p>其中可以使用 <code>break</code> 跳出。</p><hr><h2 id="_11-7-command-substitution" tabindex="-1"><a class="header-anchor" href="#_11-7-command-substitution"><span>11.7 Command Substitution</span></a></h2><p>在 shell 中，可以将一条命令的输出作为另一条命令的某一参数。可以将某一条命令的输出存储在 shell 变量中，使用 <code>$()</code>：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">FLAGS <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">grep</span> <span class="token punctuation">..</span>.<span class="token variable">)</span></span></span>
<span class="line"><span class="token comment"># $FLAGS ...</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>传统的命令替换方法：使用 \` 字符包围命令。</p><hr><h2 id="_11-8-temporary-file-management" tabindex="-1"><a class="header-anchor" href="#_11-8-temporary-file-management"><span>11.8 Temporary File Management</span></a></h2><p>在运行脚本时，需要暂时创建文件存放中间结果，并在脚本结束后删除：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token shebang important">#!/bin/sh</span></span>
<span class="line"><span class="token assign-left variable">TMPFILE</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>mktemp /tmp/im1.XXXXXX<span class="token variable">)</span></span></span>
<span class="line"><span class="token comment"># ...</span></span>
<span class="line"><span class="token function">rm</span> <span class="token parameter variable">-f</span> <span class="token variable">$TMPFILE</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>mktemp</code> 的参数是一个模板，<code>XXXXXX</code> 会被转换为一个唯一的字符集，并作为文件名。如果脚本中途执行停止，那么临时文件将会被留下。可以使用 <code>trap</code> 命令捕捉中断信号，并删除临时文件：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token shebang important">#!/bin/sh</span></span>
<span class="line"><span class="token builtin class-name">trap</span> <span class="token string">&quot;rm -f <span class="token variable">$TMPFILE</span>; exit 1&quot;</span> INT</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在 <code>trap</code> 中一定要使用 <code>exit</code> 人为停止程序运行</li><li>否则在中断处理之后，shell 将会被继续执行</li></ul><h2 id="_11-10-important-shell-script-utilities" tabindex="-1"><a class="header-anchor" href="#_11-10-important-shell-script-utilities"><span>11.10 Important Shell Script Utilities</span></a></h2><h3 id="_11-10-1-basename" tabindex="-1"><a class="header-anchor" href="#_11-10-1-basename"><span>11.10.1 basename</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">basename</span> example.html .html</span>
<span class="line"><span class="token function">basename</span> /usr/local/bin/example</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>为文件名脱去后缀，和目录名脱去前缀。</p><h3 id="_11-10-2-awk" tabindex="-1"><a class="header-anchor" href="#_11-10-2-awk"><span>11.10.2 awk</span></a></h3><p>类似一门编程语言。现在 Python 盛行，这玩意儿已经没人用了。</p><h3 id="_11-10-3-sed" tabindex="-1"><a class="header-anchor" href="#_11-10-3-sed"><span>11.10.3 sed</span></a></h3><p>文本编辑：</p><ul><li>将一个输入流（文件或标准输入）作为输入</li><li>根据表达式做对应操作</li><li>将结果输出到 stdout</li></ul><p>替换、增加、删除指定的字符串，还可以指定特定行。</p><h3 id="_11-10-4-xargs" tabindex="-1"><a class="header-anchor" href="#_11-10-4-xargs"><span>11.10.4 xargs</span></a></h3><p>开启大量进程同时运行。</p><h3 id="_11-10-5-expr" tabindex="-1"><a class="header-anchor" href="#_11-10-5-expr"><span>11.10.5 expr</span></a></h3><p>在 shell 中进行数学运算：</p><div class="language-console line-numbers-mode" data-highlighter="prismjs" data-ext="console" data-title="console"><pre><code><span class="line">$ expr 1 + 2</span>
<span class="line">3</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果有大量数学运算，就不要用 shell 了，直接用编程语言。</p><h3 id="_11-10-6-exec" tabindex="-1"><a class="header-anchor" href="#_11-10-6-exec"><span>11.10.6 exec</span></a></h3><p>与 <code>exec()</code> 系统调用差不多。使用了之后，shell 进程将被对应进程替换</p><ul><li>所有变量丢失</li><li>结束进程后，shell 也被关闭了</li></ul><h2 id="_11-11-subshells" tabindex="-1"><a class="header-anchor" href="#_11-11-subshells"><span>11.11 Subshells</span></a></h2><p>如果想在 shell 中执行一些一次性环境变量的脚本，可以在 shell 中再启动子 shell，并设置其环境变量。也是用 <code>$()</code> 实现：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">$ <span class="token punctuation">(</span><span class="token environment constant">PATH</span><span class="token operator">=</span>/usr/confusing:<span class="token environment constant">$PATH</span><span class="token punctuation">;</span> uglyprogram<span class="token punctuation">)</span></span>
<span class="line">$ <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/usr/confusing:<span class="token environment constant">$PATH</span><span class="token punctuation">;</span> uglyprogram</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>下一种已经成为 shell 的内置语法了。当子 shell 结束时，子 shell 中的环境变量将不会影响到父 shell 的环境变量。</p><h2 id="_11-12-including-other-files-in-scripts" tabindex="-1"><a class="header-anchor" href="#_11-12-including-other-files-in-scripts"><span>11.12 Including Other Files in Scripts</span></a></h2><p>使用 <code>.</code> 来执行其它 shell：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token builtin class-name">.</span> config.sh</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这种语法不会开启一个子 shell</p><h2 id="_11-13-reading-user-input" tabindex="-1"><a class="header-anchor" href="#_11-13-reading-user-input"><span>11.13 Reading User Input</span></a></h2><p>从标准输入中读取一行，并存储在 shell 变量中：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token builtin class-name">read</span> var</span>
<span class="line"><span class="token comment"># $var ...</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,120)]))}const o=e(i,[["render",t],["__file","Chapter 11 - Introduction to Shell Scripts.html.vue"]]),r=JSON.parse('{"path":"/how-linux-works-notes/Chapter%2011%20-%20Introduction%20to%20Shell%20Scripts.html","title":"Chapter 11 - Introduction to Shell Scripts","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"11.1 Shell Script Basics","slug":"_11-1-shell-script-basics","link":"#_11-1-shell-script-basics","children":[{"level":3,"title":"11.1.1 Limitations of Shell Scripts","slug":"_11-1-1-limitations-of-shell-scripts","link":"#_11-1-1-limitations-of-shell-scripts","children":[]}]},{"level":2,"title":"11.2 Quoting and Literals","slug":"_11-2-quoting-and-literals","link":"#_11-2-quoting-and-literals","children":[{"level":3,"title":"11.2.1 Literals","slug":"_11-2-1-literals","link":"#_11-2-1-literals","children":[]},{"level":3,"title":"11.2.2 Single Quotes","slug":"_11-2-2-single-quotes","link":"#_11-2-2-single-quotes","children":[]},{"level":3,"title":"11.2.3 Double Quotes","slug":"_11-2-3-double-quotes","link":"#_11-2-3-double-quotes","children":[]},{"level":3,"title":"11.2.4 Passing a Literal Single Quote","slug":"_11-2-4-passing-a-literal-single-quote","link":"#_11-2-4-passing-a-literal-single-quote","children":[]}]},{"level":2,"title":"11.3 Special Variables","slug":"_11-3-special-variables","link":"#_11-3-special-variables","children":[{"level":3,"title":"11.3.1 Individual Arguments: $1, $2, ...","slug":"_11-3-1-individual-arguments-1-2","link":"#_11-3-1-individual-arguments-1-2","children":[]},{"level":3,"title":"11.3.2 Number of Arguments: $#","slug":"_11-3-2-number-of-arguments","link":"#_11-3-2-number-of-arguments","children":[]},{"level":3,"title":"11.3.3 All Arguments: $@","slug":"_11-3-3-all-arguments","link":"#_11-3-3-all-arguments","children":[]},{"level":3,"title":"11.3.4 Script Name: $0","slug":"_11-3-4-script-name-0","link":"#_11-3-4-script-name-0","children":[]},{"level":3,"title":"11.3.5 Process ID: $$","slug":"_11-3-5-process-id","link":"#_11-3-5-process-id","children":[]},{"level":3,"title":"11.3.6 Exit Code: $?","slug":"_11-3-6-exit-code","link":"#_11-3-6-exit-code","children":[]}]},{"level":2,"title":"11.4 Exit Codes","slug":"_11-4-exit-codes","link":"#_11-4-exit-codes","children":[]},{"level":2,"title":"11.5 Conditionals","slug":"_11-5-conditionals","link":"#_11-5-conditionals","children":[{"level":3,"title":"11.5.1 Getting Around Empty Parameter Lists","slug":"_11-5-1-getting-around-empty-parameter-lists","link":"#_11-5-1-getting-around-empty-parameter-lists","children":[]},{"level":3,"title":"11.5.4 && and || Logical Constructs","slug":"_11-5-4-and-logical-constructs","link":"#_11-5-4-and-logical-constructs","children":[]},{"level":3,"title":"11.5.5 Testing Conditions","slug":"_11-5-5-testing-conditions","link":"#_11-5-5-testing-conditions","children":[]},{"level":3,"title":"11.5.6 Matching Strings with case","slug":"_11-5-6-matching-strings-with-case","link":"#_11-5-6-matching-strings-with-case","children":[]}]},{"level":2,"title":"11.6 Loops","slug":"_11-6-loops","link":"#_11-6-loops","children":[{"level":3,"title":"11.6.1 for Loops","slug":"_11-6-1-for-loops","link":"#_11-6-1-for-loops","children":[]},{"level":3,"title":"11.6.2 while Loops","slug":"_11-6-2-while-loops","link":"#_11-6-2-while-loops","children":[]}]},{"level":2,"title":"11.7 Command Substitution","slug":"_11-7-command-substitution","link":"#_11-7-command-substitution","children":[]},{"level":2,"title":"11.8 Temporary File Management","slug":"_11-8-temporary-file-management","link":"#_11-8-temporary-file-management","children":[]},{"level":2,"title":"11.10 Important Shell Script Utilities","slug":"_11-10-important-shell-script-utilities","link":"#_11-10-important-shell-script-utilities","children":[{"level":3,"title":"11.10.1 basename","slug":"_11-10-1-basename","link":"#_11-10-1-basename","children":[]},{"level":3,"title":"11.10.2 awk","slug":"_11-10-2-awk","link":"#_11-10-2-awk","children":[]},{"level":3,"title":"11.10.3 sed","slug":"_11-10-3-sed","link":"#_11-10-3-sed","children":[]},{"level":3,"title":"11.10.4 xargs","slug":"_11-10-4-xargs","link":"#_11-10-4-xargs","children":[]},{"level":3,"title":"11.10.5 expr","slug":"_11-10-5-expr","link":"#_11-10-5-expr","children":[]},{"level":3,"title":"11.10.6 exec","slug":"_11-10-6-exec","link":"#_11-10-6-exec","children":[]}]},{"level":2,"title":"11.11 Subshells","slug":"_11-11-subshells","link":"#_11-11-subshells","children":[]},{"level":2,"title":"11.12 Including Other Files in Scripts","slug":"_11-12-including-other-files-in-scripts","link":"#_11-12-including-other-files-in-scripts","children":[]},{"level":2,"title":"11.13 Reading User Input","slug":"_11-13-reading-user-input","link":"#_11-13-reading-user-input","children":[]}],"git":{},"filePathRelative":"how-linux-works-notes/Chapter 11 - Introduction to Shell Scripts.md"}');export{o as comp,r as data};
