import{_ as a,c as n,a as l,o as s}from"./app-7eKjwDat.js";const i={};function t(c,e){return s(),n("div",null,e[0]||(e[0]=[l(`<h1 id="chapter-5-系统调用" tabindex="-1"><a class="header-anchor" href="#chapter-5-系统调用"><span>Chapter 5 - 系统调用</span></a></h1><p>Created by : Mr Dk.</p><p>2019 / 10 / 18 08:56</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="_5-1-与内核通信" tabindex="-1"><a class="header-anchor" href="#_5-1-与内核通信"><span>5.1 与内核通信</span></a></h2><p>在 <strong>用户空间进程</strong> 和 <strong>硬件设备</strong> 之间添加了一个中间层，为用户空间提供了硬件的抽象接口，保证了系统的稳定性和安全。是用户空间访问内核的唯一合法入口。</p><h2 id="_5-2-api、posix-和-c-库" tabindex="-1"><a class="header-anchor" href="#_5-2-api、posix-和-c-库"><span>5.2 API、POSIX 和 C 库</span></a></h2><p>应用程序通过在用户空间实现的 <strong>API</strong> 而不是直接通过系统调用来编程：</p><ul><li>API 实际上并不需要和内核提供的系统调用对应</li><li>API 可以在各种 OS 上实现，给应用程序提供完全相同的接口</li></ul><p>在 Unix 世界中，最流行的 API 是基于 POSIX 标准的，Linux 尽力与 POSIX 和 SUSv3 兼容。Linux 的系统调用像大多数 Unix 系统一样，作为 C 库的一部分提供。</p><ul><li><strong>Mechanism, not policy. (提供机制而不是策略)</strong> 是 Unix 文化贯穿的一条设计主线</li><li><strong>What capabilities are to be provided (the mechanism)</strong></li><li><strong>How those capabilities can be used (the policy)</strong></li></ul><p>Unix 的系统调用仅抽象用于完成某种确定目的的函数，函数怎么用完全不需要内核关心。</p><h2 id="_5-3-系统调用" tabindex="-1"><a class="header-anchor" href="#_5-3-系统调用"><span>5.3 系统调用</span></a></h2><p>访问系统调用，通常使用 C 库中定义的函数来进行。</p><ul><li>可能需要 0/1/2 甚至几个参数</li><li>可能产生一些副作用 (使系统的状态发生改变)</li><li>通过一个 <code>long</code> 类型的返回值来表示成功或者错误</li></ul><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token function">SYSCALL_DEFINE0</span><span class="token punctuation">(</span>getpid<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token function">task_tgid_vnr</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>SYSCALL_DEFINE0</code> 是一个宏，定义了无参数的系统调用。宏展开后：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line">asmlinkage <span class="token keyword">long</span> <span class="token function">sys_getpid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>asmlinkage</code> 是一个编译执行，通知编译器仅从栈中提取函数参数</li><li><code>sys_xxx()</code> 是 Linux 中所有系统调用都应该遵守的命名规则</li></ul><h3 id="_5-3-1-系统调用号" tabindex="-1"><a class="header-anchor" href="#_5-3-1-系统调用号"><span>5.3.1 系统调用号</span></a></h3><p>Linux 中每个系统调用都被赋予了一个系统调用号。系统调用号很重要，一旦分配就不能再有变更，不然编译好的程序就会崩溃。系统调用被删除后，调用号也不能被回收，不然编译好的程序可能会调用另一个系统调用。Linux 中有一个 <code>sys_ni_syscall()</code>，除了返回 <code>-ENOSYS</code> 不做任何其它工作。当系统调用被删除，这个函数负责填补空缺。内核在 <code>sys_call_table</code> 中记录了所有已注册的系统调用。</p><h3 id="_5-3-2-系统调用的性能" tabindex="-1"><a class="header-anchor" href="#_5-3-2-系统调用的性能"><span>5.3.2 系统调用的性能</span></a></h3><p>Linux 系统调用比许多其它 OS 执行得快，较短的上下文切换时间是一个重要原因：进出内核都被优化得简洁高效。</p><h2 id="_5-4-系统调用处理程序" tabindex="-1"><a class="header-anchor" href="#_5-4-系统调用处理程序"><span>5.4 系统调用处理程序</span></a></h2><p>用户空间程序无法直接执行内核代码</p><ul><li>不能直接调用内核空间中的函数</li><li>内核驻留在受保护的地址空间上</li><li>如果进程可以直接读写内核，系统的安全性将不复存在</li></ul><p>应用程序应该以某种方式通知系统，促使系统切换到内核态去执行异常处理程序。通知内核是靠软中断实现的：</p><ul><li>引发一个异常，促使 CPU 进入内核态</li><li>此时异常处理程序实际上就是系统调用处理程序</li></ul><p>x86 系统上系统调用的中断号为 128，通过 <code>INT $0x80</code> 触发中断，导致系统切换到内核态，并执行第 128 号异常处理程序。处理程序名为 <code>system_call()</code>，与硬件体系结构紧密相关。最近，x86 处理器增加了一条 <code>sysenter</code> 指令，提供更快、更专业的陷入内核执行系统调用的方式。</p><h3 id="_5-4-1-指定恰当的系统调用" tabindex="-1"><a class="header-anchor" href="#_5-4-1-指定恰当的系统调用"><span>5.4.1 指定恰当的系统调用</span></a></h3><p>仅陷入内核空间是不够的，需要把系统调用号一并传给内核。在 x86 中，通过 <code>eax</code> 进行传递：在陷入内核空间前，用户空间把相应系统调用的调用号放入 <code>eax</code> 中。<code>system_call()</code> 函数通过将给定的调用号与 <code>NR_syscalls</code> 作比较，检查有效性。由于系统调用表中的表项以 8B 存放，因此：</p><div class="language-assembly line-numbers-mode" data-highlighter="prismjs" data-ext="assembly" data-title="assembly"><pre><code><span class="line">call *sys_call_table(, %rax, 8)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_5-4-2-参数传递" tabindex="-1"><a class="header-anchor" href="#_5-4-2-参数传递"><span>5.4.2 参数传递</span></a></h3><p>在 x86-32 系统上，ebx、ecx、edx、esi、edi 按顺序存放前五个参数。需要 6 个或以上参数时，应当指定一个寄存器，存放指向所有参数的用户空间地址。给用户空间的返回值也通过寄存器传递（x86 eax）。</p><h2 id="_5-5-系统调用的实现" tabindex="-1"><a class="header-anchor" href="#_5-5-系统调用的实现"><span>5.5 系统调用的实现</span></a></h2><h3 id="_5-5-1-实现系统调用" tabindex="-1"><a class="header-anchor" href="#_5-5-1-实现系统调用"><span>5.5.1 实现系统调用</span></a></h3><p>确定每个系统调用的用途。Linux 不提倡多用途的系统调用——<code>ioctl()</code>。很多系统调用提供了 <strong>标志参数</strong> 以确保向前兼容，目的并不是让单个系统调用有多个不同行为，而是为了增加新的功能和选项。设计接口尽量多为将来做考虑。</p><h3 id="_5-5-2-参数验证" tabindex="-1"><a class="header-anchor" href="#_5-5-2-参数验证"><span>5.5.2 参数验证</span></a></h3><p>系统调用必须仔细检查它们所有的参数是否合法有效。内核需要保证用户空间提供的指针：</p><ul><li>指向的内存区域属于用户空间</li><li>指向的内存区域在进程的地址空间内</li><li>不能绕过内存访问限制</li></ul><p>使用 <code>copy_from_user()</code> 和 <code>copy_to_user()</code> 来进行数据传递</p><h2 id="_5-6-系统调用上下文" tabindex="-1"><a class="header-anchor" href="#_5-6-系统调用上下文"><span>5.6 系统调用上下文</span></a></h2><p>内核在执行系统调用的时候处于 <strong>进程上下文</strong>：</p><ul><li>内核可以休眠</li><li>内核可以被抢占</li></ul><p>需要保证系统调用是可重入的。系统调用返回时，控制权仍在 <code>system_call()</code>，由该函数负责切换到用户空间。</p><h3 id="_5-6-1-绑定一个系统调用的最后步骤" tabindex="-1"><a class="header-anchor" href="#_5-6-1-绑定一个系统调用的最后步骤"><span>5.6.1 绑定一个系统调用的最后步骤</span></a></h3><ol><li>在系统调用表的最后加入一项</li><li>对于所支持的各种体系结构，将系统调用号进行定义</li><li>系统调用被实现，并被编译进内核映像 (不能被编译为模块)</li></ol><h3 id="_5-6-2-从用户空间访问系统调用" tabindex="-1"><a class="header-anchor" href="#_5-6-2-从用户空间访问系统调用"><span>5.6.2 从用户空间访问系统调用</span></a></h3><p>Linux 提供了一组宏，用于直接对系统调用访问——<code>_syscalln()</code> - n 从 0 到 6。对于每个宏，都有 2 + 2 × n 个参数：</p><ul><li>系统调用的返回值类型</li><li>系统调用名称</li><li>n 个参数的类型和名称</li></ul><p>宏会被展开为内嵌汇编的 C 函数。</p><h3 id="_5-6-3-为什么不通过系统调用的方式实现" tabindex="-1"><a class="header-anchor" href="#_5-6-3-为什么不通过系统调用的方式实现"><span>5.6.3 为什么不通过系统调用的方式实现</span></a></h3><p>建立新的系统调用非常容易，但绝不提倡这么做。</p>`,54)]))}const d=a(i,[["render",t],["__file","Chapter 5 - 系统调用.html.vue"]]),r=JSON.parse('{"path":"/linux-kernel-development-notes/Chapter%205%20-%20%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.html","title":"Chapter 5 - 系统调用","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"5.1 与内核通信","slug":"_5-1-与内核通信","link":"#_5-1-与内核通信","children":[]},{"level":2,"title":"5.2 API、POSIX 和 C 库","slug":"_5-2-api、posix-和-c-库","link":"#_5-2-api、posix-和-c-库","children":[]},{"level":2,"title":"5.3 系统调用","slug":"_5-3-系统调用","link":"#_5-3-系统调用","children":[{"level":3,"title":"5.3.1 系统调用号","slug":"_5-3-1-系统调用号","link":"#_5-3-1-系统调用号","children":[]},{"level":3,"title":"5.3.2 系统调用的性能","slug":"_5-3-2-系统调用的性能","link":"#_5-3-2-系统调用的性能","children":[]}]},{"level":2,"title":"5.4 系统调用处理程序","slug":"_5-4-系统调用处理程序","link":"#_5-4-系统调用处理程序","children":[{"level":3,"title":"5.4.1 指定恰当的系统调用","slug":"_5-4-1-指定恰当的系统调用","link":"#_5-4-1-指定恰当的系统调用","children":[]},{"level":3,"title":"5.4.2 参数传递","slug":"_5-4-2-参数传递","link":"#_5-4-2-参数传递","children":[]}]},{"level":2,"title":"5.5 系统调用的实现","slug":"_5-5-系统调用的实现","link":"#_5-5-系统调用的实现","children":[{"level":3,"title":"5.5.1 实现系统调用","slug":"_5-5-1-实现系统调用","link":"#_5-5-1-实现系统调用","children":[]},{"level":3,"title":"5.5.2 参数验证","slug":"_5-5-2-参数验证","link":"#_5-5-2-参数验证","children":[]}]},{"level":2,"title":"5.6 系统调用上下文","slug":"_5-6-系统调用上下文","link":"#_5-6-系统调用上下文","children":[{"level":3,"title":"5.6.1 绑定一个系统调用的最后步骤","slug":"_5-6-1-绑定一个系统调用的最后步骤","link":"#_5-6-1-绑定一个系统调用的最后步骤","children":[]},{"level":3,"title":"5.6.2 从用户空间访问系统调用","slug":"_5-6-2-从用户空间访问系统调用","link":"#_5-6-2-从用户空间访问系统调用","children":[]},{"level":3,"title":"5.6.3 为什么不通过系统调用的方式实现","slug":"_5-6-3-为什么不通过系统调用的方式实现","link":"#_5-6-3-为什么不通过系统调用的方式实现","children":[]}]}],"git":{},"filePathRelative":"linux-kernel-development-notes/Chapter 5 - 系统调用.md"}');export{d as comp,r as data};
