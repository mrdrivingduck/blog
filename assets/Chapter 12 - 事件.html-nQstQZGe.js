import{_ as l,c as i,a as t,o as a}from"./app-BeHGwf2X.js";const r={};function n(s,e){return a(),i("div",null,e[0]||(e[0]=[t('<h1 id="chapter-12-事件" tabindex="-1"><a class="header-anchor" href="#chapter-12-事件"><span>Chapter 12 - 事件</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 06 / 05 16:17</p><p>Nanjing, Jiangsu, China</p><hr><p>Redis 服务器是事件驱动的，主要处理两类事件：</p><ul><li>文件事件 (file event) - 服务器对 socket 的抽象</li><li>时间事件 (time event)</li></ul><hr><h2 id="file-event" tabindex="-1"><a class="header-anchor" href="#file-event"><span>File Event</span></a></h2><p>Redis 通过 <strong>I/O 多路复用</strong> 来监听多个 socket，当得到 socket 的命令时，与 socket 关联的 handler 就会被调用。由于 Redis 由单进程的方式被实现，所以 I/O 多路复用程序还是会将所有的 socket 放到一个队列中，然后通过这个队列有序、同步地依次处理事件。每个 handler 中定义了对应事件发生时服务器应该执行的动作：</p><ul><li>accept</li><li>read</li><li>write</li><li>close</li></ul><p>I/O 多路复用程序的底层有：</p><ul><li>select</li><li>epoll</li><li>evport</li><li>kqueue</li></ul><p>Redis 在编译时会自动选择系统中性能最佳的多路复用库。</p><p>Handler 的具体类型：</p><ul><li>连接应答处理器 - 封装了 <code>accept()</code> 函数，对 socket 进行应答</li><li>命令请求处理器 - 封装了 <code>read()</code>，从客户端读入命令请求</li><li>命令回复处理器 - 封装了 <code>write()</code>，将命令回复发送给客户端</li></ul><hr><h2 id="time-event" tabindex="-1"><a class="header-anchor" href="#time-event"><span>Time Event</span></a></h2><p>Redis 将所有的时间事件都放在一个无序链表中。每当时间事件执行器运行时，就遍历整个链表，对每个已超时的事件调用 handler。</p><p>Redis 中的 <code>serverCron()</code> 函数就是时间事件的例子。在这个事件的 handler 中有如下工作：</p><ul><li>更新服务器的统计信息</li><li>清理过期的 key</li><li>关闭和清理连接失效的客户端</li><li>AOF/RDB 持久化</li><li>如果服务器是主服务器，则对从服务器进行定期同步</li><li>如果处于集群模式，则对集群进行定期同步和连接测试</li></ul><p>这个函数默认每秒运行 10 次，也可以通过配置文件进行调整。</p><hr><h2 id="scheduler" tabindex="-1"><a class="header-anchor" href="#scheduler"><span>Scheduler</span></a></h2><p>在 Redis 主进程的主循环中，首先计算最近的时间事件还有多久发生。然后在最近的时间事件发生之前，阻塞等待文件事件 (因为文件事件是随机发生的)，最久阻塞到下一个时间事件发生前。然后先处理文件事件 (本轮循环中可能没有)，再处理时间事件 (本轮循环中也可能没有)；最终重新循环。</p><p>对事件的处理都是同步、有序、原子地进行的，不存在中断与抢占。因此 handler 应当尽可能减少阻塞时间，并在有必要时让出 CPU：</p><ul><li>比如，对 socket 进行 <code>write()</code> 时，写够一定的字节数后，余下的字节下次再写</li><li>将持久化操作放到子线程或子进程中</li></ul><blockquote><p>这里的原则与 Vert.x 类似，不要阻塞 event loop。</p></blockquote>',28)]))}const c=l(r,[["render",n],["__file","Chapter 12 - 事件.html.vue"]]),d=JSON.parse('{"path":"/redis-implementation-notes/Part%202%20-%20%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/Chapter%2012%20-%20%E4%BA%8B%E4%BB%B6.html","title":"Chapter 12 - 事件","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"File Event","slug":"file-event","link":"#file-event","children":[]},{"level":2,"title":"Time Event","slug":"time-event","link":"#time-event","children":[]},{"level":2,"title":"Scheduler","slug":"scheduler","link":"#scheduler","children":[]}],"git":{},"filePathRelative":"redis-implementation-notes/Part 2 - 单机数据库的实现/Chapter 12 - 事件.md"}');export{c as comp,d as data};
