import{_ as n,c as a,a as e,o as p}from"./app-7eKjwDat.js";const t={};function l(o,s){return p(),a("div",null,s[0]||(s[0]=[e(`<h1 id="chapter-3-链表" tabindex="-1"><a class="header-anchor" href="#chapter-3-链表"><span>Chapter 3 - 链表</span></a></h1><p>Created by : Mr Dk.</p><p>2020 / 06 / 01 14:24</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="definition" tabindex="-1"><a class="header-anchor" href="#definition"><span>Definition</span></a></h2><p>链表结点 (<code>adlist.h/listNode</code>)：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span> listNode<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>显然，由 <code>prev</code> 和 <code>next</code> 指针就能把结点串成一个双向链表。另外，有一个链表头结点维护链表的整体信息会更方便 (<code>adlist.h/list</code>)：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">list</span> <span class="token punctuation">{</span></span>
<span class="line">    listNode <span class="token operator">*</span>head<span class="token punctuation">;</span></span>
<span class="line">    listNode <span class="token operator">*</span>tail<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>dup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 结点复制函数</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 结点释放函数</span></span>
<span class="line">    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>match<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 结点值比较函数</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于链表的一些特性总结：</p><ul><li>双向链表</li><li>无环 - 表头结点的 <code>prev</code> 和表尾结点的 <code>next</code> 都指向 NULL</li><li>获取表头结点、表尾结点、链表长度的时间复杂度都是 O(1)</li><li>三个函数指针用于多态 (！这里也用到了)</li></ul>`,12)]))}const c=n(t,[["render",l],["__file","Chapter 3 - 链表.html.vue"]]),r=JSON.parse('{"path":"/redis-implementation-notes/Part%201%20-%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/Chapter%203%20-%20%E9%93%BE%E8%A1%A8.html","title":"Chapter 3 - 链表","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Definition","slug":"definition","link":"#definition","children":[]}],"git":{},"filePathRelative":"redis-implementation-notes/Part 1 - 数据结构与对象/Chapter 3 - 链表.md"}');export{c as comp,r as data};
