import{_ as s,c as a,a as t,o as e}from"./app-BeHGwf2X.js";const p="/blog/assets/disjoint-set-init-pEgyEOSY.png",o="/blog/assets/disjoint-set-connect-BQAatvYS.png",i="/blog/assets/disjoint-set-merge-Oz_7BhNJ.png",c="/blog/assets/disjoint-set-path-compression-2SYWQO6l.png",l="/blog/assets/disjoint-set-rank-DePGEe1q.png",r={};function u(d,n){return e(),a("div",null,n[0]||(n[0]=[t(`<h1 id="algorithm-disjoint-set" tabindex="-1"><a class="header-anchor" href="#algorithm-disjoint-set"><span>Algorithm - Disjoint Set</span></a></h1><p>Created by : Mr Dk.</p><p>2021 / 01 / 11 21:42</p><p>Nanjing, Jiangsu, China</p><hr><h2 id="about" tabindex="-1"><a class="header-anchor" href="#about"><span>About</span></a></h2><p><strong>并查集</strong> 是一种树型的数据结构，用于处理一些不相交集合的合并。一些元素，从一开始各自属于一个集合，随着条件的逐渐给出，集合之间会互相合并，直到最终操作结束，不同元素可能会分属不同的集合。其中主要包括两个主要操作：</p><ul><li>合并 - 把两个不相交的集合合并为一个集合</li><li>查询 - 查询两个元素是否属于一个集合</li></ul><h2 id="theory" tabindex="-1"><a class="header-anchor" href="#theory"><span>Theory</span></a></h2><p>最开始，每个元素分属一个类型，可以初始化一个数组，数组中的每个元素分别代表一个类型：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">collection</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> collection<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    collection<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时集合图示为：</p><p><img src="`+p+'" alt="disjoint-set-init"></p><p>接下来，随着条件的给出 (比如元素 A 和元素 B 同属一类)，分属不同集合的元素需要被合并到一个集合中：</p><p><img src="'+o+'" alt="disjoint-set-connect"></p><p>在每个集合中，都会有一个 <strong>代表元素</strong> (即根结点)。只需要使元素中的代表元素指向要合并的元素，就能合并集合：</p><p><img src="'+i+`" alt="disjoint-set-merge"></p><p>以上过程完全可以由一个数组来实现：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">int</span> <span class="token function">find_root</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>collection<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> collection<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> i <span class="token operator">?</span> i <span class="token operator">:</span> <span class="token function">find_root</span><span class="token punctuation">(</span>collection<span class="token punctuation">,</span> collection<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>实战中，有更好的 <code>find_root()</code> 实现方式。</p></blockquote><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    collection<span class="token punctuation">[</span><span class="token function">find_root</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find_root</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="path-compression" tabindex="-1"><a class="header-anchor" href="#path-compression"><span>Path Compression</span></a></h2><p>随着集合的合并，可能会导致形成越来越长的链，从而导致每次的 <strong>查询</strong> 操作耗时长。可以对路径进行压缩，从而优化查询操作的时间复杂度：</p><p><img src="`+c+`" alt="disjoint-set-path-compression"></p><p>另一种实现的 <code>find_root()</code> 算法能够在合并分组的同时，顺便实现路径压缩。在递归结束后，顺便更新每个结点所在集合的 root 结点：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">int</span> <span class="token function">find_root</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>collection<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> collection<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> i <span class="token operator">?</span></span>
<span class="line">            i <span class="token operator">:</span></span>
<span class="line">            collection<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find_root</span><span class="token punctuation">(</span>collection<span class="token punctuation">,</span> collection<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在实际使用中，如果需要形成真正 unique 的并查集，在合并分组完成后，还要额外单独进行一轮路径压缩。这是由于 for 循环遍历的先后顺序导致的。</p></blockquote><h2 id="rank" tabindex="-1"><a class="header-anchor" href="#rank"><span>Rank</span></a></h2><p>两个集合合并时，原则上应当使简单的集合并入复杂的结合中，这样到根结点的路径变长的结点数更少：</p><p><img src="`+l+'" alt="disjoint-set-rank"></p><p>可以为每个结点维护一个 <code>rank[]</code> 数组，记录以每个结点为根的树深度。一开始所有元素的深度都为 1。合并时，把深度较小的结点往深度较大的结点上合并。</p><p>路径压缩和按秩合并同时启用时，树的深度将会变得不准确，但是总比没有按秩合并的性能要好。</p><hr><h2 id="references" tabindex="-1"><a class="header-anchor" href="#references"><span>References</span></a></h2><p><a href="https://zhuanlan.zhihu.com/p/93647900/" target="_blank" rel="noopener noreferrer">知乎专栏 - 算法学习笔记 (1)：并查集</a></p>',35)]))}const h=s(r,[["render",u],["__file","Algorithm Disjoint Set.html.vue"]]),m=JSON.parse('{"path":"/notes/Algorithm/Algorithm%20Disjoint%20Set.html","title":"Algorithm - Disjoint Set","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"About","slug":"about","link":"#about","children":[]},{"level":2,"title":"Theory","slug":"theory","link":"#theory","children":[]},{"level":2,"title":"Path Compression","slug":"path-compression","link":"#path-compression","children":[]},{"level":2,"title":"Rank","slug":"rank","link":"#rank","children":[]},{"level":2,"title":"References","slug":"references","link":"#references","children":[]}],"git":{},"filePathRelative":"notes/Algorithm/Algorithm Disjoint Set.md"}');export{h as comp,m as data};
